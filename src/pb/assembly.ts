namespace __proto {
  /**
   * Decoder implements protobuf message decode interface.
   *
   * Useful references:
   *
   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
   */
  export class Decoder {
    public view: DataView;
    public pos: i32;

    constructor(view: DataView) {
      this.view = view;
      this.pos = 0;
    }

    /**
     * Returns true if current reader has reached the buffer end
     * @returns True if current reader has reached the buffer end
     */
    @inline
    eof(): bool {
      return this.pos >= this.view.byteLength;
    }

    /**
     * Returns current buffer length in bytes
     * @returns Length in bytes
     */
    @inline
    get byteLength(): i32 {
      return this.view.byteLength;
    }

    /**
     * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].
     * TODO: Replace with return tuple when tuples become implemented in AS.
     * @returns Message tag value
     */
    @inline
    tag(): u32 {
      return this.uint32();
    }

    /**
     * Returns byte at offset, alias for getUint8
     * @param byteOffset Offset
     * @returns u8
     */
    @inline
    private u8at(byteOffset: i32): u8 {
      return this.view.getUint8(byteOffset);
    }

    /**
     * Reads and returns varint number (128 + 10 bits max) from a current position.
     * @returns Returns varint
     */
    varint(): u64 {
      let value: u64;

      // u32
      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      // u32 remainder or u64 byte
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      // u64
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value =
        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>
        0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;
      // u64 remainder
      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;
      if (u8(this.u8at(this.pos++)) < 128) return value;

      if (this.pos > this.byteLength) {
        this.throwOutOfRange();
      }

      return value;
    }

    @inline
    int32(): i32 {
      return i32(this.varint());
    }

    @inline
    int64(): i64 {
      return i32(this.varint());
    }

    @inline
    uint32(): u32 {
      return u32(this.varint());
    }

    @inline
    uint64(): u64 {
      return u64(this.varint());
    }

    @inline
    sint32(): i32 {
      const n: u64 = this.varint();
      return i32((n >>> 1) ^ -(n & 1));
    }

    @inline
    sint64(): i64 {
      const n: u64 = this.varint();
      return i64((n >>> 1) ^ -(n & 1));
    }

    fixed32(): u32 {
      this.pos += 4;
      if (this.pos > this.byteLength) {
        this.throwOutOfRange();
      }

      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)
      return (
        u32(u8(this.u8at(this.pos - 4))) |
        (u32(u8(this.u8at(this.pos - 3))) << 8) |
        (u32(u8(this.u8at(this.pos - 2))) << 16) |
        (u32(u8(this.u8at(this.pos - 1))) << 24)
      );
    }

    @inline
    sfixed32(): i32 {
      return i32(this.fixed32());
    }

    fixed64(): u64 {
      this.pos += 8;
      if (this.pos > this.byteLength) {
        this.throwOutOfRange();
      }

      return (
        u64(u8(this.u8at(this.pos - 8))) |
        (u64(u8(this.u8at(this.pos - 7))) << 8) |
        (u64(u8(this.u8at(this.pos - 6))) << 16) |
        (u64(u8(this.u8at(this.pos - 5))) << 24) |
        (u64(u8(this.u8at(this.pos - 4))) << 32) |
        (u64(u8(this.u8at(this.pos - 3))) << 40) |
        (u64(u8(this.u8at(this.pos - 2))) << 48) |
        (u64(u8(this.u8at(this.pos - 1))) << 56)
      );
    }

    @inline
    sfixed64(): i64 {
      return i64(this.fixed64());
    }

    @inline
    float(): f32 {
      return f32.reinterpret_i32(this.fixed32());
    }

    @inline
    double(): f64 {
      return f64.reinterpret_i64(this.fixed64());
    }

    @inline
    bool(): boolean {
      return this.uint32() > 0;
    }

    /**
     * Reads and returns UTF8 string.
     * @returns String
     */
    string(): string {
      const length = this.uint32();
      if (this.pos + length > this.byteLength) {
        this.throwOutOfRange();
      }

      const p = this.pos + this.view.byteOffset;
      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));
      this.pos += length;
      return value;
    }

    /**
     * Reads and returns bytes array.
     * @returns Array<u8> of bytes
     */
    bytes(): Array<u8> {
      const len = this.uint32();
      if (this.pos + len > this.byteLength) {
        this.throwOutOfRange();
      }

      const a = new Array<u8>(len);
      for (let i: u32 = 0; i < len; i++) {
        a[i] = u8(this.u8at(this.pos++));
      }

      return a;
    }

    /**
     * Skips a message field if it can'be recognized by an object's decode() method
     * @param wireType Current wire type
     */
    skipType(wireType: u32): void {
      switch (wireType) {
        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length
        case 0:
          this.varint(); // Just read a varint
          break;
        // fixed64, sfixed64, double: 8 bytes always
        case 1:
          this.skip(8);
          break;
        // length-delimited; length is determined by varint32; skip length bytes;
        case 2:
          this.skip(this.uint32());
          break;
        // tart group: skip till the end of the group, then skip group end marker
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        // fixed32, sfixed32, float: 4 bytes always
        case 5:
          this.skip(4);
          break;

        // Something went beyond our capability to understand
        default:
          throw new Error(
            `Invalid wire type ${wireType} at offset ${this.pos}`
          );
      }
    }

    /**
     * Fast-forwards cursor by length with boundary check
     * @param length Byte length
     */
    skip(length: u32): void {
      if (this.pos + length > this.byteLength) {
        this.throwOutOfRange();
      }
      this.pos += length;
    }

    /**
     * OutOfRange check. Throws an exception if current position exceeds current buffer range
     */
    @inline
    private throwOutOfRange(): void {
      throw new Error(`Decoder position ${this.pos} is out of range!`);
    }
  }

  /**
   * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses
   * Array<u8>.
   *
   * Useful references:
   *
   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding
   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128
   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
   */
  export class Encoder {
    public buf: Array<u8>;

    constructor(buf: Array<u8>) {
      this.buf = buf;
    }

    /**
     * Encodes varint at a current position
     * @returns Returns varint
     */
    varint64(value: u64): void {
      let v: u64 = value;

      while (v > 127) {
        this.buf.push(u8((v & 127) | 128));
        v = v >> 7;
      }

      this.buf.push(u8(v));
    }

    @inline
    int32(value: i32): void {
      this.varint64(value);
    }

    @inline
    int64(value: i64): void {
      this.varint64(value);
    }

    @inline
    uint32(value: u32): void {
      this.varint64(value);
    }

    @inline
    uint64(value: u64): void {
      this.varint64(value);
    }

    @inline
    sint32(value: i32): void {
      this.varint64((value << 1) ^ (value >> 31));
    }

    @inline
    sint64(value: i64): void {
      this.varint64((value << 1) ^ (value >> 63));
    }

    @inline
    fixed32(value: u32): void {
      this.buf.push(u8(value & 255));
      this.buf.push(u8((value >> 8) & 255));
      this.buf.push(u8((value >> 16) & 255));
      this.buf.push(u8(value >> 24));
    }

    @inline
    sfixed32(value: i32): void {
      this.fixed32(u32(value));
    }

    @inline
    fixed64(value: u64): void {
      this.buf.push(u8(value & 255));
      this.buf.push(u8((value >> 8) & 255));
      this.buf.push(u8((value >> 16) & 255));
      this.buf.push(u8((value >> 24) & 255));
      this.buf.push(u8((value >> 32) & 255));
      this.buf.push(u8((value >> 40) & 255));
      this.buf.push(u8((value >> 48) & 255));
      this.buf.push(u8(value >> 56));
    }

    @inline
    sfixed64(value: i64): void {
      this.fixed64(u64(value));
    }

    @inline
    float(value: f32): void {
      this.fixed32(u32(i32.reinterpret_f32(value)));
    }

    @inline
    double(value: f64): void {
      this.fixed64(u64(i64.reinterpret_f64(value)));
    }

    @inline
    bool(value: boolean): void {
      this.buf.push(value ? 1 : 0);
    }

    string(value: string): void {
      const utf8string = new DataView(String.UTF8.encode(value));

      for (let i = 0; i < utf8string.byteLength; i++) {
        this.buf.push(utf8string.getUint8(i));
      }
    }

    @inline
    bytes(value: Array<u8>): void {
      for (let i = 0; i < value.length; i++) {
        this.buf.push(value[i]);
      }
    }
  }

  /**
   * Returns byte size required to encode a value of a certain type
   */
  export class Sizer {
    static varint64(value: u64): u32 {
      return value < 128
        ? 1 // 2^7
        : value < 16384
        ? 2 // 2^14
        : value < 2097152
        ? 3 // 2^21
        : value < 268435456
        ? 4 // 2^28
        : value < 34359738368
        ? 5 // 2^35
        : value < 4398046511104
        ? 6 // 2^42
        : value < 562949953421312
        ? 7 // 2^49
        : value < 72057594037927936
        ? 8 // 2^56
        : value < 9223372036854775808
        ? 9 // 2^63
        : 10;
    }

    @inline
    static int32(value: i32): u32 {
      return Sizer.varint64(u64(value));
    }

    @inline
    static int64(value: i64): u32 {
      return Sizer.varint64(u64(value));
    }

    @inline
    static uint32(value: u32): u32 {
      return Sizer.varint64(value);
    }

    @inline
    static uint64(value: u64): u32 {
      return Sizer.varint64(value);
    }

    @inline
    static sint32(value: i32): u32 {
      return Sizer.varint64((value << 1) ^ (value >> 31));
    }

    @inline
    static sint64(value: i64): u32 {
      return Sizer.varint64((value << 1) ^ (value >> 63));
    }

    @inline
    static string(value: string): u32 {
      return value.length;
    }

    @inline
    static bytes(value: Array<u8>): u32 {
      return value.length;
    }
  }
}
export namespace sf {
  export namespace near {
    export namespace codec {
      export namespace v1 {
        export enum CurveKind {
          ED25519 = 0,
          SECP256K1 = 1,
        } // CurveKind
        export enum ExecutionMetadata {
          ExecutionMetadataV1 = 0,
        } // ExecutionMetadata
        // todo: add more detail?
        export enum FunctionCallErrorSer {
          CompilationError = 0,
          LinkError = 1,
          MethodResolveError = 2,
          WasmTrap = 3,
          WasmUnknownError = 4,
          HostError = 5,
          _EVMError = 6,
          ExecutionError = 7,
        } // FunctionCallErrorSer
        // todo: add more detail?
        export enum ReceiptValidationError {
          InvalidPredecessorId = 0,
          InvalidReceiverAccountId = 1,
          InvalidSignerAccountId = 2,
          InvalidDataReceiverId = 3,
          ReturnedValueLengthExceeded = 4,
          NumberInputDataDependenciesExceeded = 5,
          ActionsValidationError = 6,
        } // ReceiptValidationError
        // todo: add more detail?
        export enum InvalidTxError {
          InvalidAccessKeyError = 0,
          InvalidSignerId = 1,
          SignerDoesNotExist = 2,
          InvalidNonce = 3,
          NonceTooLarge = 4,
          InvalidReceiverId = 5,
          InvalidSignature = 6,
          NotEnoughBalance = 7,
          LackBalanceForState = 8,
          CostOverflow = 9,
          InvalidChain = 10,
          Expired = 11,
          ActionsValidation = 12,
          TransactionSizeExceeded = 13,
        } // InvalidTxError
        export enum Direction {
          left = 0,
          right = 1,
        } // Direction
        export class Block {
          public author: string = "";
          public header: BlockHeader = new BlockHeader();
          public chunk_headers: Array<ChunkHeader> = new Array<ChunkHeader>();
          public shards: Array<IndexerShard> = new Array<IndexerShard>();
          public state_changes: Array<StateChangeWithCause> =
            new Array<StateChangeWithCause>();

          // Decodes Block from an ArrayBuffer
          static decode(buf: ArrayBuffer): Block {
            return Block.decodeDataView(new DataView(buf));
          }

          // Decodes Block from a DataView
          static decodeDataView(view: DataView): Block {
            const decoder = new __proto.Decoder(view);
            const obj = new Block();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.author = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.header = BlockHeader.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.chunk_headers.push(
                    ChunkHeader.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.shards.push(
                    IndexerShard.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.state_changes.push(
                    StateChangeWithCause.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode Block

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.author.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.author.length) +
                  this.author.length
                : 0;

            if (this.header != null) {
              const f: BlockHeader = this.header as BlockHeader;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
              const messageSize = this.chunk_headers[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.shards.length; n++) {
              const messageSize = this.shards[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.state_changes.length; n++) {
              const messageSize = this.state_changes[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes Block to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes Block to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.author.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.author.length);
              encoder.string(this.author);
            }

            if (this.header != null) {
              const f = this.header as BlockHeader;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
              const messageSize = this.chunk_headers[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                this.chunk_headers[n].encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.shards.length; n++) {
              const messageSize = this.shards[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                this.shards[n].encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.state_changes.length; n++) {
              const messageSize = this.state_changes[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                this.state_changes[n].encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode Block
        } // Block

        /**
         * HeaderOnlyBlock is a standard [Block] structure where all other fields are
         *  removed so that hydrating that object from a [Block] bytes payload will
         *  drastically reduced allocated memory required to hold the full block.
         *
         *  This can be used to unpack a [Block] when only the [BlockHeader] information
         *  is required and greatly reduced required memory.
         */
        export class HeaderOnlyBlock {
          public header: BlockHeader = new BlockHeader();

          // Decodes HeaderOnlyBlock from an ArrayBuffer
          static decode(buf: ArrayBuffer): HeaderOnlyBlock {
            return HeaderOnlyBlock.decodeDataView(new DataView(buf));
          }

          // Decodes HeaderOnlyBlock from a DataView
          static decodeDataView(view: DataView): HeaderOnlyBlock {
            const decoder = new __proto.Decoder(view);
            const obj = new HeaderOnlyBlock();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 2: {
                  const length = decoder.uint32();
                  obj.header = BlockHeader.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode HeaderOnlyBlock

          public size(): u32 {
            let size: u32 = 0;

            if (this.header != null) {
              const f: BlockHeader = this.header as BlockHeader;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes HeaderOnlyBlock to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes HeaderOnlyBlock to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.header != null) {
              const f = this.header as BlockHeader;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode HeaderOnlyBlock
        } // HeaderOnlyBlock

        export class StateChangeWithCause {
          public value: StateChangeValue = new StateChangeValue();
          public cause: StateChangeCause = new StateChangeCause();

          // Decodes StateChangeWithCause from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeWithCause {
            return StateChangeWithCause.decodeDataView(new DataView(buf));
          }

          // Decodes StateChangeWithCause from a DataView
          static decodeDataView(view: DataView): StateChangeWithCause {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeWithCause();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.value = StateChangeValue.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.cause = StateChangeCause.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeWithCause

          public size(): u32 {
            let size: u32 = 0;

            if (this.value != null) {
              const f: StateChangeValue = this.value as StateChangeValue;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.cause != null) {
              const f: StateChangeCause = this.cause as StateChangeCause;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeWithCause to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeWithCause to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.value != null) {
              const f = this.value as StateChangeValue;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.cause != null) {
              const f = this.cause as StateChangeCause;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeWithCause
        } // StateChangeWithCause

        // / A top-level account ID can only be created by registrar.
        export class StateChangeCause {
          public not_writable_to_disk: StateChangeCause_NotWritableToDisk | null;
          public initial_state: StateChangeCause_InitialState | null;
          public transaction_processing: StateChangeCause_TransactionProcessing | null;
          public action_receipt_processing_started: StateChangeCause_ActionReceiptProcessingStarted | null;
          public action_receipt_gas_reward: StateChangeCause_ActionReceiptGasReward | null;
          public receipt_processing: StateChangeCause_ReceiptProcessing | null;
          public postponed_receipt: StateChangeCause_PostponedReceipt | null;
          public updated_delayed_receipts: StateChangeCause_UpdatedDelayedReceipts | null;
          public validator_accounts_update: StateChangeCause_ValidatorAccountsUpdate | null;
          public migration: StateChangeCause_Migration | null;

          public __cause: string = "";
          public __cause_index: u8 = 0;

          static readonly CAUSE_NOT_WRITABLE_TO_DISK_INDEX: u8 = 1;
          static readonly CAUSE_INITIAL_STATE_INDEX: u8 = 2;
          static readonly CAUSE_TRANSACTION_PROCESSING_INDEX: u8 = 3;
          static readonly CAUSE_ACTION_RECEIPT_PROCESSING_STARTED_INDEX: u8 = 4;
          static readonly CAUSE_ACTION_RECEIPT_GAS_REWARD_INDEX: u8 = 5;
          static readonly CAUSE_RECEIPT_PROCESSING_INDEX: u8 = 6;
          static readonly CAUSE_POSTPONED_RECEIPT_INDEX: u8 = 7;
          static readonly CAUSE_UPDATED_DELAYED_RECEIPTS_INDEX: u8 = 8;
          static readonly CAUSE_VALIDATOR_ACCOUNTS_UPDATE_INDEX: u8 = 9;
          static readonly CAUSE_MIGRATION_INDEX: u8 = 10;

          // Decodes StateChangeCause from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause {
            return StateChangeCause.decodeDataView(new DataView(buf));
          }

          // Decodes StateChangeCause from a DataView
          static decodeDataView(view: DataView): StateChangeCause {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.not_writable_to_disk =
                    StateChangeCause_NotWritableToDisk.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "not_writable_to_disk";
                  obj.__cause_index = 1;
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.initial_state =
                    StateChangeCause_InitialState.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "initial_state";
                  obj.__cause_index = 2;
                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.transaction_processing =
                    StateChangeCause_TransactionProcessing.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "transaction_processing";
                  obj.__cause_index = 3;
                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.action_receipt_processing_started =
                    StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "action_receipt_processing_started";
                  obj.__cause_index = 4;
                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.action_receipt_gas_reward =
                    StateChangeCause_ActionReceiptGasReward.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "action_receipt_gas_reward";
                  obj.__cause_index = 5;
                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.receipt_processing =
                    StateChangeCause_ReceiptProcessing.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "receipt_processing";
                  obj.__cause_index = 6;
                  break;
                }
                case 7: {
                  const length = decoder.uint32();
                  obj.postponed_receipt =
                    StateChangeCause_PostponedReceipt.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "postponed_receipt";
                  obj.__cause_index = 7;
                  break;
                }
                case 8: {
                  const length = decoder.uint32();
                  obj.updated_delayed_receipts =
                    StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "updated_delayed_receipts";
                  obj.__cause_index = 8;
                  break;
                }
                case 9: {
                  const length = decoder.uint32();
                  obj.validator_accounts_update =
                    StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__cause = "validator_accounts_update";
                  obj.__cause_index = 9;
                  break;
                }
                case 10: {
                  const length = decoder.uint32();
                  obj.migration = StateChangeCause_Migration.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__cause = "migration";
                  obj.__cause_index = 10;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause

          public size(): u32 {
            let size: u32 = 0;

            if (this.not_writable_to_disk != null) {
              const f: StateChangeCause_NotWritableToDisk = this
                .not_writable_to_disk as StateChangeCause_NotWritableToDisk;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.initial_state != null) {
              const f: StateChangeCause_InitialState = this
                .initial_state as StateChangeCause_InitialState;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.transaction_processing != null) {
              const f: StateChangeCause_TransactionProcessing = this
                .transaction_processing as StateChangeCause_TransactionProcessing;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.action_receipt_processing_started != null) {
              const f: StateChangeCause_ActionReceiptProcessingStarted = this
                .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.action_receipt_gas_reward != null) {
              const f: StateChangeCause_ActionReceiptGasReward = this
                .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.receipt_processing != null) {
              const f: StateChangeCause_ReceiptProcessing = this
                .receipt_processing as StateChangeCause_ReceiptProcessing;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.postponed_receipt != null) {
              const f: StateChangeCause_PostponedReceipt = this
                .postponed_receipt as StateChangeCause_PostponedReceipt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.updated_delayed_receipts != null) {
              const f: StateChangeCause_UpdatedDelayedReceipts = this
                .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.validator_accounts_update != null) {
              const f: StateChangeCause_ValidatorAccountsUpdate = this
                .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.migration != null) {
              const f: StateChangeCause_Migration = this
                .migration as StateChangeCause_Migration;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.not_writable_to_disk != null) {
              const f = this
                .not_writable_to_disk as StateChangeCause_NotWritableToDisk;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.initial_state != null) {
              const f = this.initial_state as StateChangeCause_InitialState;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.transaction_processing != null) {
              const f = this
                .transaction_processing as StateChangeCause_TransactionProcessing;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.action_receipt_processing_started != null) {
              const f = this
                .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.action_receipt_gas_reward != null) {
              const f = this
                .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.receipt_processing != null) {
              const f = this
                .receipt_processing as StateChangeCause_ReceiptProcessing;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.postponed_receipt != null) {
              const f = this
                .postponed_receipt as StateChangeCause_PostponedReceipt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.updated_delayed_receipts != null) {
              const f = this
                .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x42);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.validator_accounts_update != null) {
              const f = this
                .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.migration != null) {
              const f = this.migration as StateChangeCause_Migration;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x52);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause
        } // StateChangeCause

        export class StateChangeCause_NotWritableToDisk {
          // Decodes StateChangeCause_NotWritableToDisk from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause_NotWritableToDisk {
            return StateChangeCause_NotWritableToDisk.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_NotWritableToDisk from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_NotWritableToDisk {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_NotWritableToDisk();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_NotWritableToDisk

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes StateChangeCause_NotWritableToDisk to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_NotWritableToDisk to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode StateChangeCause_NotWritableToDisk
        } // StateChangeCause_NotWritableToDisk

        export class StateChangeCause_InitialState {
          // Decodes StateChangeCause_InitialState from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause_InitialState {
            return StateChangeCause_InitialState.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_InitialState from a DataView
          static decodeDataView(view: DataView): StateChangeCause_InitialState {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_InitialState();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_InitialState

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes StateChangeCause_InitialState to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_InitialState to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode StateChangeCause_InitialState
        } // StateChangeCause_InitialState

        export class StateChangeCause_TransactionProcessing {
          public tx_hash: CryptoHash = new CryptoHash();

          // Decodes StateChangeCause_TransactionProcessing from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeCause_TransactionProcessing {
            return StateChangeCause_TransactionProcessing.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_TransactionProcessing from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_TransactionProcessing {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_TransactionProcessing();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.tx_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_TransactionProcessing

          public size(): u32 {
            let size: u32 = 0;

            if (this.tx_hash != null) {
              const f: CryptoHash = this.tx_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause_TransactionProcessing to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_TransactionProcessing to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.tx_hash != null) {
              const f = this.tx_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause_TransactionProcessing
        } // StateChangeCause_TransactionProcessing

        export class StateChangeCause_ActionReceiptProcessingStarted {
          public receipt_hash: CryptoHash = new CryptoHash();

          // Decodes StateChangeCause_ActionReceiptProcessingStarted from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeCause_ActionReceiptProcessingStarted {
            return StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_ActionReceiptProcessingStarted from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_ActionReceiptProcessingStarted {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_ActionReceiptProcessingStarted();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.receipt_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_ActionReceiptProcessingStarted

          public size(): u32 {
            let size: u32 = 0;

            if (this.receipt_hash != null) {
              const f: CryptoHash = this.receipt_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause_ActionReceiptProcessingStarted to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_ActionReceiptProcessingStarted to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.receipt_hash != null) {
              const f = this.receipt_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause_ActionReceiptProcessingStarted
        } // StateChangeCause_ActionReceiptProcessingStarted

        export class StateChangeCause_ActionReceiptGasReward {
          public tx_hash: CryptoHash = new CryptoHash();

          // Decodes StateChangeCause_ActionReceiptGasReward from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeCause_ActionReceiptGasReward {
            return StateChangeCause_ActionReceiptGasReward.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_ActionReceiptGasReward from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_ActionReceiptGasReward {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_ActionReceiptGasReward();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.tx_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_ActionReceiptGasReward

          public size(): u32 {
            let size: u32 = 0;

            if (this.tx_hash != null) {
              const f: CryptoHash = this.tx_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause_ActionReceiptGasReward to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_ActionReceiptGasReward to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.tx_hash != null) {
              const f = this.tx_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause_ActionReceiptGasReward
        } // StateChangeCause_ActionReceiptGasReward

        export class StateChangeCause_ReceiptProcessing {
          public tx_hash: CryptoHash = new CryptoHash();

          // Decodes StateChangeCause_ReceiptProcessing from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause_ReceiptProcessing {
            return StateChangeCause_ReceiptProcessing.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_ReceiptProcessing from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_ReceiptProcessing {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_ReceiptProcessing();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.tx_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_ReceiptProcessing

          public size(): u32 {
            let size: u32 = 0;

            if (this.tx_hash != null) {
              const f: CryptoHash = this.tx_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause_ReceiptProcessing to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_ReceiptProcessing to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.tx_hash != null) {
              const f = this.tx_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause_ReceiptProcessing
        } // StateChangeCause_ReceiptProcessing

        export class StateChangeCause_PostponedReceipt {
          public tx_hash: CryptoHash = new CryptoHash();

          // Decodes StateChangeCause_PostponedReceipt from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause_PostponedReceipt {
            return StateChangeCause_PostponedReceipt.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_PostponedReceipt from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_PostponedReceipt {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_PostponedReceipt();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.tx_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_PostponedReceipt

          public size(): u32 {
            let size: u32 = 0;

            if (this.tx_hash != null) {
              const f: CryptoHash = this.tx_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeCause_PostponedReceipt to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_PostponedReceipt to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.tx_hash != null) {
              const f = this.tx_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeCause_PostponedReceipt
        } // StateChangeCause_PostponedReceipt

        export class StateChangeCause_UpdatedDelayedReceipts {
          // Decodes StateChangeCause_UpdatedDelayedReceipts from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeCause_UpdatedDelayedReceipts {
            return StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_UpdatedDelayedReceipts from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_UpdatedDelayedReceipts {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_UpdatedDelayedReceipts();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_UpdatedDelayedReceipts

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes StateChangeCause_UpdatedDelayedReceipts to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_UpdatedDelayedReceipts to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode StateChangeCause_UpdatedDelayedReceipts
        } // StateChangeCause_UpdatedDelayedReceipts

        export class StateChangeCause_ValidatorAccountsUpdate {
          // Decodes StateChangeCause_ValidatorAccountsUpdate from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeCause_ValidatorAccountsUpdate {
            return StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeCause_ValidatorAccountsUpdate from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeCause_ValidatorAccountsUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_ValidatorAccountsUpdate();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_ValidatorAccountsUpdate

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes StateChangeCause_ValidatorAccountsUpdate to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_ValidatorAccountsUpdate to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode StateChangeCause_ValidatorAccountsUpdate
        } // StateChangeCause_ValidatorAccountsUpdate

        export class StateChangeCause_Migration {
          // Decodes StateChangeCause_Migration from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeCause_Migration {
            return StateChangeCause_Migration.decodeDataView(new DataView(buf));
          }

          // Decodes StateChangeCause_Migration from a DataView
          static decodeDataView(view: DataView): StateChangeCause_Migration {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeCause_Migration();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeCause_Migration

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes StateChangeCause_Migration to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeCause_Migration to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode StateChangeCause_Migration
        } // StateChangeCause_Migration

        export class StateChangeValue {
          public account_update: StateChangeValue_AccountUpdate | null;
          public account_deletion: StateChangeValue_AccountDeletion | null;
          public access_key_update: StateChangeValue_AccessKeyUpdate | null;
          public access_key_deletion: StateChangeValue_AccessKeyDeletion | null;
          public data_update: StateChangeValue_DataUpdate | null;
          public data_deletion: StateChangeValue_DataDeletion | null;
          public contract_code_update: StateChangeValue_ContractCodeUpdate | null;
          public contract_deletion: StateChangeValue_ContractCodeDeletion | null;

          public __value: string = "";
          public __value_index: u8 = 0;

          static readonly VALUE_ACCOUNT_UPDATE_INDEX: u8 = 1;
          static readonly VALUE_ACCOUNT_DELETION_INDEX: u8 = 2;
          static readonly VALUE_ACCESS_KEY_UPDATE_INDEX: u8 = 3;
          static readonly VALUE_ACCESS_KEY_DELETION_INDEX: u8 = 4;
          static readonly VALUE_DATA_UPDATE_INDEX: u8 = 5;
          static readonly VALUE_DATA_DELETION_INDEX: u8 = 6;
          static readonly VALUE_CONTRACT_CODE_UPDATE_INDEX: u8 = 7;
          static readonly VALUE_CONTRACT_DELETION_INDEX: u8 = 8;

          // Decodes StateChangeValue from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue {
            return StateChangeValue.decodeDataView(new DataView(buf));
          }

          // Decodes StateChangeValue from a DataView
          static decodeDataView(view: DataView): StateChangeValue {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.account_update =
                    StateChangeValue_AccountUpdate.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "account_update";
                  obj.__value_index = 1;
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.account_deletion =
                    StateChangeValue_AccountDeletion.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "account_deletion";
                  obj.__value_index = 2;
                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.access_key_update =
                    StateChangeValue_AccessKeyUpdate.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "access_key_update";
                  obj.__value_index = 3;
                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.access_key_deletion =
                    StateChangeValue_AccessKeyDeletion.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "access_key_deletion";
                  obj.__value_index = 4;
                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.data_update = StateChangeValue_DataUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__value = "data_update";
                  obj.__value_index = 5;
                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.data_deletion =
                    StateChangeValue_DataDeletion.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "data_deletion";
                  obj.__value_index = 6;
                  break;
                }
                case 7: {
                  const length = decoder.uint32();
                  obj.contract_code_update =
                    StateChangeValue_ContractCodeUpdate.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "contract_code_update";
                  obj.__value_index = 7;
                  break;
                }
                case 8: {
                  const length = decoder.uint32();
                  obj.contract_deletion =
                    StateChangeValue_ContractCodeDeletion.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__value = "contract_deletion";
                  obj.__value_index = 8;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue

          public size(): u32 {
            let size: u32 = 0;

            if (this.account_update != null) {
              const f: StateChangeValue_AccountUpdate = this
                .account_update as StateChangeValue_AccountUpdate;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.account_deletion != null) {
              const f: StateChangeValue_AccountDeletion = this
                .account_deletion as StateChangeValue_AccountDeletion;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.access_key_update != null) {
              const f: StateChangeValue_AccessKeyUpdate = this
                .access_key_update as StateChangeValue_AccessKeyUpdate;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.access_key_deletion != null) {
              const f: StateChangeValue_AccessKeyDeletion = this
                .access_key_deletion as StateChangeValue_AccessKeyDeletion;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.data_update != null) {
              const f: StateChangeValue_DataUpdate = this
                .data_update as StateChangeValue_DataUpdate;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.data_deletion != null) {
              const f: StateChangeValue_DataDeletion = this
                .data_deletion as StateChangeValue_DataDeletion;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.contract_code_update != null) {
              const f: StateChangeValue_ContractCodeUpdate = this
                .contract_code_update as StateChangeValue_ContractCodeUpdate;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.contract_deletion != null) {
              const f: StateChangeValue_ContractCodeDeletion = this
                .contract_deletion as StateChangeValue_ContractCodeDeletion;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeValue to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_update != null) {
              const f = this.account_update as StateChangeValue_AccountUpdate;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.account_deletion != null) {
              const f = this
                .account_deletion as StateChangeValue_AccountDeletion;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.access_key_update != null) {
              const f = this
                .access_key_update as StateChangeValue_AccessKeyUpdate;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.access_key_deletion != null) {
              const f = this
                .access_key_deletion as StateChangeValue_AccessKeyDeletion;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.data_update != null) {
              const f = this.data_update as StateChangeValue_DataUpdate;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.data_deletion != null) {
              const f = this.data_deletion as StateChangeValue_DataDeletion;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.contract_code_update != null) {
              const f = this
                .contract_code_update as StateChangeValue_ContractCodeUpdate;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.contract_deletion != null) {
              const f = this
                .contract_deletion as StateChangeValue_ContractCodeDeletion;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x42);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeValue
        } // StateChangeValue

        export class StateChangeValue_AccountUpdate {
          public account_id: string = "";
          public account: Account = new Account();

          // Decodes StateChangeValue_AccountUpdate from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_AccountUpdate {
            return StateChangeValue_AccountUpdate.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_AccountUpdate from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_AccountUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_AccountUpdate();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.account = Account.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_AccountUpdate

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.account != null) {
              const f: Account = this.account as Account;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeValue_AccountUpdate to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_AccountUpdate to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.account != null) {
              const f = this.account as Account;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeValue_AccountUpdate
        } // StateChangeValue_AccountUpdate

        export class StateChangeValue_AccountDeletion {
          public account_id: string = "";

          // Decodes StateChangeValue_AccountDeletion from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_AccountDeletion {
            return StateChangeValue_AccountDeletion.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_AccountDeletion from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_AccountDeletion {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_AccountDeletion();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_AccountDeletion

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes StateChangeValue_AccountDeletion to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_AccountDeletion to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode StateChangeValue_AccountDeletion
        } // StateChangeValue_AccountDeletion

        export class StateChangeValue_AccessKeyUpdate {
          public account_id: string = "";
          public public_key: PublicKey = new PublicKey();
          public access_key: AccessKey = new AccessKey();

          // Decodes StateChangeValue_AccessKeyUpdate from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyUpdate {
            return StateChangeValue_AccessKeyUpdate.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_AccessKeyUpdate from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_AccessKeyUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_AccessKeyUpdate();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.access_key = AccessKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_AccessKeyUpdate

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.access_key != null) {
              const f: AccessKey = this.access_key as AccessKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeValue_AccessKeyUpdate to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_AccessKeyUpdate to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.access_key != null) {
              const f = this.access_key as AccessKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeValue_AccessKeyUpdate
        } // StateChangeValue_AccessKeyUpdate

        export class StateChangeValue_AccessKeyDeletion {
          public account_id: string = "";
          public public_key: PublicKey = new PublicKey();

          // Decodes StateChangeValue_AccessKeyDeletion from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyDeletion {
            return StateChangeValue_AccessKeyDeletion.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_AccessKeyDeletion from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_AccessKeyDeletion {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_AccessKeyDeletion();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_AccessKeyDeletion

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StateChangeValue_AccessKeyDeletion to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_AccessKeyDeletion to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StateChangeValue_AccessKeyDeletion
        } // StateChangeValue_AccessKeyDeletion

        export class StateChangeValue_DataUpdate {
          public account_id: string = "";
          public key: Array<u8> = new Array<u8>();
          public value: Array<u8> = new Array<u8>();

          // Decodes StateChangeValue_DataUpdate from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_DataUpdate {
            return StateChangeValue_DataUpdate.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_DataUpdate from a DataView
          static decodeDataView(view: DataView): StateChangeValue_DataUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_DataUpdate();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.key = decoder.bytes();
                  break;
                }
                case 3: {
                  obj.value = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_DataUpdate

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.key.length > 0
                ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
                : 0;
            size +=
              this.value.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.value.length) +
                  this.value.length
                : 0;

            return size;
          }

          // Encodes StateChangeValue_DataUpdate to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_DataUpdate to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.key.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.key.length);
              encoder.bytes(this.key);
            }
            if (this.value.length > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(this.value.length);
              encoder.bytes(this.value);
            }

            return buf;
          } // encode StateChangeValue_DataUpdate
        } // StateChangeValue_DataUpdate

        export class StateChangeValue_DataDeletion {
          public account_id: string = "";
          public key: Array<u8> = new Array<u8>();

          // Decodes StateChangeValue_DataDeletion from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_DataDeletion {
            return StateChangeValue_DataDeletion.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_DataDeletion from a DataView
          static decodeDataView(view: DataView): StateChangeValue_DataDeletion {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_DataDeletion();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.key = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_DataDeletion

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.key.length > 0
                ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
                : 0;

            return size;
          }

          // Encodes StateChangeValue_DataDeletion to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_DataDeletion to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.key.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.key.length);
              encoder.bytes(this.key);
            }

            return buf;
          } // encode StateChangeValue_DataDeletion
        } // StateChangeValue_DataDeletion

        export class StateChangeValue_ContractCodeUpdate {
          public account_id: string = "";
          public code: Array<u8> = new Array<u8>();

          // Decodes StateChangeValue_ContractCodeUpdate from an ArrayBuffer
          static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeUpdate {
            return StateChangeValue_ContractCodeUpdate.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_ContractCodeUpdate from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_ContractCodeUpdate {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_ContractCodeUpdate();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.code = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_ContractCodeUpdate

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.code.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.code.length) +
                  this.code.length
                : 0;

            return size;
          }

          // Encodes StateChangeValue_ContractCodeUpdate to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_ContractCodeUpdate to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.code.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.code.length);
              encoder.bytes(this.code);
            }

            return buf;
          } // encode StateChangeValue_ContractCodeUpdate
        } // StateChangeValue_ContractCodeUpdate

        export class StateChangeValue_ContractCodeDeletion {
          public account_id: string = "";

          // Decodes StateChangeValue_ContractCodeDeletion from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): StateChangeValue_ContractCodeDeletion {
            return StateChangeValue_ContractCodeDeletion.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes StateChangeValue_ContractCodeDeletion from a DataView
          static decodeDataView(
            view: DataView
          ): StateChangeValue_ContractCodeDeletion {
            const decoder = new __proto.Decoder(view);
            const obj = new StateChangeValue_ContractCodeDeletion();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StateChangeValue_ContractCodeDeletion

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes StateChangeValue_ContractCodeDeletion to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StateChangeValue_ContractCodeDeletion to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode StateChangeValue_ContractCodeDeletion
        } // StateChangeValue_ContractCodeDeletion

        export class Account {
          public amount: BigInt = new BigInt();
          public locked: BigInt = new BigInt();
          public code_hash: CryptoHash = new CryptoHash();
          public storage_usage: u64;

          // Decodes Account from an ArrayBuffer
          static decode(buf: ArrayBuffer): Account {
            return Account.decodeDataView(new DataView(buf));
          }

          // Decodes Account from a DataView
          static decodeDataView(view: DataView): Account {
            const decoder = new __proto.Decoder(view);
            const obj = new Account();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.amount = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.locked = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.code_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  obj.storage_usage = decoder.uint64();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode Account

          public size(): u32 {
            let size: u32 = 0;

            if (this.amount != null) {
              const f: BigInt = this.amount as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.locked != null) {
              const f: BigInt = this.locked as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.code_hash != null) {
              const f: CryptoHash = this.code_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.storage_usage == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.storage_usage);

            return size;
          }

          // Encodes Account to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes Account to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.amount != null) {
              const f = this.amount as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.locked != null) {
              const f = this.locked as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.code_hash != null) {
              const f = this.code_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.storage_usage != 0) {
              encoder.uint32(0x20);
              encoder.uint64(this.storage_usage);
            }

            return buf;
          } // encode Account
        } // Account

        export class BlockHeader {
          public height: u64;
          public prev_height: u64;
          public epoch_id: CryptoHash = new CryptoHash();
          public next_epoch_id: CryptoHash = new CryptoHash();
          public hash: CryptoHash = new CryptoHash();
          public prev_hash: CryptoHash = new CryptoHash();
          public prev_state_root: CryptoHash = new CryptoHash();
          public chunk_receipts_root: CryptoHash = new CryptoHash();
          public chunk_headers_root: CryptoHash = new CryptoHash();
          public chunk_tx_root: CryptoHash = new CryptoHash();
          public outcome_root: CryptoHash = new CryptoHash();
          public chunks_included: u64;
          public challenges_root: CryptoHash = new CryptoHash();
          public timestamp: u64;
          public timestamp_nanosec: u64;
          public random_value: CryptoHash = new CryptoHash();
          public validator_proposals: Array<ValidatorStake> =
            new Array<ValidatorStake>();
          public chunk_mask: Array<bool> = new Array<bool>();
          public gas_price: BigInt = new BigInt();
          public block_ordinal: u64;
          public total_supply: BigInt = new BigInt();
          public challenges_result: Array<SlashedValidator> =
            new Array<SlashedValidator>();
          public last_final_block_height: u64;
          public last_final_block: CryptoHash = new CryptoHash();
          public last_ds_final_block_height: u64;
          public last_ds_final_block: CryptoHash = new CryptoHash();
          public next_bp_hash: CryptoHash = new CryptoHash();
          public block_merkle_root: CryptoHash = new CryptoHash();
          public epoch_sync_data_hash: Array<u8> = new Array<u8>();
          public approvals: Array<Signature> = new Array<Signature>();
          public signature: Signature = new Signature();
          public latest_protocol_version: u32;

          // Decodes BlockHeader from an ArrayBuffer
          static decode(buf: ArrayBuffer): BlockHeader {
            return BlockHeader.decodeDataView(new DataView(buf));
          }

          // Decodes BlockHeader from a DataView
          static decodeDataView(view: DataView): BlockHeader {
            const decoder = new __proto.Decoder(view);
            const obj = new BlockHeader();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.height = decoder.uint64();
                  break;
                }
                case 2: {
                  obj.prev_height = decoder.uint64();
                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.epoch_id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.next_epoch_id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.prev_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 7: {
                  const length = decoder.uint32();
                  obj.prev_state_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 8: {
                  const length = decoder.uint32();
                  obj.chunk_receipts_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 9: {
                  const length = decoder.uint32();
                  obj.chunk_headers_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 10: {
                  const length = decoder.uint32();
                  obj.chunk_tx_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 11: {
                  const length = decoder.uint32();
                  obj.outcome_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 12: {
                  obj.chunks_included = decoder.uint64();
                  break;
                }
                case 13: {
                  const length = decoder.uint32();
                  obj.challenges_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 14: {
                  obj.timestamp = decoder.uint64();
                  break;
                }
                case 15: {
                  obj.timestamp_nanosec = decoder.uint64();
                  break;
                }
                case 16: {
                  const length = decoder.uint32();
                  obj.random_value = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 17: {
                  const length = decoder.uint32();
                  obj.validator_proposals.push(
                    ValidatorStake.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 18: {
                  const endPos = decoder.pos + decoder.uint32();
                  while (decoder.pos <= endPos) {
                    obj.chunk_mask.push(decoder.bool());
                  }

                  break;
                }
                case 19: {
                  const length = decoder.uint32();
                  obj.gas_price = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 20: {
                  obj.block_ordinal = decoder.uint64();
                  break;
                }
                case 21: {
                  const length = decoder.uint32();
                  obj.total_supply = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 22: {
                  const length = decoder.uint32();
                  obj.challenges_result.push(
                    SlashedValidator.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 23: {
                  obj.last_final_block_height = decoder.uint64();
                  break;
                }
                case 24: {
                  const length = decoder.uint32();
                  obj.last_final_block = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 25: {
                  obj.last_ds_final_block_height = decoder.uint64();
                  break;
                }
                case 26: {
                  const length = decoder.uint32();
                  obj.last_ds_final_block = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 27: {
                  const length = decoder.uint32();
                  obj.next_bp_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 28: {
                  const length = decoder.uint32();
                  obj.block_merkle_root = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 29: {
                  obj.epoch_sync_data_hash = decoder.bytes();
                  break;
                }
                case 30: {
                  const length = decoder.uint32();
                  obj.approvals.push(
                    Signature.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 31: {
                  const length = decoder.uint32();
                  obj.signature = Signature.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 32: {
                  obj.latest_protocol_version = decoder.uint32();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode BlockHeader

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.height == 0 ? 0 : 1 + __proto.Sizer.uint64(this.height);
            size +=
              this.prev_height == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.prev_height);

            if (this.epoch_id != null) {
              const f: CryptoHash = this.epoch_id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.next_epoch_id != null) {
              const f: CryptoHash = this.next_epoch_id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.hash != null) {
              const f: CryptoHash = this.hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.prev_hash != null) {
              const f: CryptoHash = this.prev_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.prev_state_root != null) {
              const f: CryptoHash = this.prev_state_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.chunk_receipts_root != null) {
              const f: CryptoHash = this.chunk_receipts_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.chunk_headers_root != null) {
              const f: CryptoHash = this.chunk_headers_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.chunk_tx_root != null) {
              const f: CryptoHash = this.chunk_tx_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.outcome_root != null) {
              const f: CryptoHash = this.outcome_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.chunks_included == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.chunks_included);

            if (this.challenges_root != null) {
              const f: CryptoHash = this.challenges_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.timestamp == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.timestamp);
            size +=
              this.timestamp_nanosec == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.timestamp_nanosec);

            if (this.random_value != null) {
              const f: CryptoHash = this.random_value as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
              const messageSize = this.validator_proposals[n].size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.chunk_mask.length > 0) {
              const packedSize = __size_bool_repeated_packed(this.chunk_mask);
              if (packedSize > 0) {
                size += 2 + __proto.Sizer.varint64(packedSize) + packedSize;
              }
            }

            if (this.gas_price != null) {
              const f: BigInt = this.gas_price as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.block_ordinal == 0
                ? 0
                : 2 + __proto.Sizer.uint64(this.block_ordinal);

            if (this.total_supply != null) {
              const f: BigInt = this.total_supply as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.challenges_result.length; n++) {
              const messageSize = this.challenges_result[n].size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.last_final_block_height == 0
                ? 0
                : 2 + __proto.Sizer.uint64(this.last_final_block_height);

            if (this.last_final_block != null) {
              const f: CryptoHash = this.last_final_block as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.last_ds_final_block_height == 0
                ? 0
                : 2 + __proto.Sizer.uint64(this.last_ds_final_block_height);

            if (this.last_ds_final_block != null) {
              const f: CryptoHash = this.last_ds_final_block as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.next_bp_hash != null) {
              const f: CryptoHash = this.next_bp_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.block_merkle_root != null) {
              const f: CryptoHash = this.block_merkle_root as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.epoch_sync_data_hash.length > 0
                ? 2 +
                  __proto.Sizer.varint64(this.epoch_sync_data_hash.length) +
                  this.epoch_sync_data_hash.length
                : 0;

            for (let n: i32 = 0; n < this.approvals.length; n++) {
              const messageSize = this.approvals[n].size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.signature != null) {
              const f: Signature = this.signature as Signature;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.latest_protocol_version == 0
                ? 0
                : 2 + __proto.Sizer.uint32(this.latest_protocol_version);

            return size;
          }

          // Encodes BlockHeader to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes BlockHeader to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.height != 0) {
              encoder.uint32(0x8);
              encoder.uint64(this.height);
            }
            if (this.prev_height != 0) {
              encoder.uint32(0x10);
              encoder.uint64(this.prev_height);
            }

            if (this.epoch_id != null) {
              const f = this.epoch_id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.next_epoch_id != null) {
              const f = this.next_epoch_id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.hash != null) {
              const f = this.hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.prev_hash != null) {
              const f = this.prev_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.prev_state_root != null) {
              const f = this.prev_state_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.chunk_receipts_root != null) {
              const f = this.chunk_receipts_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x42);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.chunk_headers_root != null) {
              const f = this.chunk_headers_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x4a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.chunk_tx_root != null) {
              const f = this.chunk_tx_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x52);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.outcome_root != null) {
              const f = this.outcome_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.chunks_included != 0) {
              encoder.uint32(0x60);
              encoder.uint64(this.chunks_included);
            }

            if (this.challenges_root != null) {
              const f = this.challenges_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x6a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.timestamp != 0) {
              encoder.uint32(0x70);
              encoder.uint64(this.timestamp);
            }
            if (this.timestamp_nanosec != 0) {
              encoder.uint32(0x78);
              encoder.uint64(this.timestamp_nanosec);
            }

            if (this.random_value != null) {
              const f = this.random_value as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x82);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
              const messageSize = this.validator_proposals[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x8a);
                encoder.uint32(messageSize);
                this.validator_proposals[n].encodeU8Array(encoder);
              }
            }

            if (this.chunk_mask.length > 0) {
              encoder.uint32(0x92);
              encoder.uint32(__size_bool_repeated_packed(this.chunk_mask));

              for (let n: i32 = 0; n < this.chunk_mask.length; n++) {
                encoder.bool(this.chunk_mask[n]);
              }
            }

            if (this.gas_price != null) {
              const f = this.gas_price as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x9a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.block_ordinal != 0) {
              encoder.uint32(0xa0);
              encoder.uint64(this.block_ordinal);
            }

            if (this.total_supply != null) {
              const f = this.total_supply as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xaa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.challenges_result.length; n++) {
              const messageSize = this.challenges_result[n].size();

              if (messageSize > 0) {
                encoder.uint32(0xb2);
                encoder.uint32(messageSize);
                this.challenges_result[n].encodeU8Array(encoder);
              }
            }

            if (this.last_final_block_height != 0) {
              encoder.uint32(0xb8);
              encoder.uint64(this.last_final_block_height);
            }

            if (this.last_final_block != null) {
              const f = this.last_final_block as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xc2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.last_ds_final_block_height != 0) {
              encoder.uint32(0xc8);
              encoder.uint64(this.last_ds_final_block_height);
            }

            if (this.last_ds_final_block != null) {
              const f = this.last_ds_final_block as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xd2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.next_bp_hash != null) {
              const f = this.next_bp_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xda);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.block_merkle_root != null) {
              const f = this.block_merkle_root as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xe2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.epoch_sync_data_hash.length > 0) {
              encoder.uint32(0xea);
              encoder.uint32(this.epoch_sync_data_hash.length);
              encoder.bytes(this.epoch_sync_data_hash);
            }

            for (let n: i32 = 0; n < this.approvals.length; n++) {
              const messageSize = this.approvals[n].size();

              if (messageSize > 0) {
                encoder.uint32(0xf2);
                encoder.uint32(messageSize);
                this.approvals[n].encodeU8Array(encoder);
              }
            }

            if (this.signature != null) {
              const f = this.signature as Signature;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xfa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.latest_protocol_version != 0) {
              encoder.uint32(0x100);
              encoder.uint32(this.latest_protocol_version);
            }

            return buf;
          } // encode BlockHeader
        } // BlockHeader

        export class BigInt {
          public bytes: Array<u8> = new Array<u8>();

          // Decodes BigInt from an ArrayBuffer
          static decode(buf: ArrayBuffer): BigInt {
            return BigInt.decodeDataView(new DataView(buf));
          }

          // Decodes BigInt from a DataView
          static decodeDataView(view: DataView): BigInt {
            const decoder = new __proto.Decoder(view);
            const obj = new BigInt();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.bytes = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode BigInt

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.bytes.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.bytes.length) +
                  this.bytes.length
                : 0;

            return size;
          }

          // Encodes BigInt to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes BigInt to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.bytes.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.bytes.length);
              encoder.bytes(this.bytes);
            }

            return buf;
          } // encode BigInt
        } // BigInt

        export class CryptoHash {
          public bytes: Array<u8> = new Array<u8>();

          // Decodes CryptoHash from an ArrayBuffer
          static decode(buf: ArrayBuffer): CryptoHash {
            return CryptoHash.decodeDataView(new DataView(buf));
          }

          // Decodes CryptoHash from a DataView
          static decodeDataView(view: DataView): CryptoHash {
            const decoder = new __proto.Decoder(view);
            const obj = new CryptoHash();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.bytes = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode CryptoHash

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.bytes.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.bytes.length) +
                  this.bytes.length
                : 0;

            return size;
          }

          // Encodes CryptoHash to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes CryptoHash to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.bytes.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.bytes.length);
              encoder.bytes(this.bytes);
            }

            return buf;
          } // encode CryptoHash
        } // CryptoHash

        export class Signature {
          public type: u32;
          public bytes: Array<u8> = new Array<u8>();

          // Decodes Signature from an ArrayBuffer
          static decode(buf: ArrayBuffer): Signature {
            return Signature.decodeDataView(new DataView(buf));
          }

          // Decodes Signature from a DataView
          static decodeDataView(view: DataView): Signature {
            const decoder = new __proto.Decoder(view);
            const obj = new Signature();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.type = decoder.uint32();
                  break;
                }
                case 2: {
                  obj.bytes = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode Signature

          public size(): u32 {
            let size: u32 = 0;

            size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
            size +=
              this.bytes.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.bytes.length) +
                  this.bytes.length
                : 0;

            return size;
          }

          // Encodes Signature to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes Signature to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.type != 0) {
              encoder.uint32(0x8);
              encoder.uint32(this.type);
            }
            if (this.bytes.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.bytes.length);
              encoder.bytes(this.bytes);
            }

            return buf;
          } // encode Signature
        } // Signature

        export class PublicKey {
          public type: u32;
          public bytes: Array<u8> = new Array<u8>();

          // Decodes PublicKey from an ArrayBuffer
          static decode(buf: ArrayBuffer): PublicKey {
            return PublicKey.decodeDataView(new DataView(buf));
          }

          // Decodes PublicKey from a DataView
          static decodeDataView(view: DataView): PublicKey {
            const decoder = new __proto.Decoder(view);
            const obj = new PublicKey();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.type = decoder.uint32();
                  break;
                }
                case 2: {
                  obj.bytes = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode PublicKey

          public size(): u32 {
            let size: u32 = 0;

            size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
            size +=
              this.bytes.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.bytes.length) +
                  this.bytes.length
                : 0;

            return size;
          }

          // Encodes PublicKey to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes PublicKey to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.type != 0) {
              encoder.uint32(0x8);
              encoder.uint32(this.type);
            }
            if (this.bytes.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.bytes.length);
              encoder.bytes(this.bytes);
            }

            return buf;
          } // encode PublicKey
        } // PublicKey

        export class ValidatorStake {
          public account_id: string = "";
          public public_key: PublicKey = new PublicKey();
          public stake: BigInt = new BigInt();

          // Decodes ValidatorStake from an ArrayBuffer
          static decode(buf: ArrayBuffer): ValidatorStake {
            return ValidatorStake.decodeDataView(new DataView(buf));
          }

          // Decodes ValidatorStake from a DataView
          static decodeDataView(view: DataView): ValidatorStake {
            const decoder = new __proto.Decoder(view);
            const obj = new ValidatorStake();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.stake = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ValidatorStake

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.stake != null) {
              const f: BigInt = this.stake as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes ValidatorStake to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ValidatorStake to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.stake != null) {
              const f = this.stake as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode ValidatorStake
        } // ValidatorStake

        export class SlashedValidator {
          public account_id: string = "";
          public is_double_sign: bool;

          // Decodes SlashedValidator from an ArrayBuffer
          static decode(buf: ArrayBuffer): SlashedValidator {
            return SlashedValidator.decodeDataView(new DataView(buf));
          }

          // Decodes SlashedValidator from a DataView
          static decodeDataView(view: DataView): SlashedValidator {
            const decoder = new __proto.Decoder(view);
            const obj = new SlashedValidator();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.is_double_sign = decoder.bool();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode SlashedValidator

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size += this.is_double_sign == 0 ? 0 : 1 + 1;

            return size;
          }

          // Encodes SlashedValidator to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes SlashedValidator to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.is_double_sign != 0) {
              encoder.uint32(0x10);
              encoder.bool(this.is_double_sign);
            }

            return buf;
          } // encode SlashedValidator
        } // SlashedValidator

        export class ChunkHeader {
          public chunk_hash: Array<u8> = new Array<u8>();
          public prev_block_hash: Array<u8> = new Array<u8>();
          public outcome_root: Array<u8> = new Array<u8>();
          public prev_state_root: Array<u8> = new Array<u8>();
          public encoded_merkle_root: Array<u8> = new Array<u8>();
          public encoded_length: u64;
          public height_created: u64;
          public height_included: u64;
          public shard_id: u64;
          public gas_used: u64;
          public gas_limit: u64;
          public validator_reward: BigInt = new BigInt();
          public balance_burnt: BigInt = new BigInt();
          public outgoing_receipts_root: Array<u8> = new Array<u8>();
          public tx_root: Array<u8> = new Array<u8>();
          public validator_proposals: Array<ValidatorStake> =
            new Array<ValidatorStake>();
          public signature: Signature = new Signature();

          // Decodes ChunkHeader from an ArrayBuffer
          static decode(buf: ArrayBuffer): ChunkHeader {
            return ChunkHeader.decodeDataView(new DataView(buf));
          }

          // Decodes ChunkHeader from a DataView
          static decodeDataView(view: DataView): ChunkHeader {
            const decoder = new __proto.Decoder(view);
            const obj = new ChunkHeader();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.chunk_hash = decoder.bytes();
                  break;
                }
                case 2: {
                  obj.prev_block_hash = decoder.bytes();
                  break;
                }
                case 3: {
                  obj.outcome_root = decoder.bytes();
                  break;
                }
                case 4: {
                  obj.prev_state_root = decoder.bytes();
                  break;
                }
                case 5: {
                  obj.encoded_merkle_root = decoder.bytes();
                  break;
                }
                case 6: {
                  obj.encoded_length = decoder.uint64();
                  break;
                }
                case 7: {
                  obj.height_created = decoder.uint64();
                  break;
                }
                case 8: {
                  obj.height_included = decoder.uint64();
                  break;
                }
                case 9: {
                  obj.shard_id = decoder.uint64();
                  break;
                }
                case 10: {
                  obj.gas_used = decoder.uint64();
                  break;
                }
                case 11: {
                  obj.gas_limit = decoder.uint64();
                  break;
                }
                case 12: {
                  const length = decoder.uint32();
                  obj.validator_reward = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 13: {
                  const length = decoder.uint32();
                  obj.balance_burnt = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 14: {
                  obj.outgoing_receipts_root = decoder.bytes();
                  break;
                }
                case 15: {
                  obj.tx_root = decoder.bytes();
                  break;
                }
                case 16: {
                  const length = decoder.uint32();
                  obj.validator_proposals.push(
                    ValidatorStake.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 17: {
                  const length = decoder.uint32();
                  obj.signature = Signature.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ChunkHeader

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.chunk_hash.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.chunk_hash.length) +
                  this.chunk_hash.length
                : 0;
            size +=
              this.prev_block_hash.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.prev_block_hash.length) +
                  this.prev_block_hash.length
                : 0;
            size +=
              this.outcome_root.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.outcome_root.length) +
                  this.outcome_root.length
                : 0;
            size +=
              this.prev_state_root.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.prev_state_root.length) +
                  this.prev_state_root.length
                : 0;
            size +=
              this.encoded_merkle_root.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.encoded_merkle_root.length) +
                  this.encoded_merkle_root.length
                : 0;
            size +=
              this.encoded_length == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.encoded_length);
            size +=
              this.height_created == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.height_created);
            size +=
              this.height_included == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.height_included);
            size +=
              this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);
            size +=
              this.gas_used == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_used);
            size +=
              this.gas_limit == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.gas_limit);

            if (this.validator_reward != null) {
              const f: BigInt = this.validator_reward as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.balance_burnt != null) {
              const f: BigInt = this.balance_burnt as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.outgoing_receipts_root.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.outgoing_receipts_root.length) +
                  this.outgoing_receipts_root.length
                : 0;
            size +=
              this.tx_root.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.tx_root.length) +
                  this.tx_root.length
                : 0;

            for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
              const messageSize = this.validator_proposals[n].size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.signature != null) {
              const f: Signature = this.signature as Signature;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes ChunkHeader to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ChunkHeader to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.chunk_hash.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.chunk_hash.length);
              encoder.bytes(this.chunk_hash);
            }
            if (this.prev_block_hash.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.prev_block_hash.length);
              encoder.bytes(this.prev_block_hash);
            }
            if (this.outcome_root.length > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(this.outcome_root.length);
              encoder.bytes(this.outcome_root);
            }
            if (this.prev_state_root.length > 0) {
              encoder.uint32(0x22);
              encoder.uint32(this.prev_state_root.length);
              encoder.bytes(this.prev_state_root);
            }
            if (this.encoded_merkle_root.length > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(this.encoded_merkle_root.length);
              encoder.bytes(this.encoded_merkle_root);
            }
            if (this.encoded_length != 0) {
              encoder.uint32(0x30);
              encoder.uint64(this.encoded_length);
            }
            if (this.height_created != 0) {
              encoder.uint32(0x38);
              encoder.uint64(this.height_created);
            }
            if (this.height_included != 0) {
              encoder.uint32(0x40);
              encoder.uint64(this.height_included);
            }
            if (this.shard_id != 0) {
              encoder.uint32(0x48);
              encoder.uint64(this.shard_id);
            }
            if (this.gas_used != 0) {
              encoder.uint32(0x50);
              encoder.uint64(this.gas_used);
            }
            if (this.gas_limit != 0) {
              encoder.uint32(0x58);
              encoder.uint64(this.gas_limit);
            }

            if (this.validator_reward != null) {
              const f = this.validator_reward as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x62);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.balance_burnt != null) {
              const f = this.balance_burnt as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x6a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.outgoing_receipts_root.length > 0) {
              encoder.uint32(0x72);
              encoder.uint32(this.outgoing_receipts_root.length);
              encoder.bytes(this.outgoing_receipts_root);
            }
            if (this.tx_root.length > 0) {
              encoder.uint32(0x7a);
              encoder.uint32(this.tx_root.length);
              encoder.bytes(this.tx_root);
            }

            for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
              const messageSize = this.validator_proposals[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x82);
                encoder.uint32(messageSize);
                this.validator_proposals[n].encodeU8Array(encoder);
              }
            }

            if (this.signature != null) {
              const f = this.signature as Signature;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x8a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode ChunkHeader
        } // ChunkHeader

        export class IndexerShard {
          public shard_id: u64;
          public chunk: IndexerChunk = new IndexerChunk();
          public receipt_execution_outcomes: Array<IndexerExecutionOutcomeWithReceipt> =
            new Array<IndexerExecutionOutcomeWithReceipt>();

          // Decodes IndexerShard from an ArrayBuffer
          static decode(buf: ArrayBuffer): IndexerShard {
            return IndexerShard.decodeDataView(new DataView(buf));
          }

          // Decodes IndexerShard from a DataView
          static decodeDataView(view: DataView): IndexerShard {
            const decoder = new __proto.Decoder(view);
            const obj = new IndexerShard();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.shard_id = decoder.uint64();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.chunk = IndexerChunk.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.receipt_execution_outcomes.push(
                    IndexerExecutionOutcomeWithReceipt.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode IndexerShard

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);

            if (this.chunk != null) {
              const f: IndexerChunk = this.chunk as IndexerChunk;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (
              let n: i32 = 0;
              n < this.receipt_execution_outcomes.length;
              n++
            ) {
              const messageSize = this.receipt_execution_outcomes[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes IndexerShard to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes IndexerShard to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.shard_id != 0) {
              encoder.uint32(0x8);
              encoder.uint64(this.shard_id);
            }

            if (this.chunk != null) {
              const f = this.chunk as IndexerChunk;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (
              let n: i32 = 0;
              n < this.receipt_execution_outcomes.length;
              n++
            ) {
              const messageSize = this.receipt_execution_outcomes[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                this.receipt_execution_outcomes[n].encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode IndexerShard
        } // IndexerShard

        export class IndexerExecutionOutcomeWithReceipt {
          public execution_outcome: ExecutionOutcomeWithId =
            new ExecutionOutcomeWithId();
          public receipt: Receipt = new Receipt();

          // Decodes IndexerExecutionOutcomeWithReceipt from an ArrayBuffer
          static decode(buf: ArrayBuffer): IndexerExecutionOutcomeWithReceipt {
            return IndexerExecutionOutcomeWithReceipt.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes IndexerExecutionOutcomeWithReceipt from a DataView
          static decodeDataView(
            view: DataView
          ): IndexerExecutionOutcomeWithReceipt {
            const decoder = new __proto.Decoder(view);
            const obj = new IndexerExecutionOutcomeWithReceipt();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.receipt = Receipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode IndexerExecutionOutcomeWithReceipt

          public size(): u32 {
            let size: u32 = 0;

            if (this.execution_outcome != null) {
              const f: ExecutionOutcomeWithId = this
                .execution_outcome as ExecutionOutcomeWithId;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.receipt != null) {
              const f: Receipt = this.receipt as Receipt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes IndexerExecutionOutcomeWithReceipt to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes IndexerExecutionOutcomeWithReceipt to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.execution_outcome != null) {
              const f = this.execution_outcome as ExecutionOutcomeWithId;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.receipt != null) {
              const f = this.receipt as Receipt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode IndexerExecutionOutcomeWithReceipt
        } // IndexerExecutionOutcomeWithReceipt

        export class IndexerChunk {
          public author: string = "";
          public header: ChunkHeader = new ChunkHeader();
          public transactions: Array<IndexerTransactionWithOutcome> =
            new Array<IndexerTransactionWithOutcome>();
          public receipts: Array<Receipt> = new Array<Receipt>();

          // Decodes IndexerChunk from an ArrayBuffer
          static decode(buf: ArrayBuffer): IndexerChunk {
            return IndexerChunk.decodeDataView(new DataView(buf));
          }

          // Decodes IndexerChunk from a DataView
          static decodeDataView(view: DataView): IndexerChunk {
            const decoder = new __proto.Decoder(view);
            const obj = new IndexerChunk();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.author = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.header = ChunkHeader.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.transactions.push(
                    IndexerTransactionWithOutcome.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.receipts.push(
                    Receipt.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode IndexerChunk

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.author.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.author.length) +
                  this.author.length
                : 0;

            if (this.header != null) {
              const f: ChunkHeader = this.header as ChunkHeader;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.transactions.length; n++) {
              const messageSize = this.transactions[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.receipts.length; n++) {
              const messageSize = this.receipts[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes IndexerChunk to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes IndexerChunk to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.author.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.author.length);
              encoder.string(this.author);
            }

            if (this.header != null) {
              const f = this.header as ChunkHeader;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.transactions.length; n++) {
              const messageSize = this.transactions[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                this.transactions[n].encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.receipts.length; n++) {
              const messageSize = this.receipts[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                this.receipts[n].encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode IndexerChunk
        } // IndexerChunk

        export class IndexerTransactionWithOutcome {
          public transaction: SignedTransaction = new SignedTransaction();
          public outcome: IndexerExecutionOutcomeWithOptionalReceipt =
            new IndexerExecutionOutcomeWithOptionalReceipt();

          // Decodes IndexerTransactionWithOutcome from an ArrayBuffer
          static decode(buf: ArrayBuffer): IndexerTransactionWithOutcome {
            return IndexerTransactionWithOutcome.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes IndexerTransactionWithOutcome from a DataView
          static decodeDataView(view: DataView): IndexerTransactionWithOutcome {
            const decoder = new __proto.Decoder(view);
            const obj = new IndexerTransactionWithOutcome();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.transaction = SignedTransaction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.outcome =
                    IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode IndexerTransactionWithOutcome

          public size(): u32 {
            let size: u32 = 0;

            if (this.transaction != null) {
              const f: SignedTransaction = this
                .transaction as SignedTransaction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.outcome != null) {
              const f: IndexerExecutionOutcomeWithOptionalReceipt = this
                .outcome as IndexerExecutionOutcomeWithOptionalReceipt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes IndexerTransactionWithOutcome to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes IndexerTransactionWithOutcome to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.transaction != null) {
              const f = this.transaction as SignedTransaction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.outcome != null) {
              const f = this
                .outcome as IndexerExecutionOutcomeWithOptionalReceipt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode IndexerTransactionWithOutcome
        } // IndexerTransactionWithOutcome

        export class SignedTransaction {
          public signer_id: string = "";
          public public_key: PublicKey = new PublicKey();
          public nonce: u64;
          public receiver_id: string = "";
          public actions: Array<Action> = new Array<Action>();
          public signature: Signature = new Signature();
          public hash: CryptoHash = new CryptoHash();

          // Decodes SignedTransaction from an ArrayBuffer
          static decode(buf: ArrayBuffer): SignedTransaction {
            return SignedTransaction.decodeDataView(new DataView(buf));
          }

          // Decodes SignedTransaction from a DataView
          static decodeDataView(view: DataView): SignedTransaction {
            const decoder = new __proto.Decoder(view);
            const obj = new SignedTransaction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.signer_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  obj.nonce = decoder.uint64();
                  break;
                }
                case 4: {
                  obj.receiver_id = decoder.string();
                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.actions.push(
                    Action.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.signature = Signature.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 7: {
                  const length = decoder.uint32();
                  obj.hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode SignedTransaction

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.signer_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.signer_id.length) +
                  this.signer_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);
            size +=
              this.receiver_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.receiver_id.length) +
                  this.receiver_id.length
                : 0;

            for (let n: i32 = 0; n < this.actions.length; n++) {
              const messageSize = this.actions[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.signature != null) {
              const f: Signature = this.signature as Signature;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.hash != null) {
              const f: CryptoHash = this.hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes SignedTransaction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes SignedTransaction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.signer_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.signer_id.length);
              encoder.string(this.signer_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.nonce != 0) {
              encoder.uint32(0x18);
              encoder.uint64(this.nonce);
            }
            if (this.receiver_id.length > 0) {
              encoder.uint32(0x22);
              encoder.uint32(this.receiver_id.length);
              encoder.string(this.receiver_id);
            }

            for (let n: i32 = 0; n < this.actions.length; n++) {
              const messageSize = this.actions[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                this.actions[n].encodeU8Array(encoder);
              }
            }

            if (this.signature != null) {
              const f = this.signature as Signature;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.hash != null) {
              const f = this.hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode SignedTransaction
        } // SignedTransaction

        export class IndexerExecutionOutcomeWithOptionalReceipt {
          public execution_outcome: ExecutionOutcomeWithId =
            new ExecutionOutcomeWithId();
          public receipt: Receipt = new Receipt();

          // Decodes IndexerExecutionOutcomeWithOptionalReceipt from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): IndexerExecutionOutcomeWithOptionalReceipt {
            return IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes IndexerExecutionOutcomeWithOptionalReceipt from a DataView
          static decodeDataView(
            view: DataView
          ): IndexerExecutionOutcomeWithOptionalReceipt {
            const decoder = new __proto.Decoder(view);
            const obj = new IndexerExecutionOutcomeWithOptionalReceipt();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.receipt = Receipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode IndexerExecutionOutcomeWithOptionalReceipt

          public size(): u32 {
            let size: u32 = 0;

            if (this.execution_outcome != null) {
              const f: ExecutionOutcomeWithId = this
                .execution_outcome as ExecutionOutcomeWithId;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.receipt != null) {
              const f: Receipt = this.receipt as Receipt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.execution_outcome != null) {
              const f = this.execution_outcome as ExecutionOutcomeWithId;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.receipt != null) {
              const f = this.receipt as Receipt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode IndexerExecutionOutcomeWithOptionalReceipt
        } // IndexerExecutionOutcomeWithOptionalReceipt

        export class Receipt {
          public predecessor_id: string = "";
          public receiver_id: string = "";
          public receipt_id: CryptoHash = new CryptoHash();
          public action: ReceiptAction | null;
          public data: ReceiptData | null;

          public __receipt: string = "";
          public __receipt_index: u8 = 0;

          static readonly RECEIPT_ACTION_INDEX: u8 = 10;
          static readonly RECEIPT_DATA_INDEX: u8 = 11;

          // Decodes Receipt from an ArrayBuffer
          static decode(buf: ArrayBuffer): Receipt {
            return Receipt.decodeDataView(new DataView(buf));
          }

          // Decodes Receipt from a DataView
          static decodeDataView(view: DataView): Receipt {
            const decoder = new __proto.Decoder(view);
            const obj = new Receipt();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.predecessor_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.receiver_id = decoder.string();
                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.receipt_id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 10: {
                  const length = decoder.uint32();
                  obj.action = ReceiptAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__receipt = "action";
                  obj.__receipt_index = 10;
                  break;
                }
                case 11: {
                  const length = decoder.uint32();
                  obj.data = ReceiptData.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__receipt = "data";
                  obj.__receipt_index = 11;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode Receipt

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.predecessor_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.predecessor_id.length) +
                  this.predecessor_id.length
                : 0;
            size +=
              this.receiver_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.receiver_id.length) +
                  this.receiver_id.length
                : 0;

            if (this.receipt_id != null) {
              const f: CryptoHash = this.receipt_id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.action != null) {
              const f: ReceiptAction = this.action as ReceiptAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.data != null) {
              const f: ReceiptData = this.data as ReceiptData;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes Receipt to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes Receipt to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.predecessor_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.predecessor_id.length);
              encoder.string(this.predecessor_id);
            }
            if (this.receiver_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.receiver_id.length);
              encoder.string(this.receiver_id);
            }

            if (this.receipt_id != null) {
              const f = this.receipt_id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.action != null) {
              const f = this.action as ReceiptAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x52);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.data != null) {
              const f = this.data as ReceiptData;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x5a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode Receipt
        } // Receipt

        export class ReceiptData {
          public data_id: CryptoHash = new CryptoHash();
          public data: Array<u8> = new Array<u8>();

          // Decodes ReceiptData from an ArrayBuffer
          static decode(buf: ArrayBuffer): ReceiptData {
            return ReceiptData.decodeDataView(new DataView(buf));
          }

          // Decodes ReceiptData from a DataView
          static decodeDataView(view: DataView): ReceiptData {
            const decoder = new __proto.Decoder(view);
            const obj = new ReceiptData();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.data_id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  obj.data = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ReceiptData

          public size(): u32 {
            let size: u32 = 0;

            if (this.data_id != null) {
              const f: CryptoHash = this.data_id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.data.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.data.length) +
                  this.data.length
                : 0;

            return size;
          }

          // Encodes ReceiptData to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ReceiptData to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.data_id != null) {
              const f = this.data_id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.data.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.data.length);
              encoder.bytes(this.data);
            }

            return buf;
          } // encode ReceiptData
        } // ReceiptData

        export class ReceiptAction {
          public signer_id: string = "";
          public signer_public_key: PublicKey = new PublicKey();
          public gas_price: BigInt = new BigInt();
          public output_data_receivers: Array<DataReceiver> =
            new Array<DataReceiver>();
          public input_data_ids: Array<CryptoHash> = new Array<CryptoHash>();
          public actions: Array<Action> = new Array<Action>();

          // Decodes ReceiptAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): ReceiptAction {
            return ReceiptAction.decodeDataView(new DataView(buf));
          }

          // Decodes ReceiptAction from a DataView
          static decodeDataView(view: DataView): ReceiptAction {
            const decoder = new __proto.Decoder(view);
            const obj = new ReceiptAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.signer_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.signer_public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.gas_price = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.output_data_receivers.push(
                    DataReceiver.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.input_data_ids.push(
                    CryptoHash.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.actions.push(
                    Action.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ReceiptAction

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.signer_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.signer_id.length) +
                  this.signer_id.length
                : 0;

            if (this.signer_public_key != null) {
              const f: PublicKey = this.signer_public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.gas_price != null) {
              const f: BigInt = this.gas_price as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
              const messageSize = this.output_data_receivers[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
              const messageSize = this.input_data_ids[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            for (let n: i32 = 0; n < this.actions.length; n++) {
              const messageSize = this.actions[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes ReceiptAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ReceiptAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.signer_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.signer_id.length);
              encoder.string(this.signer_id);
            }

            if (this.signer_public_key != null) {
              const f = this.signer_public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.gas_price != null) {
              const f = this.gas_price as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
              const messageSize = this.output_data_receivers[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                this.output_data_receivers[n].encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
              const messageSize = this.input_data_ids[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                this.input_data_ids[n].encodeU8Array(encoder);
              }
            }

            for (let n: i32 = 0; n < this.actions.length; n++) {
              const messageSize = this.actions[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                this.actions[n].encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode ReceiptAction
        } // ReceiptAction

        export class DataReceiver {
          public data_id: CryptoHash = new CryptoHash();
          public receiver_id: string = "";

          // Decodes DataReceiver from an ArrayBuffer
          static decode(buf: ArrayBuffer): DataReceiver {
            return DataReceiver.decodeDataView(new DataView(buf));
          }

          // Decodes DataReceiver from a DataView
          static decodeDataView(view: DataView): DataReceiver {
            const decoder = new __proto.Decoder(view);
            const obj = new DataReceiver();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.data_id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  obj.receiver_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DataReceiver

          public size(): u32 {
            let size: u32 = 0;

            if (this.data_id != null) {
              const f: CryptoHash = this.data_id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.receiver_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.receiver_id.length) +
                  this.receiver_id.length
                : 0;

            return size;
          }

          // Encodes DataReceiver to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DataReceiver to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.data_id != null) {
              const f = this.data_id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.receiver_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.receiver_id.length);
              encoder.string(this.receiver_id);
            }

            return buf;
          } // encode DataReceiver
        } // DataReceiver

        export class ExecutionOutcomeWithId {
          public proof: MerklePath = new MerklePath();
          public block_hash: CryptoHash = new CryptoHash();
          public id: CryptoHash = new CryptoHash();
          public outcome: ExecutionOutcome = new ExecutionOutcome();

          // Decodes ExecutionOutcomeWithId from an ArrayBuffer
          static decode(buf: ArrayBuffer): ExecutionOutcomeWithId {
            return ExecutionOutcomeWithId.decodeDataView(new DataView(buf));
          }

          // Decodes ExecutionOutcomeWithId from a DataView
          static decodeDataView(view: DataView): ExecutionOutcomeWithId {
            const decoder = new __proto.Decoder(view);
            const obj = new ExecutionOutcomeWithId();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.proof = MerklePath.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.block_hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.outcome = ExecutionOutcome.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ExecutionOutcomeWithId

          public size(): u32 {
            let size: u32 = 0;

            if (this.proof != null) {
              const f: MerklePath = this.proof as MerklePath;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.block_hash != null) {
              const f: CryptoHash = this.block_hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.id != null) {
              const f: CryptoHash = this.id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.outcome != null) {
              const f: ExecutionOutcome = this.outcome as ExecutionOutcome;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes ExecutionOutcomeWithId to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ExecutionOutcomeWithId to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.proof != null) {
              const f = this.proof as MerklePath;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.block_hash != null) {
              const f = this.block_hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.id != null) {
              const f = this.id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.outcome != null) {
              const f = this.outcome as ExecutionOutcome;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode ExecutionOutcomeWithId
        } // ExecutionOutcomeWithId

        export class ExecutionOutcome {
          public logs: Array<string> = new Array<string>();
          public receipt_ids: Array<CryptoHash> = new Array<CryptoHash>();
          public gas_burnt: u64;
          public tokens_burnt: BigInt = new BigInt();
          public executor_id: string = "";
          public unknown: UnknownExecutionStatus | null;
          public failure: FailureExecutionStatus | null;
          public success_value: SuccessValueExecutionStatus | null;
          public success_receipt_id: SuccessReceiptIdExecutionStatus | null;
          public metadata: u32;

          public __status: string = "";
          public __status_index: u8 = 0;

          static readonly STATUS_UNKNOWN_INDEX: u8 = 20;
          static readonly STATUS_FAILURE_INDEX: u8 = 21;
          static readonly STATUS_SUCCESS_VALUE_INDEX: u8 = 22;
          static readonly STATUS_SUCCESS_RECEIPT_ID_INDEX: u8 = 23;

          // Decodes ExecutionOutcome from an ArrayBuffer
          static decode(buf: ArrayBuffer): ExecutionOutcome {
            return ExecutionOutcome.decodeDataView(new DataView(buf));
          }

          // Decodes ExecutionOutcome from a DataView
          static decodeDataView(view: DataView): ExecutionOutcome {
            const decoder = new __proto.Decoder(view);
            const obj = new ExecutionOutcome();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.logs.push(decoder.string());
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.receipt_ids.push(
                    CryptoHash.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  obj.gas_burnt = decoder.uint64();
                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.tokens_burnt = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 5: {
                  obj.executor_id = decoder.string();
                  break;
                }
                case 20: {
                  const length = decoder.uint32();
                  obj.unknown = UnknownExecutionStatus.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__status = "unknown";
                  obj.__status_index = 20;
                  break;
                }
                case 21: {
                  const length = decoder.uint32();
                  obj.failure = FailureExecutionStatus.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__status = "failure";
                  obj.__status_index = 21;
                  break;
                }
                case 22: {
                  const length = decoder.uint32();
                  obj.success_value =
                    SuccessValueExecutionStatus.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__status = "success_value";
                  obj.__status_index = 22;
                  break;
                }
                case 23: {
                  const length = decoder.uint32();
                  obj.success_receipt_id =
                    SuccessReceiptIdExecutionStatus.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__status = "success_receipt_id";
                  obj.__status_index = 23;
                  break;
                }
                case 6: {
                  obj.metadata = decoder.uint32();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ExecutionOutcome

          public size(): u32 {
            let size: u32 = 0;

            size += __size_string_repeated(this.logs);

            for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
              const messageSize = this.receipt_ids[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.gas_burnt == 0
                ? 0
                : 1 + __proto.Sizer.uint64(this.gas_burnt);

            if (this.tokens_burnt != null) {
              const f: BigInt = this.tokens_burnt as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.executor_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.executor_id.length) +
                  this.executor_id.length
                : 0;

            if (this.unknown != null) {
              const f: UnknownExecutionStatus = this
                .unknown as UnknownExecutionStatus;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.failure != null) {
              const f: FailureExecutionStatus = this
                .failure as FailureExecutionStatus;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.success_value != null) {
              const f: SuccessValueExecutionStatus = this
                .success_value as SuccessValueExecutionStatus;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.success_receipt_id != null) {
              const f: SuccessReceiptIdExecutionStatus = this
                .success_receipt_id as SuccessReceiptIdExecutionStatus;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.metadata == 0 ? 0 : 1 + __proto.Sizer.uint32(this.metadata);

            return size;
          }

          // Encodes ExecutionOutcome to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ExecutionOutcome to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.logs.length > 0) {
              for (let n: i32 = 0; n < this.logs.length; n++) {
                encoder.uint32(0xa);
                encoder.uint32(this.logs[n].length);
                encoder.string(this.logs[n]);
              }
            }

            for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
              const messageSize = this.receipt_ids[n].size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                this.receipt_ids[n].encodeU8Array(encoder);
              }
            }

            if (this.gas_burnt != 0) {
              encoder.uint32(0x18);
              encoder.uint64(this.gas_burnt);
            }

            if (this.tokens_burnt != null) {
              const f = this.tokens_burnt as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.executor_id.length > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(this.executor_id.length);
              encoder.string(this.executor_id);
            }

            if (this.unknown != null) {
              const f = this.unknown as UnknownExecutionStatus;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.failure != null) {
              const f = this.failure as FailureExecutionStatus;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xaa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.success_value != null) {
              const f = this.success_value as SuccessValueExecutionStatus;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xb2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.success_receipt_id != null) {
              const f = this
                .success_receipt_id as SuccessReceiptIdExecutionStatus;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xba);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.metadata != 0) {
              encoder.uint32(0x30);
              encoder.uint32(this.metadata);
            }

            return buf;
          } // encode ExecutionOutcome
        } // ExecutionOutcome

        export class SuccessValueExecutionStatus {
          public value: Array<u8> = new Array<u8>();

          // Decodes SuccessValueExecutionStatus from an ArrayBuffer
          static decode(buf: ArrayBuffer): SuccessValueExecutionStatus {
            return SuccessValueExecutionStatus.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes SuccessValueExecutionStatus from a DataView
          static decodeDataView(view: DataView): SuccessValueExecutionStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new SuccessValueExecutionStatus();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.value = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode SuccessValueExecutionStatus

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.value.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.value.length) +
                  this.value.length
                : 0;

            return size;
          }

          // Encodes SuccessValueExecutionStatus to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes SuccessValueExecutionStatus to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.value.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.value.length);
              encoder.bytes(this.value);
            }

            return buf;
          } // encode SuccessValueExecutionStatus
        } // SuccessValueExecutionStatus

        export class SuccessReceiptIdExecutionStatus {
          public id: CryptoHash = new CryptoHash();

          // Decodes SuccessReceiptIdExecutionStatus from an ArrayBuffer
          static decode(buf: ArrayBuffer): SuccessReceiptIdExecutionStatus {
            return SuccessReceiptIdExecutionStatus.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes SuccessReceiptIdExecutionStatus from a DataView
          static decodeDataView(
            view: DataView
          ): SuccessReceiptIdExecutionStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new SuccessReceiptIdExecutionStatus();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.id = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode SuccessReceiptIdExecutionStatus

          public size(): u32 {
            let size: u32 = 0;

            if (this.id != null) {
              const f: CryptoHash = this.id as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes SuccessReceiptIdExecutionStatus to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes SuccessReceiptIdExecutionStatus to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.id != null) {
              const f = this.id as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode SuccessReceiptIdExecutionStatus
        } // SuccessReceiptIdExecutionStatus

        export class UnknownExecutionStatus {
          // Decodes UnknownExecutionStatus from an ArrayBuffer
          static decode(buf: ArrayBuffer): UnknownExecutionStatus {
            return UnknownExecutionStatus.decodeDataView(new DataView(buf));
          }

          // Decodes UnknownExecutionStatus from a DataView
          static decodeDataView(view: DataView): UnknownExecutionStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new UnknownExecutionStatus();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode UnknownExecutionStatus

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes UnknownExecutionStatus to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes UnknownExecutionStatus to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode UnknownExecutionStatus
        } // UnknownExecutionStatus

        export class FailureExecutionStatus {
          public action_error: ActionError | null;
          public invalid_tx_error: u32;

          public __failure: string = "";
          public __failure_index: u8 = 0;

          static readonly FAILURE_ACTION_ERROR_INDEX: u8 = 1;
          static readonly FAILURE_INVALID_TX_ERROR_INDEX: u8 = 2;

          // Decodes FailureExecutionStatus from an ArrayBuffer
          static decode(buf: ArrayBuffer): FailureExecutionStatus {
            return FailureExecutionStatus.decodeDataView(new DataView(buf));
          }

          // Decodes FailureExecutionStatus from a DataView
          static decodeDataView(view: DataView): FailureExecutionStatus {
            const decoder = new __proto.Decoder(view);
            const obj = new FailureExecutionStatus();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.action_error = ActionError.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__failure = "action_error";
                  obj.__failure_index = 1;
                  break;
                }
                case 2: {
                  obj.invalid_tx_error = decoder.uint32();
                  obj.__failure = "invalid_tx_error";
                  obj.__failure_index = 2;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode FailureExecutionStatus

          public size(): u32 {
            let size: u32 = 0;

            if (this.action_error != null) {
              const f: ActionError = this.action_error as ActionError;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.invalid_tx_error == 0
                ? 0
                : 1 + __proto.Sizer.uint32(this.invalid_tx_error);

            return size;
          }

          // Encodes FailureExecutionStatus to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes FailureExecutionStatus to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.action_error != null) {
              const f = this.action_error as ActionError;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.invalid_tx_error != 0) {
              encoder.uint32(0x10);
              encoder.uint32(this.invalid_tx_error);
            }

            return buf;
          } // encode FailureExecutionStatus
        } // FailureExecutionStatus

        export class ActionError {
          public index: u64;
          public account_already_exist: AccountAlreadyExistsErrorKind | null;
          public account_does_not_exist: AccountDoesNotExistErrorKind | null;
          public create_account_only_by_registrar: CreateAccountOnlyByRegistrarErrorKind | null;
          public create_account_not_allowed: CreateAccountNotAllowedErrorKind | null;
          public actor_no_permission: ActorNoPermissionErrorKind | null;
          public delete_key_does_not_exist: DeleteKeyDoesNotExistErrorKind | null;
          public add_key_already_exists: AddKeyAlreadyExistsErrorKind | null;
          public delete_account_staking: DeleteAccountStakingErrorKind | null;
          public lack_balance_for_state: LackBalanceForStateErrorKind | null;
          public tries_to_unstake: TriesToUnstakeErrorKind | null;
          public tries_to_stake: TriesToStakeErrorKind | null;
          public insufficient_stake: InsufficientStakeErrorKind | null;
          public function_call: FunctionCallErrorKind | null;
          public new_receipt_validation: NewReceiptValidationErrorKind | null;
          public only_implicit_account_creation_allowed: OnlyImplicitAccountCreationAllowedErrorKind | null;
          public delete_account_with_large_state: DeleteAccountWithLargeStateErrorKind | null;

          public __kind: string = "";
          public __kind_index: u8 = 0;

          static readonly KIND_ACCOUNT_ALREADY_EXIST_INDEX: u8 = 21;
          static readonly KIND_ACCOUNT_DOES_NOT_EXIST_INDEX: u8 = 22;
          static readonly KIND_CREATE_ACCOUNT_ONLY_BY_REGISTRAR_INDEX: u8 = 23;
          static readonly KIND_CREATE_ACCOUNT_NOT_ALLOWED_INDEX: u8 = 24;
          static readonly KIND_ACTOR_NO_PERMISSION_INDEX: u8 = 25;
          static readonly KIND_DELETE_KEY_DOES_NOT_EXIST_INDEX: u8 = 26;
          static readonly KIND_ADD_KEY_ALREADY_EXISTS_INDEX: u8 = 27;
          static readonly KIND_DELETE_ACCOUNT_STAKING_INDEX: u8 = 28;
          static readonly KIND_LACK_BALANCE_FOR_STATE_INDEX: u8 = 29;
          static readonly KIND_TRIES_TO_UNSTAKE_INDEX: u8 = 30;
          static readonly KIND_TRIES_TO_STAKE_INDEX: u8 = 31;
          static readonly KIND_INSUFFICIENT_STAKE_INDEX: u8 = 32;
          static readonly KIND_FUNCTION_CALL_INDEX: u8 = 33;
          static readonly KIND_NEW_RECEIPT_VALIDATION_INDEX: u8 = 34;
          static readonly KIND_ONLY_IMPLICIT_ACCOUNT_CREATION_ALLOWED_INDEX: u8 = 35;
          static readonly KIND_DELETE_ACCOUNT_WITH_LARGE_STATE_INDEX: u8 = 36;

          // Decodes ActionError from an ArrayBuffer
          static decode(buf: ArrayBuffer): ActionError {
            return ActionError.decodeDataView(new DataView(buf));
          }

          // Decodes ActionError from a DataView
          static decodeDataView(view: DataView): ActionError {
            const decoder = new __proto.Decoder(view);
            const obj = new ActionError();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.index = decoder.uint64();
                  break;
                }
                case 21: {
                  const length = decoder.uint32();
                  obj.account_already_exist =
                    AccountAlreadyExistsErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "account_already_exist";
                  obj.__kind_index = 21;
                  break;
                }
                case 22: {
                  const length = decoder.uint32();
                  obj.account_does_not_exist =
                    AccountDoesNotExistErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "account_does_not_exist";
                  obj.__kind_index = 22;
                  break;
                }
                case 23: {
                  const length = decoder.uint32();
                  obj.create_account_only_by_registrar =
                    CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "create_account_only_by_registrar";
                  obj.__kind_index = 23;
                  break;
                }
                case 24: {
                  const length = decoder.uint32();
                  obj.create_account_not_allowed =
                    CreateAccountNotAllowedErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "create_account_not_allowed";
                  obj.__kind_index = 24;
                  break;
                }
                case 25: {
                  const length = decoder.uint32();
                  obj.actor_no_permission =
                    ActorNoPermissionErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "actor_no_permission";
                  obj.__kind_index = 25;
                  break;
                }
                case 26: {
                  const length = decoder.uint32();
                  obj.delete_key_does_not_exist =
                    DeleteKeyDoesNotExistErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "delete_key_does_not_exist";
                  obj.__kind_index = 26;
                  break;
                }
                case 27: {
                  const length = decoder.uint32();
                  obj.add_key_already_exists =
                    AddKeyAlreadyExistsErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "add_key_already_exists";
                  obj.__kind_index = 27;
                  break;
                }
                case 28: {
                  const length = decoder.uint32();
                  obj.delete_account_staking =
                    DeleteAccountStakingErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "delete_account_staking";
                  obj.__kind_index = 28;
                  break;
                }
                case 29: {
                  const length = decoder.uint32();
                  obj.lack_balance_for_state =
                    LackBalanceForStateErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "lack_balance_for_state";
                  obj.__kind_index = 29;
                  break;
                }
                case 30: {
                  const length = decoder.uint32();
                  obj.tries_to_unstake = TriesToUnstakeErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__kind = "tries_to_unstake";
                  obj.__kind_index = 30;
                  break;
                }
                case 31: {
                  const length = decoder.uint32();
                  obj.tries_to_stake = TriesToStakeErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__kind = "tries_to_stake";
                  obj.__kind_index = 31;
                  break;
                }
                case 32: {
                  const length = decoder.uint32();
                  obj.insufficient_stake =
                    InsufficientStakeErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "insufficient_stake";
                  obj.__kind_index = 32;
                  break;
                }
                case 33: {
                  const length = decoder.uint32();
                  obj.function_call = FunctionCallErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__kind = "function_call";
                  obj.__kind_index = 33;
                  break;
                }
                case 34: {
                  const length = decoder.uint32();
                  obj.new_receipt_validation =
                    NewReceiptValidationErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "new_receipt_validation";
                  obj.__kind_index = 34;
                  break;
                }
                case 35: {
                  const length = decoder.uint32();
                  obj.only_implicit_account_creation_allowed =
                    OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "only_implicit_account_creation_allowed";
                  obj.__kind_index = 35;
                  break;
                }
                case 36: {
                  const length = decoder.uint32();
                  obj.delete_account_with_large_state =
                    DeleteAccountWithLargeStateErrorKind.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    );
                  decoder.skip(length);

                  obj.__kind = "delete_account_with_large_state";
                  obj.__kind_index = 36;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ActionError

          public size(): u32 {
            let size: u32 = 0;

            size += this.index == 0 ? 0 : 1 + __proto.Sizer.uint64(this.index);

            if (this.account_already_exist != null) {
              const f: AccountAlreadyExistsErrorKind = this
                .account_already_exist as AccountAlreadyExistsErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.account_does_not_exist != null) {
              const f: AccountDoesNotExistErrorKind = this
                .account_does_not_exist as AccountDoesNotExistErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.create_account_only_by_registrar != null) {
              const f: CreateAccountOnlyByRegistrarErrorKind = this
                .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.create_account_not_allowed != null) {
              const f: CreateAccountNotAllowedErrorKind = this
                .create_account_not_allowed as CreateAccountNotAllowedErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.actor_no_permission != null) {
              const f: ActorNoPermissionErrorKind = this
                .actor_no_permission as ActorNoPermissionErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.delete_key_does_not_exist != null) {
              const f: DeleteKeyDoesNotExistErrorKind = this
                .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.add_key_already_exists != null) {
              const f: AddKeyAlreadyExistsErrorKind = this
                .add_key_already_exists as AddKeyAlreadyExistsErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.delete_account_staking != null) {
              const f: DeleteAccountStakingErrorKind = this
                .delete_account_staking as DeleteAccountStakingErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.lack_balance_for_state != null) {
              const f: LackBalanceForStateErrorKind = this
                .lack_balance_for_state as LackBalanceForStateErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.tries_to_unstake != null) {
              const f: TriesToUnstakeErrorKind = this
                .tries_to_unstake as TriesToUnstakeErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.tries_to_stake != null) {
              const f: TriesToStakeErrorKind = this
                .tries_to_stake as TriesToStakeErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.insufficient_stake != null) {
              const f: InsufficientStakeErrorKind = this
                .insufficient_stake as InsufficientStakeErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.function_call != null) {
              const f: FunctionCallErrorKind = this
                .function_call as FunctionCallErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.new_receipt_validation != null) {
              const f: NewReceiptValidationErrorKind = this
                .new_receipt_validation as NewReceiptValidationErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.only_implicit_account_creation_allowed != null) {
              const f: OnlyImplicitAccountCreationAllowedErrorKind = this
                .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.delete_account_with_large_state != null) {
              const f: DeleteAccountWithLargeStateErrorKind = this
                .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes ActionError to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ActionError to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.index != 0) {
              encoder.uint32(0x8);
              encoder.uint64(this.index);
            }

            if (this.account_already_exist != null) {
              const f = this
                .account_already_exist as AccountAlreadyExistsErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xaa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.account_does_not_exist != null) {
              const f = this
                .account_does_not_exist as AccountDoesNotExistErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xb2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.create_account_only_by_registrar != null) {
              const f = this
                .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xba);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.create_account_not_allowed != null) {
              const f = this
                .create_account_not_allowed as CreateAccountNotAllowedErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xc2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.actor_no_permission != null) {
              const f = this.actor_no_permission as ActorNoPermissionErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xca);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.delete_key_does_not_exist != null) {
              const f = this
                .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xd2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.add_key_already_exists != null) {
              const f = this
                .add_key_already_exists as AddKeyAlreadyExistsErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xda);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.delete_account_staking != null) {
              const f = this
                .delete_account_staking as DeleteAccountStakingErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xe2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.lack_balance_for_state != null) {
              const f = this
                .lack_balance_for_state as LackBalanceForStateErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xea);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.tries_to_unstake != null) {
              const f = this.tries_to_unstake as TriesToUnstakeErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xf2);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.tries_to_stake != null) {
              const f = this.tries_to_stake as TriesToStakeErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xfa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.insufficient_stake != null) {
              const f = this.insufficient_stake as InsufficientStakeErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x102);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.function_call != null) {
              const f = this.function_call as FunctionCallErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x10a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.new_receipt_validation != null) {
              const f = this
                .new_receipt_validation as NewReceiptValidationErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x112);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.only_implicit_account_creation_allowed != null) {
              const f = this
                .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x11a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.delete_account_with_large_state != null) {
              const f = this
                .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x122);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode ActionError
        } // ActionError

        export class AccountAlreadyExistsErrorKind {
          public account_id: string = "";

          // Decodes AccountAlreadyExistsErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): AccountAlreadyExistsErrorKind {
            return AccountAlreadyExistsErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes AccountAlreadyExistsErrorKind from a DataView
          static decodeDataView(view: DataView): AccountAlreadyExistsErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new AccountAlreadyExistsErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AccountAlreadyExistsErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes AccountAlreadyExistsErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AccountAlreadyExistsErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode AccountAlreadyExistsErrorKind
        } // AccountAlreadyExistsErrorKind

        export class AccountDoesNotExistErrorKind {
          public account_id: string = "";

          // Decodes AccountDoesNotExistErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): AccountDoesNotExistErrorKind {
            return AccountDoesNotExistErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes AccountDoesNotExistErrorKind from a DataView
          static decodeDataView(view: DataView): AccountDoesNotExistErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new AccountDoesNotExistErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AccountDoesNotExistErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes AccountDoesNotExistErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AccountDoesNotExistErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode AccountDoesNotExistErrorKind
        } // AccountDoesNotExistErrorKind

        // / A top-level account ID can only be created by registrar.
        export class CreateAccountOnlyByRegistrarErrorKind {
          public account_id: string = "";
          public registrar_account_id: string = "";
          public predecessor_id: string = "";

          // Decodes CreateAccountOnlyByRegistrarErrorKind from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): CreateAccountOnlyByRegistrarErrorKind {
            return CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes CreateAccountOnlyByRegistrarErrorKind from a DataView
          static decodeDataView(
            view: DataView
          ): CreateAccountOnlyByRegistrarErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new CreateAccountOnlyByRegistrarErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.registrar_account_id = decoder.string();
                  break;
                }
                case 3: {
                  obj.predecessor_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode CreateAccountOnlyByRegistrarErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.registrar_account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.registrar_account_id.length) +
                  this.registrar_account_id.length
                : 0;
            size +=
              this.predecessor_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.predecessor_id.length) +
                  this.predecessor_id.length
                : 0;

            return size;
          }

          // Encodes CreateAccountOnlyByRegistrarErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes CreateAccountOnlyByRegistrarErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.registrar_account_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.registrar_account_id.length);
              encoder.string(this.registrar_account_id);
            }
            if (this.predecessor_id.length > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(this.predecessor_id.length);
              encoder.string(this.predecessor_id);
            }

            return buf;
          } // encode CreateAccountOnlyByRegistrarErrorKind
        } // CreateAccountOnlyByRegistrarErrorKind

        export class CreateAccountNotAllowedErrorKind {
          public account_id: string = "";
          public predecessor_id: string = "";

          // Decodes CreateAccountNotAllowedErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): CreateAccountNotAllowedErrorKind {
            return CreateAccountNotAllowedErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes CreateAccountNotAllowedErrorKind from a DataView
          static decodeDataView(
            view: DataView
          ): CreateAccountNotAllowedErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new CreateAccountNotAllowedErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.predecessor_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode CreateAccountNotAllowedErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.predecessor_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.predecessor_id.length) +
                  this.predecessor_id.length
                : 0;

            return size;
          }

          // Encodes CreateAccountNotAllowedErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes CreateAccountNotAllowedErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.predecessor_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.predecessor_id.length);
              encoder.string(this.predecessor_id);
            }

            return buf;
          } // encode CreateAccountNotAllowedErrorKind
        } // CreateAccountNotAllowedErrorKind

        export class ActorNoPermissionErrorKind {
          public account_id: string = "";
          public actor_id: string = "";

          // Decodes ActorNoPermissionErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): ActorNoPermissionErrorKind {
            return ActorNoPermissionErrorKind.decodeDataView(new DataView(buf));
          }

          // Decodes ActorNoPermissionErrorKind from a DataView
          static decodeDataView(view: DataView): ActorNoPermissionErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new ActorNoPermissionErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  obj.actor_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode ActorNoPermissionErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;
            size +=
              this.actor_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.actor_id.length) +
                  this.actor_id.length
                : 0;

            return size;
          }

          // Encodes ActorNoPermissionErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes ActorNoPermissionErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }
            if (this.actor_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.actor_id.length);
              encoder.string(this.actor_id);
            }

            return buf;
          } // encode ActorNoPermissionErrorKind
        } // ActorNoPermissionErrorKind

        export class DeleteKeyDoesNotExistErrorKind {
          public account_id: string = "";
          public public_key: PublicKey = new PublicKey();

          // Decodes DeleteKeyDoesNotExistErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): DeleteKeyDoesNotExistErrorKind {
            return DeleteKeyDoesNotExistErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes DeleteKeyDoesNotExistErrorKind from a DataView
          static decodeDataView(
            view: DataView
          ): DeleteKeyDoesNotExistErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteKeyDoesNotExistErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeleteKeyDoesNotExistErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes DeleteKeyDoesNotExistErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeleteKeyDoesNotExistErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode DeleteKeyDoesNotExistErrorKind
        } // DeleteKeyDoesNotExistErrorKind

        export class AddKeyAlreadyExistsErrorKind {
          public account_id: string = "";
          public public_key: PublicKey = new PublicKey();

          // Decodes AddKeyAlreadyExistsErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): AddKeyAlreadyExistsErrorKind {
            return AddKeyAlreadyExistsErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes AddKeyAlreadyExistsErrorKind from a DataView
          static decodeDataView(view: DataView): AddKeyAlreadyExistsErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new AddKeyAlreadyExistsErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AddKeyAlreadyExistsErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes AddKeyAlreadyExistsErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AddKeyAlreadyExistsErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode AddKeyAlreadyExistsErrorKind
        } // AddKeyAlreadyExistsErrorKind

        export class DeleteAccountStakingErrorKind {
          public account_id: string = "";

          // Decodes DeleteAccountStakingErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): DeleteAccountStakingErrorKind {
            return DeleteAccountStakingErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes DeleteAccountStakingErrorKind from a DataView
          static decodeDataView(view: DataView): DeleteAccountStakingErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteAccountStakingErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeleteAccountStakingErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes DeleteAccountStakingErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeleteAccountStakingErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode DeleteAccountStakingErrorKind
        } // DeleteAccountStakingErrorKind

        export class LackBalanceForStateErrorKind {
          public account_id: string = "";
          public balance: BigInt = new BigInt();

          // Decodes LackBalanceForStateErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): LackBalanceForStateErrorKind {
            return LackBalanceForStateErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes LackBalanceForStateErrorKind from a DataView
          static decodeDataView(view: DataView): LackBalanceForStateErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new LackBalanceForStateErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.balance = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode LackBalanceForStateErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.balance != null) {
              const f: BigInt = this.balance as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes LackBalanceForStateErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes LackBalanceForStateErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.balance != null) {
              const f = this.balance as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode LackBalanceForStateErrorKind
        } // LackBalanceForStateErrorKind

        export class TriesToUnstakeErrorKind {
          public account_id: string = "";

          // Decodes TriesToUnstakeErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): TriesToUnstakeErrorKind {
            return TriesToUnstakeErrorKind.decodeDataView(new DataView(buf));
          }

          // Decodes TriesToUnstakeErrorKind from a DataView
          static decodeDataView(view: DataView): TriesToUnstakeErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new TriesToUnstakeErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode TriesToUnstakeErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes TriesToUnstakeErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes TriesToUnstakeErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode TriesToUnstakeErrorKind
        } // TriesToUnstakeErrorKind

        export class TriesToStakeErrorKind {
          public account_id: string = "";
          public stake: BigInt = new BigInt();
          public locked: BigInt = new BigInt();
          public balance: BigInt = new BigInt();

          // Decodes TriesToStakeErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): TriesToStakeErrorKind {
            return TriesToStakeErrorKind.decodeDataView(new DataView(buf));
          }

          // Decodes TriesToStakeErrorKind from a DataView
          static decodeDataView(view: DataView): TriesToStakeErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new TriesToStakeErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.stake = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.locked = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.balance = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode TriesToStakeErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.stake != null) {
              const f: BigInt = this.stake as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.locked != null) {
              const f: BigInt = this.locked as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.balance != null) {
              const f: BigInt = this.balance as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes TriesToStakeErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes TriesToStakeErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.stake != null) {
              const f = this.stake as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.locked != null) {
              const f = this.locked as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.balance != null) {
              const f = this.balance as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode TriesToStakeErrorKind
        } // TriesToStakeErrorKind

        export class InsufficientStakeErrorKind {
          public account_id: string = "";
          public stake: BigInt = new BigInt();
          public minimum_stake: BigInt = new BigInt();

          // Decodes InsufficientStakeErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): InsufficientStakeErrorKind {
            return InsufficientStakeErrorKind.decodeDataView(new DataView(buf));
          }

          // Decodes InsufficientStakeErrorKind from a DataView
          static decodeDataView(view: DataView): InsufficientStakeErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new InsufficientStakeErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.stake = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.minimum_stake = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode InsufficientStakeErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            if (this.stake != null) {
              const f: BigInt = this.stake as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.minimum_stake != null) {
              const f: BigInt = this.minimum_stake as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes InsufficientStakeErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes InsufficientStakeErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            if (this.stake != null) {
              const f = this.stake as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.minimum_stake != null) {
              const f = this.minimum_stake as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode InsufficientStakeErrorKind
        } // InsufficientStakeErrorKind

        export class FunctionCallErrorKind {
          public error: u32;

          // Decodes FunctionCallErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): FunctionCallErrorKind {
            return FunctionCallErrorKind.decodeDataView(new DataView(buf));
          }

          // Decodes FunctionCallErrorKind from a DataView
          static decodeDataView(view: DataView): FunctionCallErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new FunctionCallErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.error = decoder.uint32();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode FunctionCallErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

            return size;
          }

          // Encodes FunctionCallErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes FunctionCallErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.error != 0) {
              encoder.uint32(0x8);
              encoder.uint32(this.error);
            }

            return buf;
          } // encode FunctionCallErrorKind
        } // FunctionCallErrorKind

        export class NewReceiptValidationErrorKind {
          public error: u32;

          // Decodes NewReceiptValidationErrorKind from an ArrayBuffer
          static decode(buf: ArrayBuffer): NewReceiptValidationErrorKind {
            return NewReceiptValidationErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes NewReceiptValidationErrorKind from a DataView
          static decodeDataView(view: DataView): NewReceiptValidationErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new NewReceiptValidationErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.error = decoder.uint32();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode NewReceiptValidationErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

            return size;
          }

          // Encodes NewReceiptValidationErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes NewReceiptValidationErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.error != 0) {
              encoder.uint32(0x8);
              encoder.uint32(this.error);
            }

            return buf;
          } // encode NewReceiptValidationErrorKind
        } // NewReceiptValidationErrorKind

        export class OnlyImplicitAccountCreationAllowedErrorKind {
          public account_id: string = "";

          // Decodes OnlyImplicitAccountCreationAllowedErrorKind from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): OnlyImplicitAccountCreationAllowedErrorKind {
            return OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes OnlyImplicitAccountCreationAllowedErrorKind from a DataView
          static decodeDataView(
            view: DataView
          ): OnlyImplicitAccountCreationAllowedErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new OnlyImplicitAccountCreationAllowedErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode OnlyImplicitAccountCreationAllowedErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode OnlyImplicitAccountCreationAllowedErrorKind
        } // OnlyImplicitAccountCreationAllowedErrorKind

        export class DeleteAccountWithLargeStateErrorKind {
          public account_id: string = "";

          // Decodes DeleteAccountWithLargeStateErrorKind from an ArrayBuffer
          static decode(
            buf: ArrayBuffer
          ): DeleteAccountWithLargeStateErrorKind {
            return DeleteAccountWithLargeStateErrorKind.decodeDataView(
              new DataView(buf)
            );
          }

          // Decodes DeleteAccountWithLargeStateErrorKind from a DataView
          static decodeDataView(
            view: DataView
          ): DeleteAccountWithLargeStateErrorKind {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteAccountWithLargeStateErrorKind();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.account_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeleteAccountWithLargeStateErrorKind

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.account_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.account_id.length) +
                  this.account_id.length
                : 0;

            return size;
          }

          // Encodes DeleteAccountWithLargeStateErrorKind to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeleteAccountWithLargeStateErrorKind to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.account_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.account_id.length);
              encoder.string(this.account_id);
            }

            return buf;
          } // encode DeleteAccountWithLargeStateErrorKind
        } // DeleteAccountWithLargeStateErrorKind

        export class MerklePath {
          public path: Array<MerklePathItem> = new Array<MerklePathItem>();

          // Decodes MerklePath from an ArrayBuffer
          static decode(buf: ArrayBuffer): MerklePath {
            return MerklePath.decodeDataView(new DataView(buf));
          }

          // Decodes MerklePath from a DataView
          static decodeDataView(view: DataView): MerklePath {
            const decoder = new __proto.Decoder(view);
            const obj = new MerklePath();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.path.push(
                    MerklePathItem.decodeDataView(
                      new DataView(
                        decoder.view.buffer,
                        decoder.pos + decoder.view.byteOffset,
                        length
                      )
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode MerklePath

          public size(): u32 {
            let size: u32 = 0;

            for (let n: i32 = 0; n < this.path.length; n++) {
              const messageSize = this.path[n].size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes MerklePath to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes MerklePath to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            for (let n: i32 = 0; n < this.path.length; n++) {
              const messageSize = this.path[n].size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                this.path[n].encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode MerklePath
        } // MerklePath

        export class MerklePathItem {
          public hash: CryptoHash = new CryptoHash();
          public direction: u32;

          // Decodes MerklePathItem from an ArrayBuffer
          static decode(buf: ArrayBuffer): MerklePathItem {
            return MerklePathItem.decodeDataView(new DataView(buf));
          }

          // Decodes MerklePathItem from a DataView
          static decodeDataView(view: DataView): MerklePathItem {
            const decoder = new __proto.Decoder(view);
            const obj = new MerklePathItem();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.hash = CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  obj.direction = decoder.uint32();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode MerklePathItem

          public size(): u32 {
            let size: u32 = 0;

            if (this.hash != null) {
              const f: CryptoHash = this.hash as CryptoHash;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.direction == 0
                ? 0
                : 1 + __proto.Sizer.uint32(this.direction);

            return size;
          }

          // Encodes MerklePathItem to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes MerklePathItem to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.hash != null) {
              const f = this.hash as CryptoHash;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.direction != 0) {
              encoder.uint32(0x10);
              encoder.uint32(this.direction);
            }

            return buf;
          } // encode MerklePathItem
        } // MerklePathItem

        export class Action {
          public create_account: CreateAccountAction | null;
          public deploy_contract: DeployContractAction | null;
          public function_call: FunctionCallAction | null;
          public transfer: TransferAction | null;
          public stake: StakeAction | null;
          public add_key: AddKeyAction | null;
          public delete_key: DeleteKeyAction | null;
          public delete_account: DeleteAccountAction | null;

          public __action: string = "";
          public __action_index: u8 = 0;

          static readonly ACTION_CREATE_ACCOUNT_INDEX: u8 = 1;
          static readonly ACTION_DEPLOY_CONTRACT_INDEX: u8 = 2;
          static readonly ACTION_FUNCTION_CALL_INDEX: u8 = 3;
          static readonly ACTION_TRANSFER_INDEX: u8 = 4;
          static readonly ACTION_STAKE_INDEX: u8 = 5;
          static readonly ACTION_ADD_KEY_INDEX: u8 = 6;
          static readonly ACTION_DELETE_KEY_INDEX: u8 = 7;
          static readonly ACTION_DELETE_ACCOUNT_INDEX: u8 = 8;

          // Decodes Action from an ArrayBuffer
          static decode(buf: ArrayBuffer): Action {
            return Action.decodeDataView(new DataView(buf));
          }

          // Decodes Action from a DataView
          static decodeDataView(view: DataView): Action {
            const decoder = new __proto.Decoder(view);
            const obj = new Action();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.create_account = CreateAccountAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "create_account";
                  obj.__action_index = 1;
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.deploy_contract = DeployContractAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "deploy_contract";
                  obj.__action_index = 2;
                  break;
                }
                case 3: {
                  const length = decoder.uint32();
                  obj.function_call = FunctionCallAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "function_call";
                  obj.__action_index = 3;
                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.transfer = TransferAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "transfer";
                  obj.__action_index = 4;
                  break;
                }
                case 5: {
                  const length = decoder.uint32();
                  obj.stake = StakeAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "stake";
                  obj.__action_index = 5;
                  break;
                }
                case 6: {
                  const length = decoder.uint32();
                  obj.add_key = AddKeyAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "add_key";
                  obj.__action_index = 6;
                  break;
                }
                case 7: {
                  const length = decoder.uint32();
                  obj.delete_key = DeleteKeyAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "delete_key";
                  obj.__action_index = 7;
                  break;
                }
                case 8: {
                  const length = decoder.uint32();
                  obj.delete_account = DeleteAccountAction.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__action = "delete_account";
                  obj.__action_index = 8;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode Action

          public size(): u32 {
            let size: u32 = 0;

            if (this.create_account != null) {
              const f: CreateAccountAction = this
                .create_account as CreateAccountAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.deploy_contract != null) {
              const f: DeployContractAction = this
                .deploy_contract as DeployContractAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.function_call != null) {
              const f: FunctionCallAction = this
                .function_call as FunctionCallAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.transfer != null) {
              const f: TransferAction = this.transfer as TransferAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.stake != null) {
              const f: StakeAction = this.stake as StakeAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.add_key != null) {
              const f: AddKeyAction = this.add_key as AddKeyAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.delete_key != null) {
              const f: DeleteKeyAction = this.delete_key as DeleteKeyAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.delete_account != null) {
              const f: DeleteAccountAction = this
                .delete_account as DeleteAccountAction;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes Action to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes Action to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.create_account != null) {
              const f = this.create_account as CreateAccountAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.deploy_contract != null) {
              const f = this.deploy_contract as DeployContractAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.function_call != null) {
              const f = this.function_call as FunctionCallAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x1a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.transfer != null) {
              const f = this.transfer as TransferAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.stake != null) {
              const f = this.stake as StakeAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x2a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.add_key != null) {
              const f = this.add_key as AddKeyAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x32);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.delete_key != null) {
              const f = this.delete_key as DeleteKeyAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x3a);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.delete_account != null) {
              const f = this.delete_account as DeleteAccountAction;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x42);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode Action
        } // Action

        export class CreateAccountAction {
          // Decodes CreateAccountAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): CreateAccountAction {
            return CreateAccountAction.decodeDataView(new DataView(buf));
          }

          // Decodes CreateAccountAction from a DataView
          static decodeDataView(view: DataView): CreateAccountAction {
            const decoder = new __proto.Decoder(view);
            const obj = new CreateAccountAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode CreateAccountAction

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes CreateAccountAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes CreateAccountAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode CreateAccountAction
        } // CreateAccountAction

        export class DeployContractAction {
          public code: Array<u8> = new Array<u8>();

          // Decodes DeployContractAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): DeployContractAction {
            return DeployContractAction.decodeDataView(new DataView(buf));
          }

          // Decodes DeployContractAction from a DataView
          static decodeDataView(view: DataView): DeployContractAction {
            const decoder = new __proto.Decoder(view);
            const obj = new DeployContractAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.code = decoder.bytes();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeployContractAction

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.code.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.code.length) +
                  this.code.length
                : 0;

            return size;
          }

          // Encodes DeployContractAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeployContractAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.code.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.code.length);
              encoder.bytes(this.code);
            }

            return buf;
          } // encode DeployContractAction
        } // DeployContractAction

        export class FunctionCallAction {
          public method_name: string = "";
          public args: Array<u8> = new Array<u8>();
          public gas: u64;
          public deposit: BigInt = new BigInt();

          // Decodes FunctionCallAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): FunctionCallAction {
            return FunctionCallAction.decodeDataView(new DataView(buf));
          }

          // Decodes FunctionCallAction from a DataView
          static decodeDataView(view: DataView): FunctionCallAction {
            const decoder = new __proto.Decoder(view);
            const obj = new FunctionCallAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.method_name = decoder.string();
                  break;
                }
                case 2: {
                  obj.args = decoder.bytes();
                  break;
                }
                case 3: {
                  obj.gas = decoder.uint64();
                  break;
                }
                case 4: {
                  const length = decoder.uint32();
                  obj.deposit = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode FunctionCallAction

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.method_name.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.method_name.length) +
                  this.method_name.length
                : 0;
            size +=
              this.args.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.args.length) +
                  this.args.length
                : 0;
            size += this.gas == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas);

            if (this.deposit != null) {
              const f: BigInt = this.deposit as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes FunctionCallAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes FunctionCallAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.method_name.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.method_name.length);
              encoder.string(this.method_name);
            }
            if (this.args.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.args.length);
              encoder.bytes(this.args);
            }
            if (this.gas != 0) {
              encoder.uint32(0x18);
              encoder.uint64(this.gas);
            }

            if (this.deposit != null) {
              const f = this.deposit as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x22);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode FunctionCallAction
        } // FunctionCallAction

        export class TransferAction {
          public deposit: BigInt = new BigInt();

          // Decodes TransferAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): TransferAction {
            return TransferAction.decodeDataView(new DataView(buf));
          }

          // Decodes TransferAction from a DataView
          static decodeDataView(view: DataView): TransferAction {
            const decoder = new __proto.Decoder(view);
            const obj = new TransferAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.deposit = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode TransferAction

          public size(): u32 {
            let size: u32 = 0;

            if (this.deposit != null) {
              const f: BigInt = this.deposit as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes TransferAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes TransferAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.deposit != null) {
              const f = this.deposit as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode TransferAction
        } // TransferAction

        export class StakeAction {
          public stake: BigInt = new BigInt();
          public public_key: PublicKey = new PublicKey();

          // Decodes StakeAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): StakeAction {
            return StakeAction.decodeDataView(new DataView(buf));
          }

          // Decodes StakeAction from a DataView
          static decodeDataView(view: DataView): StakeAction {
            const decoder = new __proto.Decoder(view);
            const obj = new StakeAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.stake = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode StakeAction

          public size(): u32 {
            let size: u32 = 0;

            if (this.stake != null) {
              const f: BigInt = this.stake as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes StakeAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes StakeAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.stake != null) {
              const f = this.stake as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode StakeAction
        } // StakeAction

        export class AddKeyAction {
          public public_key: PublicKey = new PublicKey();
          public access_key: AccessKey = new AccessKey();

          // Decodes AddKeyAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): AddKeyAction {
            return AddKeyAction.decodeDataView(new DataView(buf));
          }

          // Decodes AddKeyAction from a DataView
          static decodeDataView(view: DataView): AddKeyAction {
            const decoder = new __proto.Decoder(view);
            const obj = new AddKeyAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.access_key = AccessKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AddKeyAction

          public size(): u32 {
            let size: u32 = 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.access_key != null) {
              const f: AccessKey = this.access_key as AccessKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes AddKeyAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AddKeyAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.access_key != null) {
              const f = this.access_key as AccessKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode AddKeyAction
        } // AddKeyAction

        export class DeleteKeyAction {
          public public_key: PublicKey = new PublicKey();

          // Decodes DeleteKeyAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): DeleteKeyAction {
            return DeleteKeyAction.decodeDataView(new DataView(buf));
          }

          // Decodes DeleteKeyAction from a DataView
          static decodeDataView(view: DataView): DeleteKeyAction {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteKeyAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.public_key = PublicKey.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeleteKeyAction

          public size(): u32 {
            let size: u32 = 0;

            if (this.public_key != null) {
              const f: PublicKey = this.public_key as PublicKey;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes DeleteKeyAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeleteKeyAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.public_key != null) {
              const f = this.public_key as PublicKey;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode DeleteKeyAction
        } // DeleteKeyAction

        export class DeleteAccountAction {
          public beneficiary_id: string = "";

          // Decodes DeleteAccountAction from an ArrayBuffer
          static decode(buf: ArrayBuffer): DeleteAccountAction {
            return DeleteAccountAction.decodeDataView(new DataView(buf));
          }

          // Decodes DeleteAccountAction from a DataView
          static decodeDataView(view: DataView): DeleteAccountAction {
            const decoder = new __proto.Decoder(view);
            const obj = new DeleteAccountAction();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.beneficiary_id = decoder.string();
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode DeleteAccountAction

          public size(): u32 {
            let size: u32 = 0;

            size +=
              this.beneficiary_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.beneficiary_id.length) +
                  this.beneficiary_id.length
                : 0;

            return size;
          }

          // Encodes DeleteAccountAction to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes DeleteAccountAction to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.beneficiary_id.length > 0) {
              encoder.uint32(0xa);
              encoder.uint32(this.beneficiary_id.length);
              encoder.string(this.beneficiary_id);
            }

            return buf;
          } // encode DeleteAccountAction
        } // DeleteAccountAction

        export class AccessKey {
          public nonce: u64;
          public permission: AccessKeyPermission = new AccessKeyPermission();

          // Decodes AccessKey from an ArrayBuffer
          static decode(buf: ArrayBuffer): AccessKey {
            return AccessKey.decodeDataView(new DataView(buf));
          }

          // Decodes AccessKey from a DataView
          static decodeDataView(view: DataView): AccessKey {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessKey();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  obj.nonce = decoder.uint64();
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.permission = AccessKeyPermission.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AccessKey

          public size(): u32 {
            let size: u32 = 0;

            size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);

            if (this.permission != null) {
              const f: AccessKeyPermission = this
                .permission as AccessKeyPermission;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes AccessKey to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AccessKey to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.nonce != 0) {
              encoder.uint32(0x8);
              encoder.uint64(this.nonce);
            }

            if (this.permission != null) {
              const f = this.permission as AccessKeyPermission;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode AccessKey
        } // AccessKey

        export class AccessKeyPermission {
          public function_call: FunctionCallPermission | null;
          public full_access: FullAccessPermission | null;

          public __permission: string = "";
          public __permission_index: u8 = 0;

          static readonly PERMISSION_FUNCTION_CALL_INDEX: u8 = 1;
          static readonly PERMISSION_FULL_ACCESS_INDEX: u8 = 2;

          // Decodes AccessKeyPermission from an ArrayBuffer
          static decode(buf: ArrayBuffer): AccessKeyPermission {
            return AccessKeyPermission.decodeDataView(new DataView(buf));
          }

          // Decodes AccessKeyPermission from a DataView
          static decodeDataView(view: DataView): AccessKeyPermission {
            const decoder = new __proto.Decoder(view);
            const obj = new AccessKeyPermission();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.function_call = FunctionCallPermission.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__permission = "function_call";
                  obj.__permission_index = 1;
                  break;
                }
                case 2: {
                  const length = decoder.uint32();
                  obj.full_access = FullAccessPermission.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  obj.__permission = "full_access";
                  obj.__permission_index = 2;
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode AccessKeyPermission

          public size(): u32 {
            let size: u32 = 0;

            if (this.function_call != null) {
              const f: FunctionCallPermission = this
                .function_call as FunctionCallPermission;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            if (this.full_access != null) {
              const f: FullAccessPermission = this
                .full_access as FullAccessPermission;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            return size;
          }

          // Encodes AccessKeyPermission to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes AccessKeyPermission to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.function_call != null) {
              const f = this.function_call as FunctionCallPermission;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.full_access != null) {
              const f = this.full_access as FullAccessPermission;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0x12);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            return buf;
          } // encode AccessKeyPermission
        } // AccessKeyPermission

        export class FunctionCallPermission {
          public allowance: BigInt = new BigInt();
          public receiver_id: string = "";
          public method_names: Array<string> = new Array<string>();

          // Decodes FunctionCallPermission from an ArrayBuffer
          static decode(buf: ArrayBuffer): FunctionCallPermission {
            return FunctionCallPermission.decodeDataView(new DataView(buf));
          }

          // Decodes FunctionCallPermission from a DataView
          static decodeDataView(view: DataView): FunctionCallPermission {
            const decoder = new __proto.Decoder(view);
            const obj = new FunctionCallPermission();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                case 1: {
                  const length = decoder.uint32();
                  obj.allowance = BigInt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                  decoder.skip(length);

                  break;
                }
                case 2: {
                  obj.receiver_id = decoder.string();
                  break;
                }
                case 3: {
                  obj.method_names.push(decoder.string());
                  break;
                }

                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode FunctionCallPermission

          public size(): u32 {
            let size: u32 = 0;

            if (this.allowance != null) {
              const f: BigInt = this.allowance as BigInt;
              const messageSize = f.size();

              if (messageSize > 0) {
                size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
              }
            }

            size +=
              this.receiver_id.length > 0
                ? 1 +
                  __proto.Sizer.varint64(this.receiver_id.length) +
                  this.receiver_id.length
                : 0;

            size += __size_string_repeated(this.method_names);

            return size;
          }

          // Encodes FunctionCallPermission to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes FunctionCallPermission to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            if (this.allowance != null) {
              const f = this.allowance as BigInt;

              const messageSize = f.size();

              if (messageSize > 0) {
                encoder.uint32(0xa);
                encoder.uint32(messageSize);
                f.encodeU8Array(encoder);
              }
            }

            if (this.receiver_id.length > 0) {
              encoder.uint32(0x12);
              encoder.uint32(this.receiver_id.length);
              encoder.string(this.receiver_id);
            }

            if (this.method_names.length > 0) {
              for (let n: i32 = 0; n < this.method_names.length; n++) {
                encoder.uint32(0x1a);
                encoder.uint32(this.method_names[n].length);
                encoder.string(this.method_names[n]);
              }
            }

            return buf;
          } // encode FunctionCallPermission
        } // FunctionCallPermission

        export class FullAccessPermission {
          // Decodes FullAccessPermission from an ArrayBuffer
          static decode(buf: ArrayBuffer): FullAccessPermission {
            return FullAccessPermission.decodeDataView(new DataView(buf));
          }

          // Decodes FullAccessPermission from a DataView
          static decodeDataView(view: DataView): FullAccessPermission {
            const decoder = new __proto.Decoder(view);
            const obj = new FullAccessPermission();

            while (!decoder.eof()) {
              const tag = decoder.tag();
              const number = tag >>> 3;

              switch (number) {
                default:
                  decoder.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          } // decode FullAccessPermission

          public size(): u32 {
            let size: u32 = 0;

            return size;
          }

          // Encodes FullAccessPermission to the ArrayBuffer
          encode(): ArrayBuffer {
            return changetype<ArrayBuffer>(
              StaticArray.fromArray<u8>(this.encodeU8Array())
            );
          }

          // Encodes FullAccessPermission to the Array<u8>
          encodeU8Array(
            encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
          ): Array<u8> {
            const buf = encoder.buf;

            return buf;
          } // encode FullAccessPermission
        } // FullAccessPermission
      } // v1
    } // codec
    export namespace v1 {
      export enum CurveKind {
        ED25519 = 0,
        SECP256K1 = 1,
      } // CurveKind
      export enum ExecutionMetadata {
        ExecutionMetadataV1 = 0,
      } // ExecutionMetadata
      // todo: add more detail?
      export enum FunctionCallErrorSer {
        CompilationError = 0,
        LinkError = 1,
        MethodResolveError = 2,
        WasmTrap = 3,
        WasmUnknownError = 4,
        HostError = 5,
        _EVMError = 6,
        ExecutionError = 7,
      } // FunctionCallErrorSer
      // todo: add more detail?
      export enum ReceiptValidationError {
        InvalidPredecessorId = 0,
        InvalidReceiverAccountId = 1,
        InvalidSignerAccountId = 2,
        InvalidDataReceiverId = 3,
        ReturnedValueLengthExceeded = 4,
        NumberInputDataDependenciesExceeded = 5,
        ActionsValidationError = 6,
      } // ReceiptValidationError
      // todo: add more detail?
      export enum InvalidTxError {
        InvalidAccessKeyError = 0,
        InvalidSignerId = 1,
        SignerDoesNotExist = 2,
        InvalidNonce = 3,
        NonceTooLarge = 4,
        InvalidReceiverId = 5,
        InvalidSignature = 6,
        NotEnoughBalance = 7,
        LackBalanceForState = 8,
        CostOverflow = 9,
        InvalidChain = 10,
        Expired = 11,
        ActionsValidation = 12,
        TransactionSizeExceeded = 13,
      } // InvalidTxError
      export enum Direction {
        left = 0,
        right = 1,
      } // Direction
      export class Block {
        public author: string = "";
        public header: BlockHeader = new BlockHeader();
        public chunk_headers: Array<ChunkHeader> = new Array<ChunkHeader>();
        public shards: Array<IndexerShard> = new Array<IndexerShard>();
        public state_changes: Array<StateChangeWithCause> =
          new Array<StateChangeWithCause>();

        // Decodes Block from an ArrayBuffer
        static decode(buf: ArrayBuffer): Block {
          return Block.decodeDataView(new DataView(buf));
        }

        // Decodes Block from a DataView
        static decodeDataView(view: DataView): Block {
          const decoder = new __proto.Decoder(view);
          const obj = new Block();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.author = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.header = BlockHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.chunk_headers.push(
                  ChunkHeader.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.shards.push(
                  IndexerShard.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.state_changes.push(
                  StateChangeWithCause.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Block

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.author.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.author.length) +
                this.author.length
              : 0;

          if (this.header != null) {
            const f: BlockHeader = this.header as BlockHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
            const messageSize = this.chunk_headers[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.shards.length; n++) {
            const messageSize = this.shards[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.state_changes.length; n++) {
            const messageSize = this.state_changes[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Block to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Block to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.author.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.author.length);
            encoder.string(this.author);
          }

          if (this.header != null) {
            const f = this.header as BlockHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
            const messageSize = this.chunk_headers[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.chunk_headers[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.shards.length; n++) {
            const messageSize = this.shards[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.shards[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.state_changes.length; n++) {
            const messageSize = this.state_changes[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.state_changes[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Block
      } // Block

      /**
       * HeaderOnlyBlock is a standard [Block] structure where all other fields are
       *  removed so that hydrating that object from a [Block] bytes payload will
       *  drastically reduced allocated memory required to hold the full block.
       *
       *  This can be used to unpack a [Block] when only the [BlockHeader] information
       *  is required and greatly reduced required memory.
       */
      export class HeaderOnlyBlock {
        public header: BlockHeader = new BlockHeader();

        // Decodes HeaderOnlyBlock from an ArrayBuffer
        static decode(buf: ArrayBuffer): HeaderOnlyBlock {
          return HeaderOnlyBlock.decodeDataView(new DataView(buf));
        }

        // Decodes HeaderOnlyBlock from a DataView
        static decodeDataView(view: DataView): HeaderOnlyBlock {
          const decoder = new __proto.Decoder(view);
          const obj = new HeaderOnlyBlock();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 2: {
                const length = decoder.uint32();
                obj.header = BlockHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode HeaderOnlyBlock

        public size(): u32 {
          let size: u32 = 0;

          if (this.header != null) {
            const f: BlockHeader = this.header as BlockHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes HeaderOnlyBlock to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes HeaderOnlyBlock to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.header != null) {
            const f = this.header as BlockHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode HeaderOnlyBlock
      } // HeaderOnlyBlock

      export class StateChangeWithCause {
        public value: StateChangeValue = new StateChangeValue();
        public cause: StateChangeCause = new StateChangeCause();

        // Decodes StateChangeWithCause from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeWithCause {
          return StateChangeWithCause.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeWithCause from a DataView
        static decodeDataView(view: DataView): StateChangeWithCause {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeWithCause();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.value = StateChangeValue.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.cause = StateChangeCause.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeWithCause

        public size(): u32 {
          let size: u32 = 0;

          if (this.value != null) {
            const f: StateChangeValue = this.value as StateChangeValue;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.cause != null) {
            const f: StateChangeCause = this.cause as StateChangeCause;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeWithCause to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeWithCause to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.value != null) {
            const f = this.value as StateChangeValue;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.cause != null) {
            const f = this.cause as StateChangeCause;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeWithCause
      } // StateChangeWithCause

      // / A top-level account ID can only be created by registrar.
      export class StateChangeCause {
        public not_writable_to_disk: StateChangeCause_NotWritableToDisk | null;
        public initial_state: StateChangeCause_InitialState | null;
        public transaction_processing: StateChangeCause_TransactionProcessing | null;
        public action_receipt_processing_started: StateChangeCause_ActionReceiptProcessingStarted | null;
        public action_receipt_gas_reward: StateChangeCause_ActionReceiptGasReward | null;
        public receipt_processing: StateChangeCause_ReceiptProcessing | null;
        public postponed_receipt: StateChangeCause_PostponedReceipt | null;
        public updated_delayed_receipts: StateChangeCause_UpdatedDelayedReceipts | null;
        public validator_accounts_update: StateChangeCause_ValidatorAccountsUpdate | null;
        public migration: StateChangeCause_Migration | null;

        public __cause: string = "";
        public __cause_index: u8 = 0;

        static readonly CAUSE_NOT_WRITABLE_TO_DISK_INDEX: u8 = 1;
        static readonly CAUSE_INITIAL_STATE_INDEX: u8 = 2;
        static readonly CAUSE_TRANSACTION_PROCESSING_INDEX: u8 = 3;
        static readonly CAUSE_ACTION_RECEIPT_PROCESSING_STARTED_INDEX: u8 = 4;
        static readonly CAUSE_ACTION_RECEIPT_GAS_REWARD_INDEX: u8 = 5;
        static readonly CAUSE_RECEIPT_PROCESSING_INDEX: u8 = 6;
        static readonly CAUSE_POSTPONED_RECEIPT_INDEX: u8 = 7;
        static readonly CAUSE_UPDATED_DELAYED_RECEIPTS_INDEX: u8 = 8;
        static readonly CAUSE_VALIDATOR_ACCOUNTS_UPDATE_INDEX: u8 = 9;
        static readonly CAUSE_MIGRATION_INDEX: u8 = 10;

        // Decodes StateChangeCause from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause {
          return StateChangeCause.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeCause from a DataView
        static decodeDataView(view: DataView): StateChangeCause {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.not_writable_to_disk =
                  StateChangeCause_NotWritableToDisk.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "not_writable_to_disk";
                obj.__cause_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.initial_state =
                  StateChangeCause_InitialState.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "initial_state";
                obj.__cause_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.transaction_processing =
                  StateChangeCause_TransactionProcessing.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "transaction_processing";
                obj.__cause_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.action_receipt_processing_started =
                  StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "action_receipt_processing_started";
                obj.__cause_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.action_receipt_gas_reward =
                  StateChangeCause_ActionReceiptGasReward.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "action_receipt_gas_reward";
                obj.__cause_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.receipt_processing =
                  StateChangeCause_ReceiptProcessing.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "receipt_processing";
                obj.__cause_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.postponed_receipt =
                  StateChangeCause_PostponedReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "postponed_receipt";
                obj.__cause_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.updated_delayed_receipts =
                  StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "updated_delayed_receipts";
                obj.__cause_index = 8;
                break;
              }
              case 9: {
                const length = decoder.uint32();
                obj.validator_accounts_update =
                  StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "validator_accounts_update";
                obj.__cause_index = 9;
                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.migration = StateChangeCause_Migration.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__cause = "migration";
                obj.__cause_index = 10;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause

        public size(): u32 {
          let size: u32 = 0;

          if (this.not_writable_to_disk != null) {
            const f: StateChangeCause_NotWritableToDisk = this
              .not_writable_to_disk as StateChangeCause_NotWritableToDisk;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.initial_state != null) {
            const f: StateChangeCause_InitialState = this
              .initial_state as StateChangeCause_InitialState;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.transaction_processing != null) {
            const f: StateChangeCause_TransactionProcessing = this
              .transaction_processing as StateChangeCause_TransactionProcessing;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action_receipt_processing_started != null) {
            const f: StateChangeCause_ActionReceiptProcessingStarted = this
              .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action_receipt_gas_reward != null) {
            const f: StateChangeCause_ActionReceiptGasReward = this
              .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt_processing != null) {
            const f: StateChangeCause_ReceiptProcessing = this
              .receipt_processing as StateChangeCause_ReceiptProcessing;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.postponed_receipt != null) {
            const f: StateChangeCause_PostponedReceipt = this
              .postponed_receipt as StateChangeCause_PostponedReceipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.updated_delayed_receipts != null) {
            const f: StateChangeCause_UpdatedDelayedReceipts = this
              .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.validator_accounts_update != null) {
            const f: StateChangeCause_ValidatorAccountsUpdate = this
              .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.migration != null) {
            const f: StateChangeCause_Migration = this
              .migration as StateChangeCause_Migration;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.not_writable_to_disk != null) {
            const f = this
              .not_writable_to_disk as StateChangeCause_NotWritableToDisk;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.initial_state != null) {
            const f = this.initial_state as StateChangeCause_InitialState;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.transaction_processing != null) {
            const f = this
              .transaction_processing as StateChangeCause_TransactionProcessing;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action_receipt_processing_started != null) {
            const f = this
              .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action_receipt_gas_reward != null) {
            const f = this
              .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt_processing != null) {
            const f = this
              .receipt_processing as StateChangeCause_ReceiptProcessing;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.postponed_receipt != null) {
            const f = this
              .postponed_receipt as StateChangeCause_PostponedReceipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.updated_delayed_receipts != null) {
            const f = this
              .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.validator_accounts_update != null) {
            const f = this
              .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x4a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.migration != null) {
            const f = this.migration as StateChangeCause_Migration;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause
      } // StateChangeCause

      export class StateChangeCause_NotWritableToDisk {
        // Decodes StateChangeCause_NotWritableToDisk from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_NotWritableToDisk {
          return StateChangeCause_NotWritableToDisk.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_NotWritableToDisk from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_NotWritableToDisk {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_NotWritableToDisk();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_NotWritableToDisk

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_NotWritableToDisk to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_NotWritableToDisk to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_NotWritableToDisk
      } // StateChangeCause_NotWritableToDisk

      export class StateChangeCause_InitialState {
        // Decodes StateChangeCause_InitialState from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_InitialState {
          return StateChangeCause_InitialState.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_InitialState from a DataView
        static decodeDataView(view: DataView): StateChangeCause_InitialState {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_InitialState();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_InitialState

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_InitialState to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_InitialState to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_InitialState
      } // StateChangeCause_InitialState

      export class StateChangeCause_TransactionProcessing {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_TransactionProcessing from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_TransactionProcessing {
          return StateChangeCause_TransactionProcessing.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_TransactionProcessing from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_TransactionProcessing {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_TransactionProcessing();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_TransactionProcessing

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_TransactionProcessing to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_TransactionProcessing to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_TransactionProcessing
      } // StateChangeCause_TransactionProcessing

      export class StateChangeCause_ActionReceiptProcessingStarted {
        public receipt_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ActionReceiptProcessingStarted from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ActionReceiptProcessingStarted {
          return StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ActionReceiptProcessingStarted from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ActionReceiptProcessingStarted {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ActionReceiptProcessingStarted();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.receipt_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ActionReceiptProcessingStarted

        public size(): u32 {
          let size: u32 = 0;

          if (this.receipt_hash != null) {
            const f: CryptoHash = this.receipt_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ActionReceiptProcessingStarted to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ActionReceiptProcessingStarted to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.receipt_hash != null) {
            const f = this.receipt_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ActionReceiptProcessingStarted
      } // StateChangeCause_ActionReceiptProcessingStarted

      export class StateChangeCause_ActionReceiptGasReward {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ActionReceiptGasReward from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ActionReceiptGasReward {
          return StateChangeCause_ActionReceiptGasReward.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ActionReceiptGasReward from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ActionReceiptGasReward {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ActionReceiptGasReward();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ActionReceiptGasReward

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ActionReceiptGasReward to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ActionReceiptGasReward to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ActionReceiptGasReward
      } // StateChangeCause_ActionReceiptGasReward

      export class StateChangeCause_ReceiptProcessing {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ReceiptProcessing from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_ReceiptProcessing {
          return StateChangeCause_ReceiptProcessing.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ReceiptProcessing from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ReceiptProcessing {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ReceiptProcessing();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ReceiptProcessing

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ReceiptProcessing to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ReceiptProcessing to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ReceiptProcessing
      } // StateChangeCause_ReceiptProcessing

      export class StateChangeCause_PostponedReceipt {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_PostponedReceipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_PostponedReceipt {
          return StateChangeCause_PostponedReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_PostponedReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_PostponedReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_PostponedReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_PostponedReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_PostponedReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_PostponedReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_PostponedReceipt
      } // StateChangeCause_PostponedReceipt

      export class StateChangeCause_UpdatedDelayedReceipts {
        // Decodes StateChangeCause_UpdatedDelayedReceipts from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_UpdatedDelayedReceipts {
          return StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_UpdatedDelayedReceipts from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_UpdatedDelayedReceipts {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_UpdatedDelayedReceipts();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_UpdatedDelayedReceipts

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_UpdatedDelayedReceipts to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_UpdatedDelayedReceipts to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_UpdatedDelayedReceipts
      } // StateChangeCause_UpdatedDelayedReceipts

      export class StateChangeCause_ValidatorAccountsUpdate {
        // Decodes StateChangeCause_ValidatorAccountsUpdate from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ValidatorAccountsUpdate {
          return StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ValidatorAccountsUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ValidatorAccountsUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ValidatorAccountsUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ValidatorAccountsUpdate

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_ValidatorAccountsUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ValidatorAccountsUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_ValidatorAccountsUpdate
      } // StateChangeCause_ValidatorAccountsUpdate

      export class StateChangeCause_Migration {
        // Decodes StateChangeCause_Migration from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_Migration {
          return StateChangeCause_Migration.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeCause_Migration from a DataView
        static decodeDataView(view: DataView): StateChangeCause_Migration {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_Migration();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_Migration

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_Migration to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_Migration to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_Migration
      } // StateChangeCause_Migration

      export class StateChangeValue {
        public account_update: StateChangeValue_AccountUpdate | null;
        public account_deletion: StateChangeValue_AccountDeletion | null;
        public access_key_update: StateChangeValue_AccessKeyUpdate | null;
        public access_key_deletion: StateChangeValue_AccessKeyDeletion | null;
        public data_update: StateChangeValue_DataUpdate | null;
        public data_deletion: StateChangeValue_DataDeletion | null;
        public contract_code_update: StateChangeValue_ContractCodeUpdate | null;
        public contract_deletion: StateChangeValue_ContractCodeDeletion | null;

        public __value: string = "";
        public __value_index: u8 = 0;

        static readonly VALUE_ACCOUNT_UPDATE_INDEX: u8 = 1;
        static readonly VALUE_ACCOUNT_DELETION_INDEX: u8 = 2;
        static readonly VALUE_ACCESS_KEY_UPDATE_INDEX: u8 = 3;
        static readonly VALUE_ACCESS_KEY_DELETION_INDEX: u8 = 4;
        static readonly VALUE_DATA_UPDATE_INDEX: u8 = 5;
        static readonly VALUE_DATA_DELETION_INDEX: u8 = 6;
        static readonly VALUE_CONTRACT_CODE_UPDATE_INDEX: u8 = 7;
        static readonly VALUE_CONTRACT_DELETION_INDEX: u8 = 8;

        // Decodes StateChangeValue from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue {
          return StateChangeValue.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeValue from a DataView
        static decodeDataView(view: DataView): StateChangeValue {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.account_update =
                  StateChangeValue_AccountUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "account_update";
                obj.__value_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.account_deletion =
                  StateChangeValue_AccountDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "account_deletion";
                obj.__value_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.access_key_update =
                  StateChangeValue_AccessKeyUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "access_key_update";
                obj.__value_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.access_key_deletion =
                  StateChangeValue_AccessKeyDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "access_key_deletion";
                obj.__value_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.data_update = StateChangeValue_DataUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__value = "data_update";
                obj.__value_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.data_deletion =
                  StateChangeValue_DataDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "data_deletion";
                obj.__value_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.contract_code_update =
                  StateChangeValue_ContractCodeUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "contract_code_update";
                obj.__value_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.contract_deletion =
                  StateChangeValue_ContractCodeDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "contract_deletion";
                obj.__value_index = 8;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue

        public size(): u32 {
          let size: u32 = 0;

          if (this.account_update != null) {
            const f: StateChangeValue_AccountUpdate = this
              .account_update as StateChangeValue_AccountUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.account_deletion != null) {
            const f: StateChangeValue_AccountDeletion = this
              .account_deletion as StateChangeValue_AccountDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key_update != null) {
            const f: StateChangeValue_AccessKeyUpdate = this
              .access_key_update as StateChangeValue_AccessKeyUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key_deletion != null) {
            const f: StateChangeValue_AccessKeyDeletion = this
              .access_key_deletion as StateChangeValue_AccessKeyDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data_update != null) {
            const f: StateChangeValue_DataUpdate = this
              .data_update as StateChangeValue_DataUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data_deletion != null) {
            const f: StateChangeValue_DataDeletion = this
              .data_deletion as StateChangeValue_DataDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.contract_code_update != null) {
            const f: StateChangeValue_ContractCodeUpdate = this
              .contract_code_update as StateChangeValue_ContractCodeUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.contract_deletion != null) {
            const f: StateChangeValue_ContractCodeDeletion = this
              .contract_deletion as StateChangeValue_ContractCodeDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_update != null) {
            const f = this.account_update as StateChangeValue_AccountUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.account_deletion != null) {
            const f = this.account_deletion as StateChangeValue_AccountDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key_update != null) {
            const f = this
              .access_key_update as StateChangeValue_AccessKeyUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key_deletion != null) {
            const f = this
              .access_key_deletion as StateChangeValue_AccessKeyDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data_update != null) {
            const f = this.data_update as StateChangeValue_DataUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data_deletion != null) {
            const f = this.data_deletion as StateChangeValue_DataDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.contract_code_update != null) {
            const f = this
              .contract_code_update as StateChangeValue_ContractCodeUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.contract_deletion != null) {
            const f = this
              .contract_deletion as StateChangeValue_ContractCodeDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue
      } // StateChangeValue

      export class StateChangeValue_AccountUpdate {
        public account_id: string = "";
        public account: Account = new Account();

        // Decodes StateChangeValue_AccountUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccountUpdate {
          return StateChangeValue_AccountUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccountUpdate from a DataView
        static decodeDataView(view: DataView): StateChangeValue_AccountUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccountUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.account = Account.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccountUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.account != null) {
            const f: Account = this.account as Account;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccountUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccountUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.account != null) {
            const f = this.account as Account;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccountUpdate
      } // StateChangeValue_AccountUpdate

      export class StateChangeValue_AccountDeletion {
        public account_id: string = "";

        // Decodes StateChangeValue_AccountDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccountDeletion {
          return StateChangeValue_AccountDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccountDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccountDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccountDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccountDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_AccountDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccountDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode StateChangeValue_AccountDeletion
      } // StateChangeValue_AccountDeletion

      export class StateChangeValue_AccessKeyUpdate {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public access_key: AccessKey = new AccessKey();

        // Decodes StateChangeValue_AccessKeyUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyUpdate {
          return StateChangeValue_AccessKeyUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccessKeyUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccessKeyUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccessKeyUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.access_key = AccessKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccessKeyUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key != null) {
            const f: AccessKey = this.access_key as AccessKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccessKeyUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccessKeyUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key != null) {
            const f = this.access_key as AccessKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccessKeyUpdate
      } // StateChangeValue_AccessKeyUpdate

      export class StateChangeValue_AccessKeyDeletion {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes StateChangeValue_AccessKeyDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyDeletion {
          return StateChangeValue_AccessKeyDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccessKeyDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccessKeyDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccessKeyDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccessKeyDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccessKeyDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccessKeyDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccessKeyDeletion
      } // StateChangeValue_AccessKeyDeletion

      export class StateChangeValue_DataUpdate {
        public account_id: string = "";
        public key: Array<u8> = new Array<u8>();
        public value: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_DataUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_DataUpdate {
          return StateChangeValue_DataUpdate.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeValue_DataUpdate from a DataView
        static decodeDataView(view: DataView): StateChangeValue_DataUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_DataUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.key = decoder.bytes();
                break;
              }
              case 3: {
                obj.value = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_DataUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.key.length > 0
              ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
              : 0;
          size +=
            this.value.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.value.length) +
                this.value.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_DataUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_DataUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.key.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.key.length);
            encoder.bytes(this.key);
          }
          if (this.value.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.value.length);
            encoder.bytes(this.value);
          }

          return buf;
        } // encode StateChangeValue_DataUpdate
      } // StateChangeValue_DataUpdate

      export class StateChangeValue_DataDeletion {
        public account_id: string = "";
        public key: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_DataDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_DataDeletion {
          return StateChangeValue_DataDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_DataDeletion from a DataView
        static decodeDataView(view: DataView): StateChangeValue_DataDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_DataDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.key = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_DataDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.key.length > 0
              ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_DataDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_DataDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.key.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.key.length);
            encoder.bytes(this.key);
          }

          return buf;
        } // encode StateChangeValue_DataDeletion
      } // StateChangeValue_DataDeletion

      export class StateChangeValue_ContractCodeUpdate {
        public account_id: string = "";
        public code: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_ContractCodeUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeUpdate {
          return StateChangeValue_ContractCodeUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_ContractCodeUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_ContractCodeUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_ContractCodeUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.code = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_ContractCodeUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.code.length > 0
              ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_ContractCodeUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_ContractCodeUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.code.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.code.length);
            encoder.bytes(this.code);
          }

          return buf;
        } // encode StateChangeValue_ContractCodeUpdate
      } // StateChangeValue_ContractCodeUpdate

      export class StateChangeValue_ContractCodeDeletion {
        public account_id: string = "";

        // Decodes StateChangeValue_ContractCodeDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeDeletion {
          return StateChangeValue_ContractCodeDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_ContractCodeDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_ContractCodeDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_ContractCodeDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_ContractCodeDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_ContractCodeDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_ContractCodeDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode StateChangeValue_ContractCodeDeletion
      } // StateChangeValue_ContractCodeDeletion

      export class Account {
        public amount: BigInt = new BigInt();
        public locked: BigInt = new BigInt();
        public code_hash: CryptoHash = new CryptoHash();
        public storage_usage: u64;

        // Decodes Account from an ArrayBuffer
        static decode(buf: ArrayBuffer): Account {
          return Account.decodeDataView(new DataView(buf));
        }

        // Decodes Account from a DataView
        static decodeDataView(view: DataView): Account {
          const decoder = new __proto.Decoder(view);
          const obj = new Account();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.amount = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.locked = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.code_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                obj.storage_usage = decoder.uint64();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Account

        public size(): u32 {
          let size: u32 = 0;

          if (this.amount != null) {
            const f: BigInt = this.amount as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.locked != null) {
            const f: BigInt = this.locked as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.code_hash != null) {
            const f: CryptoHash = this.code_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.storage_usage == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.storage_usage);

          return size;
        }

        // Encodes Account to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Account to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.amount != null) {
            const f = this.amount as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.locked != null) {
            const f = this.locked as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.code_hash != null) {
            const f = this.code_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.storage_usage != 0) {
            encoder.uint32(0x20);
            encoder.uint64(this.storage_usage);
          }

          return buf;
        } // encode Account
      } // Account

      export class BlockHeader {
        public height: u64;
        public prev_height: u64;
        public epoch_id: CryptoHash = new CryptoHash();
        public next_epoch_id: CryptoHash = new CryptoHash();
        public hash: CryptoHash = new CryptoHash();
        public prev_hash: CryptoHash = new CryptoHash();
        public prev_state_root: CryptoHash = new CryptoHash();
        public chunk_receipts_root: CryptoHash = new CryptoHash();
        public chunk_headers_root: CryptoHash = new CryptoHash();
        public chunk_tx_root: CryptoHash = new CryptoHash();
        public outcome_root: CryptoHash = new CryptoHash();
        public chunks_included: u64;
        public challenges_root: CryptoHash = new CryptoHash();
        public timestamp: u64;
        public timestamp_nanosec: u64;
        public random_value: CryptoHash = new CryptoHash();
        public validator_proposals: Array<ValidatorStake> =
          new Array<ValidatorStake>();
        public chunk_mask: Array<bool> = new Array<bool>();
        public gas_price: BigInt = new BigInt();
        public block_ordinal: u64;
        public total_supply: BigInt = new BigInt();
        public challenges_result: Array<SlashedValidator> =
          new Array<SlashedValidator>();
        public last_final_block_height: u64;
        public last_final_block: CryptoHash = new CryptoHash();
        public last_ds_final_block_height: u64;
        public last_ds_final_block: CryptoHash = new CryptoHash();
        public next_bp_hash: CryptoHash = new CryptoHash();
        public block_merkle_root: CryptoHash = new CryptoHash();
        public epoch_sync_data_hash: Array<u8> = new Array<u8>();
        public approvals: Array<Signature> = new Array<Signature>();
        public signature: Signature = new Signature();
        public latest_protocol_version: u32;

        // Decodes BlockHeader from an ArrayBuffer
        static decode(buf: ArrayBuffer): BlockHeader {
          return BlockHeader.decodeDataView(new DataView(buf));
        }

        // Decodes BlockHeader from a DataView
        static decodeDataView(view: DataView): BlockHeader {
          const decoder = new __proto.Decoder(view);
          const obj = new BlockHeader();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.height = decoder.uint64();
                break;
              }
              case 2: {
                obj.prev_height = decoder.uint64();
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.epoch_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.next_epoch_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.prev_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.prev_state_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.chunk_receipts_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 9: {
                const length = decoder.uint32();
                obj.chunk_headers_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.chunk_tx_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 11: {
                const length = decoder.uint32();
                obj.outcome_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 12: {
                obj.chunks_included = decoder.uint64();
                break;
              }
              case 13: {
                const length = decoder.uint32();
                obj.challenges_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 14: {
                obj.timestamp = decoder.uint64();
                break;
              }
              case 15: {
                obj.timestamp_nanosec = decoder.uint64();
                break;
              }
              case 16: {
                const length = decoder.uint32();
                obj.random_value = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 17: {
                const length = decoder.uint32();
                obj.validator_proposals.push(
                  ValidatorStake.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 18: {
                const endPos = decoder.pos + decoder.uint32();
                while (decoder.pos <= endPos) {
                  obj.chunk_mask.push(decoder.bool());
                }

                break;
              }
              case 19: {
                const length = decoder.uint32();
                obj.gas_price = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 20: {
                obj.block_ordinal = decoder.uint64();
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.total_supply = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.challenges_result.push(
                  SlashedValidator.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 23: {
                obj.last_final_block_height = decoder.uint64();
                break;
              }
              case 24: {
                const length = decoder.uint32();
                obj.last_final_block = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 25: {
                obj.last_ds_final_block_height = decoder.uint64();
                break;
              }
              case 26: {
                const length = decoder.uint32();
                obj.last_ds_final_block = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 27: {
                const length = decoder.uint32();
                obj.next_bp_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 28: {
                const length = decoder.uint32();
                obj.block_merkle_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 29: {
                obj.epoch_sync_data_hash = decoder.bytes();
                break;
              }
              case 30: {
                const length = decoder.uint32();
                obj.approvals.push(
                  Signature.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 31: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 32: {
                obj.latest_protocol_version = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode BlockHeader

        public size(): u32 {
          let size: u32 = 0;

          size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint64(this.height);
          size +=
            this.prev_height == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.prev_height);

          if (this.epoch_id != null) {
            const f: CryptoHash = this.epoch_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.next_epoch_id != null) {
            const f: CryptoHash = this.next_epoch_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.prev_hash != null) {
            const f: CryptoHash = this.prev_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.prev_state_root != null) {
            const f: CryptoHash = this.prev_state_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_receipts_root != null) {
            const f: CryptoHash = this.chunk_receipts_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_headers_root != null) {
            const f: CryptoHash = this.chunk_headers_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_tx_root != null) {
            const f: CryptoHash = this.chunk_tx_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome_root != null) {
            const f: CryptoHash = this.outcome_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.chunks_included == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.chunks_included);

          if (this.challenges_root != null) {
            const f: CryptoHash = this.challenges_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.timestamp == 0 ? 0 : 1 + __proto.Sizer.uint64(this.timestamp);
          size +=
            this.timestamp_nanosec == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.timestamp_nanosec);

          if (this.random_value != null) {
            const f: CryptoHash = this.random_value as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_mask.length > 0) {
            const packedSize = __size_bool_repeated_packed(this.chunk_mask);
            if (packedSize > 0) {
              size += 2 + __proto.Sizer.varint64(packedSize) + packedSize;
            }
          }

          if (this.gas_price != null) {
            const f: BigInt = this.gas_price as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.block_ordinal == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.block_ordinal);

          if (this.total_supply != null) {
            const f: BigInt = this.total_supply as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.challenges_result.length; n++) {
            const messageSize = this.challenges_result[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.last_final_block_height == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.last_final_block_height);

          if (this.last_final_block != null) {
            const f: CryptoHash = this.last_final_block as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.last_ds_final_block_height == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.last_ds_final_block_height);

          if (this.last_ds_final_block != null) {
            const f: CryptoHash = this.last_ds_final_block as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.next_bp_hash != null) {
            const f: CryptoHash = this.next_bp_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.block_merkle_root != null) {
            const f: CryptoHash = this.block_merkle_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.epoch_sync_data_hash.length > 0
              ? 2 +
                __proto.Sizer.varint64(this.epoch_sync_data_hash.length) +
                this.epoch_sync_data_hash.length
              : 0;

          for (let n: i32 = 0; n < this.approvals.length; n++) {
            const messageSize = this.approvals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.latest_protocol_version == 0
              ? 0
              : 2 + __proto.Sizer.uint32(this.latest_protocol_version);

          return size;
        }

        // Encodes BlockHeader to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes BlockHeader to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.height != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.height);
          }
          if (this.prev_height != 0) {
            encoder.uint32(0x10);
            encoder.uint64(this.prev_height);
          }

          if (this.epoch_id != null) {
            const f = this.epoch_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.next_epoch_id != null) {
            const f = this.next_epoch_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.prev_hash != null) {
            const f = this.prev_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.prev_state_root != null) {
            const f = this.prev_state_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_receipts_root != null) {
            const f = this.chunk_receipts_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_headers_root != null) {
            const f = this.chunk_headers_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x4a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_tx_root != null) {
            const f = this.chunk_tx_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome_root != null) {
            const f = this.outcome_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x5a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunks_included != 0) {
            encoder.uint32(0x60);
            encoder.uint64(this.chunks_included);
          }

          if (this.challenges_root != null) {
            const f = this.challenges_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x6a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.timestamp != 0) {
            encoder.uint32(0x70);
            encoder.uint64(this.timestamp);
          }
          if (this.timestamp_nanosec != 0) {
            encoder.uint32(0x78);
            encoder.uint64(this.timestamp_nanosec);
          }

          if (this.random_value != null) {
            const f = this.random_value as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x82);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x8a);
              encoder.uint32(messageSize);
              this.validator_proposals[n].encodeU8Array(encoder);
            }
          }

          if (this.chunk_mask.length > 0) {
            encoder.uint32(0x92);
            encoder.uint32(__size_bool_repeated_packed(this.chunk_mask));

            for (let n: i32 = 0; n < this.chunk_mask.length; n++) {
              encoder.bool(this.chunk_mask[n]);
            }
          }

          if (this.gas_price != null) {
            const f = this.gas_price as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x9a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_ordinal != 0) {
            encoder.uint32(0xa0);
            encoder.uint64(this.block_ordinal);
          }

          if (this.total_supply != null) {
            const f = this.total_supply as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.challenges_result.length; n++) {
            const messageSize = this.challenges_result[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              this.challenges_result[n].encodeU8Array(encoder);
            }
          }

          if (this.last_final_block_height != 0) {
            encoder.uint32(0xb8);
            encoder.uint64(this.last_final_block_height);
          }

          if (this.last_final_block != null) {
            const f = this.last_final_block as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xc2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.last_ds_final_block_height != 0) {
            encoder.uint32(0xc8);
            encoder.uint64(this.last_ds_final_block_height);
          }

          if (this.last_ds_final_block != null) {
            const f = this.last_ds_final_block as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xd2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.next_bp_hash != null) {
            const f = this.next_bp_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xda);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_merkle_root != null) {
            const f = this.block_merkle_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xe2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.epoch_sync_data_hash.length > 0) {
            encoder.uint32(0xea);
            encoder.uint32(this.epoch_sync_data_hash.length);
            encoder.bytes(this.epoch_sync_data_hash);
          }

          for (let n: i32 = 0; n < this.approvals.length; n++) {
            const messageSize = this.approvals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xf2);
              encoder.uint32(messageSize);
              this.approvals[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xfa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.latest_protocol_version != 0) {
            encoder.uint32(0x100);
            encoder.uint32(this.latest_protocol_version);
          }

          return buf;
        } // encode BlockHeader
      } // BlockHeader

      export class BigInt {
        public bytes: Array<u8> = new Array<u8>();

        // Decodes BigInt from an ArrayBuffer
        static decode(buf: ArrayBuffer): BigInt {
          return BigInt.decodeDataView(new DataView(buf));
        }

        // Decodes BigInt from a DataView
        static decodeDataView(view: DataView): BigInt {
          const decoder = new __proto.Decoder(view);
          const obj = new BigInt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode BigInt

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes BigInt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes BigInt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.bytes.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode BigInt
      } // BigInt

      export class CryptoHash {
        public bytes: Array<u8> = new Array<u8>();

        // Decodes CryptoHash from an ArrayBuffer
        static decode(buf: ArrayBuffer): CryptoHash {
          return CryptoHash.decodeDataView(new DataView(buf));
        }

        // Decodes CryptoHash from a DataView
        static decodeDataView(view: DataView): CryptoHash {
          const decoder = new __proto.Decoder(view);
          const obj = new CryptoHash();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CryptoHash

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes CryptoHash to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CryptoHash to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.bytes.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode CryptoHash
      } // CryptoHash

      export class Signature {
        public type: u32;
        public bytes: Array<u8> = new Array<u8>();

        // Decodes Signature from an ArrayBuffer
        static decode(buf: ArrayBuffer): Signature {
          return Signature.decodeDataView(new DataView(buf));
        }

        // Decodes Signature from a DataView
        static decodeDataView(view: DataView): Signature {
          const decoder = new __proto.Decoder(view);
          const obj = new Signature();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.type = decoder.uint32();
                break;
              }
              case 2: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Signature

        public size(): u32 {
          let size: u32 = 0;

          size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes Signature to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Signature to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.type != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.type);
          }
          if (this.bytes.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode Signature
      } // Signature

      export class PublicKey {
        public type: u32;
        public bytes: Array<u8> = new Array<u8>();

        // Decodes PublicKey from an ArrayBuffer
        static decode(buf: ArrayBuffer): PublicKey {
          return PublicKey.decodeDataView(new DataView(buf));
        }

        // Decodes PublicKey from a DataView
        static decodeDataView(view: DataView): PublicKey {
          const decoder = new __proto.Decoder(view);
          const obj = new PublicKey();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.type = decoder.uint32();
                break;
              }
              case 2: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode PublicKey

        public size(): u32 {
          let size: u32 = 0;

          size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes PublicKey to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes PublicKey to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.type != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.type);
          }
          if (this.bytes.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode PublicKey
      } // PublicKey

      export class ValidatorStake {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public stake: BigInt = new BigInt();

        // Decodes ValidatorStake from an ArrayBuffer
        static decode(buf: ArrayBuffer): ValidatorStake {
          return ValidatorStake.decodeDataView(new DataView(buf));
        }

        // Decodes ValidatorStake from a DataView
        static decodeDataView(view: DataView): ValidatorStake {
          const decoder = new __proto.Decoder(view);
          const obj = new ValidatorStake();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ValidatorStake

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ValidatorStake to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ValidatorStake to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ValidatorStake
      } // ValidatorStake

      export class SlashedValidator {
        public account_id: string = "";
        public is_double_sign: bool;

        // Decodes SlashedValidator from an ArrayBuffer
        static decode(buf: ArrayBuffer): SlashedValidator {
          return SlashedValidator.decodeDataView(new DataView(buf));
        }

        // Decodes SlashedValidator from a DataView
        static decodeDataView(view: DataView): SlashedValidator {
          const decoder = new __proto.Decoder(view);
          const obj = new SlashedValidator();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.is_double_sign = decoder.bool();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SlashedValidator

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size += this.is_double_sign == 0 ? 0 : 1 + 1;

          return size;
        }

        // Encodes SlashedValidator to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SlashedValidator to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.is_double_sign != 0) {
            encoder.uint32(0x10);
            encoder.bool(this.is_double_sign);
          }

          return buf;
        } // encode SlashedValidator
      } // SlashedValidator

      export class ChunkHeader {
        public chunk_hash: Array<u8> = new Array<u8>();
        public prev_block_hash: Array<u8> = new Array<u8>();
        public outcome_root: Array<u8> = new Array<u8>();
        public prev_state_root: Array<u8> = new Array<u8>();
        public encoded_merkle_root: Array<u8> = new Array<u8>();
        public encoded_length: u64;
        public height_created: u64;
        public height_included: u64;
        public shard_id: u64;
        public gas_used: u64;
        public gas_limit: u64;
        public validator_reward: BigInt = new BigInt();
        public balance_burnt: BigInt = new BigInt();
        public outgoing_receipts_root: Array<u8> = new Array<u8>();
        public tx_root: Array<u8> = new Array<u8>();
        public validator_proposals: Array<ValidatorStake> =
          new Array<ValidatorStake>();
        public signature: Signature = new Signature();

        // Decodes ChunkHeader from an ArrayBuffer
        static decode(buf: ArrayBuffer): ChunkHeader {
          return ChunkHeader.decodeDataView(new DataView(buf));
        }

        // Decodes ChunkHeader from a DataView
        static decodeDataView(view: DataView): ChunkHeader {
          const decoder = new __proto.Decoder(view);
          const obj = new ChunkHeader();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.chunk_hash = decoder.bytes();
                break;
              }
              case 2: {
                obj.prev_block_hash = decoder.bytes();
                break;
              }
              case 3: {
                obj.outcome_root = decoder.bytes();
                break;
              }
              case 4: {
                obj.prev_state_root = decoder.bytes();
                break;
              }
              case 5: {
                obj.encoded_merkle_root = decoder.bytes();
                break;
              }
              case 6: {
                obj.encoded_length = decoder.uint64();
                break;
              }
              case 7: {
                obj.height_created = decoder.uint64();
                break;
              }
              case 8: {
                obj.height_included = decoder.uint64();
                break;
              }
              case 9: {
                obj.shard_id = decoder.uint64();
                break;
              }
              case 10: {
                obj.gas_used = decoder.uint64();
                break;
              }
              case 11: {
                obj.gas_limit = decoder.uint64();
                break;
              }
              case 12: {
                const length = decoder.uint32();
                obj.validator_reward = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 13: {
                const length = decoder.uint32();
                obj.balance_burnt = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 14: {
                obj.outgoing_receipts_root = decoder.bytes();
                break;
              }
              case 15: {
                obj.tx_root = decoder.bytes();
                break;
              }
              case 16: {
                const length = decoder.uint32();
                obj.validator_proposals.push(
                  ValidatorStake.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 17: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ChunkHeader

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.chunk_hash.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.chunk_hash.length) +
                this.chunk_hash.length
              : 0;
          size +=
            this.prev_block_hash.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.prev_block_hash.length) +
                this.prev_block_hash.length
              : 0;
          size +=
            this.outcome_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.outcome_root.length) +
                this.outcome_root.length
              : 0;
          size +=
            this.prev_state_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.prev_state_root.length) +
                this.prev_state_root.length
              : 0;
          size +=
            this.encoded_merkle_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.encoded_merkle_root.length) +
                this.encoded_merkle_root.length
              : 0;
          size +=
            this.encoded_length == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.encoded_length);
          size +=
            this.height_created == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.height_created);
          size +=
            this.height_included == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.height_included);
          size +=
            this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);
          size +=
            this.gas_used == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_used);
          size +=
            this.gas_limit == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_limit);

          if (this.validator_reward != null) {
            const f: BigInt = this.validator_reward as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.balance_burnt != null) {
            const f: BigInt = this.balance_burnt as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.outgoing_receipts_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.outgoing_receipts_root.length) +
                this.outgoing_receipts_root.length
              : 0;
          size +=
            this.tx_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.tx_root.length) +
                this.tx_root.length
              : 0;

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ChunkHeader to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ChunkHeader to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.chunk_hash.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.chunk_hash.length);
            encoder.bytes(this.chunk_hash);
          }
          if (this.prev_block_hash.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.prev_block_hash.length);
            encoder.bytes(this.prev_block_hash);
          }
          if (this.outcome_root.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.outcome_root.length);
            encoder.bytes(this.outcome_root);
          }
          if (this.prev_state_root.length > 0) {
            encoder.uint32(0x22);
            encoder.uint32(this.prev_state_root.length);
            encoder.bytes(this.prev_state_root);
          }
          if (this.encoded_merkle_root.length > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(this.encoded_merkle_root.length);
            encoder.bytes(this.encoded_merkle_root);
          }
          if (this.encoded_length != 0) {
            encoder.uint32(0x30);
            encoder.uint64(this.encoded_length);
          }
          if (this.height_created != 0) {
            encoder.uint32(0x38);
            encoder.uint64(this.height_created);
          }
          if (this.height_included != 0) {
            encoder.uint32(0x40);
            encoder.uint64(this.height_included);
          }
          if (this.shard_id != 0) {
            encoder.uint32(0x48);
            encoder.uint64(this.shard_id);
          }
          if (this.gas_used != 0) {
            encoder.uint32(0x50);
            encoder.uint64(this.gas_used);
          }
          if (this.gas_limit != 0) {
            encoder.uint32(0x58);
            encoder.uint64(this.gas_limit);
          }

          if (this.validator_reward != null) {
            const f = this.validator_reward as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x62);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.balance_burnt != null) {
            const f = this.balance_burnt as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x6a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outgoing_receipts_root.length > 0) {
            encoder.uint32(0x72);
            encoder.uint32(this.outgoing_receipts_root.length);
            encoder.bytes(this.outgoing_receipts_root);
          }
          if (this.tx_root.length > 0) {
            encoder.uint32(0x7a);
            encoder.uint32(this.tx_root.length);
            encoder.bytes(this.tx_root);
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x82);
              encoder.uint32(messageSize);
              this.validator_proposals[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x8a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ChunkHeader
      } // ChunkHeader

      export class IndexerShard {
        public shard_id: u64;
        public chunk: IndexerChunk = new IndexerChunk();
        public receipt_execution_outcomes: Array<IndexerExecutionOutcomeWithReceipt> =
          new Array<IndexerExecutionOutcomeWithReceipt>();

        // Decodes IndexerShard from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerShard {
          return IndexerShard.decodeDataView(new DataView(buf));
        }

        // Decodes IndexerShard from a DataView
        static decodeDataView(view: DataView): IndexerShard {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerShard();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.shard_id = decoder.uint64();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.chunk = IndexerChunk.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.receipt_execution_outcomes.push(
                  IndexerExecutionOutcomeWithReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerShard

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);

          if (this.chunk != null) {
            const f: IndexerChunk = this.chunk as IndexerChunk;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (
            let n: i32 = 0;
            n < this.receipt_execution_outcomes.length;
            n++
          ) {
            const messageSize = this.receipt_execution_outcomes[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerShard to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerShard to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.shard_id != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.shard_id);
          }

          if (this.chunk != null) {
            const f = this.chunk as IndexerChunk;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (
            let n: i32 = 0;
            n < this.receipt_execution_outcomes.length;
            n++
          ) {
            const messageSize = this.receipt_execution_outcomes[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.receipt_execution_outcomes[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerShard
      } // IndexerShard

      export class IndexerExecutionOutcomeWithReceipt {
        public execution_outcome: ExecutionOutcomeWithId =
          new ExecutionOutcomeWithId();
        public receipt: Receipt = new Receipt();

        // Decodes IndexerExecutionOutcomeWithReceipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerExecutionOutcomeWithReceipt {
          return IndexerExecutionOutcomeWithReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerExecutionOutcomeWithReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): IndexerExecutionOutcomeWithReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerExecutionOutcomeWithReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt = Receipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerExecutionOutcomeWithReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.execution_outcome != null) {
            const f: ExecutionOutcomeWithId = this
              .execution_outcome as ExecutionOutcomeWithId;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt != null) {
            const f: Receipt = this.receipt as Receipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerExecutionOutcomeWithReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerExecutionOutcomeWithReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.execution_outcome != null) {
            const f = this.execution_outcome as ExecutionOutcomeWithId;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt != null) {
            const f = this.receipt as Receipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerExecutionOutcomeWithReceipt
      } // IndexerExecutionOutcomeWithReceipt

      export class IndexerChunk {
        public author: string = "";
        public header: ChunkHeader = new ChunkHeader();
        public transactions: Array<IndexerTransactionWithOutcome> =
          new Array<IndexerTransactionWithOutcome>();
        public receipts: Array<Receipt> = new Array<Receipt>();

        // Decodes IndexerChunk from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerChunk {
          return IndexerChunk.decodeDataView(new DataView(buf));
        }

        // Decodes IndexerChunk from a DataView
        static decodeDataView(view: DataView): IndexerChunk {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerChunk();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.author = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.header = ChunkHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.transactions.push(
                  IndexerTransactionWithOutcome.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.receipts.push(
                  Receipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerChunk

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.author.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.author.length) +
                this.author.length
              : 0;

          if (this.header != null) {
            const f: ChunkHeader = this.header as ChunkHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.transactions.length; n++) {
            const messageSize = this.transactions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.receipts.length; n++) {
            const messageSize = this.receipts[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerChunk to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerChunk to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.author.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.author.length);
            encoder.string(this.author);
          }

          if (this.header != null) {
            const f = this.header as ChunkHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.transactions.length; n++) {
            const messageSize = this.transactions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.transactions[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.receipts.length; n++) {
            const messageSize = this.receipts[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.receipts[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerChunk
      } // IndexerChunk

      export class IndexerTransactionWithOutcome {
        public transaction: SignedTransaction = new SignedTransaction();
        public outcome: IndexerExecutionOutcomeWithOptionalReceipt =
          new IndexerExecutionOutcomeWithOptionalReceipt();

        // Decodes IndexerTransactionWithOutcome from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerTransactionWithOutcome {
          return IndexerTransactionWithOutcome.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerTransactionWithOutcome from a DataView
        static decodeDataView(view: DataView): IndexerTransactionWithOutcome {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerTransactionWithOutcome();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.transaction = SignedTransaction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.outcome =
                  IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerTransactionWithOutcome

        public size(): u32 {
          let size: u32 = 0;

          if (this.transaction != null) {
            const f: SignedTransaction = this.transaction as SignedTransaction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome != null) {
            const f: IndexerExecutionOutcomeWithOptionalReceipt = this
              .outcome as IndexerExecutionOutcomeWithOptionalReceipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerTransactionWithOutcome to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerTransactionWithOutcome to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.transaction != null) {
            const f = this.transaction as SignedTransaction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome != null) {
            const f = this
              .outcome as IndexerExecutionOutcomeWithOptionalReceipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerTransactionWithOutcome
      } // IndexerTransactionWithOutcome

      export class SignedTransaction {
        public signer_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public nonce: u64;
        public receiver_id: string = "";
        public actions: Array<Action> = new Array<Action>();
        public signature: Signature = new Signature();
        public hash: CryptoHash = new CryptoHash();

        // Decodes SignedTransaction from an ArrayBuffer
        static decode(buf: ArrayBuffer): SignedTransaction {
          return SignedTransaction.decodeDataView(new DataView(buf));
        }

        // Decodes SignedTransaction from a DataView
        static decodeDataView(view: DataView): SignedTransaction {
          const decoder = new __proto.Decoder(view);
          const obj = new SignedTransaction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.signer_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                obj.nonce = decoder.uint64();
                break;
              }
              case 4: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.actions.push(
                  Action.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SignedTransaction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.signer_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.signer_id.length) +
                this.signer_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);
          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes SignedTransaction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SignedTransaction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.signer_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.signer_id.length);
            encoder.string(this.signer_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.nonce != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.nonce);
          }
          if (this.receiver_id.length > 0) {
            encoder.uint32(0x22);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.actions[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode SignedTransaction
      } // SignedTransaction

      export class IndexerExecutionOutcomeWithOptionalReceipt {
        public execution_outcome: ExecutionOutcomeWithId =
          new ExecutionOutcomeWithId();
        public receipt: Receipt = new Receipt();

        // Decodes IndexerExecutionOutcomeWithOptionalReceipt from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): IndexerExecutionOutcomeWithOptionalReceipt {
          return IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerExecutionOutcomeWithOptionalReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): IndexerExecutionOutcomeWithOptionalReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerExecutionOutcomeWithOptionalReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt = Receipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerExecutionOutcomeWithOptionalReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.execution_outcome != null) {
            const f: ExecutionOutcomeWithId = this
              .execution_outcome as ExecutionOutcomeWithId;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt != null) {
            const f: Receipt = this.receipt as Receipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.execution_outcome != null) {
            const f = this.execution_outcome as ExecutionOutcomeWithId;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt != null) {
            const f = this.receipt as Receipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerExecutionOutcomeWithOptionalReceipt
      } // IndexerExecutionOutcomeWithOptionalReceipt

      export class Receipt {
        public predecessor_id: string = "";
        public receiver_id: string = "";
        public receipt_id: CryptoHash = new CryptoHash();
        public action: ReceiptAction | null;
        public data: ReceiptData | null;

        public __receipt: string = "";
        public __receipt_index: u8 = 0;

        static readonly RECEIPT_ACTION_INDEX: u8 = 10;
        static readonly RECEIPT_DATA_INDEX: u8 = 11;

        // Decodes Receipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): Receipt {
          return Receipt.decodeDataView(new DataView(buf));
        }

        // Decodes Receipt from a DataView
        static decodeDataView(view: DataView): Receipt {
          const decoder = new __proto.Decoder(view);
          const obj = new Receipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.predecessor_id = decoder.string();
                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.receipt_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.action = ReceiptAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__receipt = "action";
                obj.__receipt_index = 10;
                break;
              }
              case 11: {
                const length = decoder.uint32();
                obj.data = ReceiptData.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__receipt = "data";
                obj.__receipt_index = 11;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Receipt

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;
          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          if (this.receipt_id != null) {
            const f: CryptoHash = this.receipt_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action != null) {
            const f: ReceiptAction = this.action as ReceiptAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data != null) {
            const f: ReceiptData = this.data as ReceiptData;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Receipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Receipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.predecessor_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }
          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          if (this.receipt_id != null) {
            const f = this.receipt_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action != null) {
            const f = this.action as ReceiptAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data != null) {
            const f = this.data as ReceiptData;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x5a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Receipt
      } // Receipt

      export class ReceiptData {
        public data_id: CryptoHash = new CryptoHash();
        public data: Array<u8> = new Array<u8>();

        // Decodes ReceiptData from an ArrayBuffer
        static decode(buf: ArrayBuffer): ReceiptData {
          return ReceiptData.decodeDataView(new DataView(buf));
        }

        // Decodes ReceiptData from a DataView
        static decodeDataView(view: DataView): ReceiptData {
          const decoder = new __proto.Decoder(view);
          const obj = new ReceiptData();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.data_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.data = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ReceiptData

        public size(): u32 {
          let size: u32 = 0;

          if (this.data_id != null) {
            const f: CryptoHash = this.data_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.data.length > 0
              ? 1 + __proto.Sizer.varint64(this.data.length) + this.data.length
              : 0;

          return size;
        }

        // Encodes ReceiptData to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ReceiptData to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.data_id != null) {
            const f = this.data_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.data.length);
            encoder.bytes(this.data);
          }

          return buf;
        } // encode ReceiptData
      } // ReceiptData

      export class ReceiptAction {
        public signer_id: string = "";
        public signer_public_key: PublicKey = new PublicKey();
        public gas_price: BigInt = new BigInt();
        public output_data_receivers: Array<DataReceiver> =
          new Array<DataReceiver>();
        public input_data_ids: Array<CryptoHash> = new Array<CryptoHash>();
        public actions: Array<Action> = new Array<Action>();

        // Decodes ReceiptAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): ReceiptAction {
          return ReceiptAction.decodeDataView(new DataView(buf));
        }

        // Decodes ReceiptAction from a DataView
        static decodeDataView(view: DataView): ReceiptAction {
          const decoder = new __proto.Decoder(view);
          const obj = new ReceiptAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.signer_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.signer_public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.gas_price = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.output_data_receivers.push(
                  DataReceiver.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.input_data_ids.push(
                  CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.actions.push(
                  Action.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ReceiptAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.signer_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.signer_id.length) +
                this.signer_id.length
              : 0;

          if (this.signer_public_key != null) {
            const f: PublicKey = this.signer_public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.gas_price != null) {
            const f: BigInt = this.gas_price as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
            const messageSize = this.output_data_receivers[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
            const messageSize = this.input_data_ids[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ReceiptAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ReceiptAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.signer_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.signer_id.length);
            encoder.string(this.signer_id);
          }

          if (this.signer_public_key != null) {
            const f = this.signer_public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.gas_price != null) {
            const f = this.gas_price as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
            const messageSize = this.output_data_receivers[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.output_data_receivers[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
            const messageSize = this.input_data_ids[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.input_data_ids[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              this.actions[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ReceiptAction
      } // ReceiptAction

      export class DataReceiver {
        public data_id: CryptoHash = new CryptoHash();
        public receiver_id: string = "";

        // Decodes DataReceiver from an ArrayBuffer
        static decode(buf: ArrayBuffer): DataReceiver {
          return DataReceiver.decodeDataView(new DataView(buf));
        }

        // Decodes DataReceiver from a DataView
        static decodeDataView(view: DataView): DataReceiver {
          const decoder = new __proto.Decoder(view);
          const obj = new DataReceiver();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.data_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DataReceiver

        public size(): u32 {
          let size: u32 = 0;

          if (this.data_id != null) {
            const f: CryptoHash = this.data_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          return size;
        }

        // Encodes DataReceiver to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DataReceiver to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.data_id != null) {
            const f = this.data_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          return buf;
        } // encode DataReceiver
      } // DataReceiver

      export class ExecutionOutcomeWithId {
        public proof: MerklePath = new MerklePath();
        public block_hash: CryptoHash = new CryptoHash();
        public id: CryptoHash = new CryptoHash();
        public outcome: ExecutionOutcome = new ExecutionOutcome();

        // Decodes ExecutionOutcomeWithId from an ArrayBuffer
        static decode(buf: ArrayBuffer): ExecutionOutcomeWithId {
          return ExecutionOutcomeWithId.decodeDataView(new DataView(buf));
        }

        // Decodes ExecutionOutcomeWithId from a DataView
        static decodeDataView(view: DataView): ExecutionOutcomeWithId {
          const decoder = new __proto.Decoder(view);
          const obj = new ExecutionOutcomeWithId();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.proof = MerklePath.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.block_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.outcome = ExecutionOutcome.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ExecutionOutcomeWithId

        public size(): u32 {
          let size: u32 = 0;

          if (this.proof != null) {
            const f: MerklePath = this.proof as MerklePath;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.block_hash != null) {
            const f: CryptoHash = this.block_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.id != null) {
            const f: CryptoHash = this.id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome != null) {
            const f: ExecutionOutcome = this.outcome as ExecutionOutcome;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ExecutionOutcomeWithId to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ExecutionOutcomeWithId to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.proof != null) {
            const f = this.proof as MerklePath;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_hash != null) {
            const f = this.block_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.id != null) {
            const f = this.id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome != null) {
            const f = this.outcome as ExecutionOutcome;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ExecutionOutcomeWithId
      } // ExecutionOutcomeWithId

      export class ExecutionOutcome {
        public logs: Array<string> = new Array<string>();
        public receipt_ids: Array<CryptoHash> = new Array<CryptoHash>();
        public gas_burnt: u64;
        public tokens_burnt: BigInt = new BigInt();
        public executor_id: string = "";
        public unknown: UnknownExecutionStatus | null;
        public failure: FailureExecutionStatus | null;
        public success_value: SuccessValueExecutionStatus | null;
        public success_receipt_id: SuccessReceiptIdExecutionStatus | null;
        public metadata: u32;

        public __status: string = "";
        public __status_index: u8 = 0;

        static readonly STATUS_UNKNOWN_INDEX: u8 = 20;
        static readonly STATUS_FAILURE_INDEX: u8 = 21;
        static readonly STATUS_SUCCESS_VALUE_INDEX: u8 = 22;
        static readonly STATUS_SUCCESS_RECEIPT_ID_INDEX: u8 = 23;

        // Decodes ExecutionOutcome from an ArrayBuffer
        static decode(buf: ArrayBuffer): ExecutionOutcome {
          return ExecutionOutcome.decodeDataView(new DataView(buf));
        }

        // Decodes ExecutionOutcome from a DataView
        static decodeDataView(view: DataView): ExecutionOutcome {
          const decoder = new __proto.Decoder(view);
          const obj = new ExecutionOutcome();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.logs.push(decoder.string());
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt_ids.push(
                  CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                obj.gas_burnt = decoder.uint64();
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.tokens_burnt = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                obj.executor_id = decoder.string();
                break;
              }
              case 20: {
                const length = decoder.uint32();
                obj.unknown = UnknownExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "unknown";
                obj.__status_index = 20;
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.failure = FailureExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "failure";
                obj.__status_index = 21;
                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.success_value = SuccessValueExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "success_value";
                obj.__status_index = 22;
                break;
              }
              case 23: {
                const length = decoder.uint32();
                obj.success_receipt_id =
                  SuccessReceiptIdExecutionStatus.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__status = "success_receipt_id";
                obj.__status_index = 23;
                break;
              }
              case 6: {
                obj.metadata = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ExecutionOutcome

        public size(): u32 {
          let size: u32 = 0;

          size += __size_string_repeated(this.logs);

          for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
            const messageSize = this.receipt_ids[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.gas_burnt == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_burnt);

          if (this.tokens_burnt != null) {
            const f: BigInt = this.tokens_burnt as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.executor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.executor_id.length) +
                this.executor_id.length
              : 0;

          if (this.unknown != null) {
            const f: UnknownExecutionStatus = this
              .unknown as UnknownExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.failure != null) {
            const f: FailureExecutionStatus = this
              .failure as FailureExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.success_value != null) {
            const f: SuccessValueExecutionStatus = this
              .success_value as SuccessValueExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.success_receipt_id != null) {
            const f: SuccessReceiptIdExecutionStatus = this
              .success_receipt_id as SuccessReceiptIdExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.metadata == 0 ? 0 : 1 + __proto.Sizer.uint32(this.metadata);

          return size;
        }

        // Encodes ExecutionOutcome to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ExecutionOutcome to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.logs.length > 0) {
            for (let n: i32 = 0; n < this.logs.length; n++) {
              encoder.uint32(0xa);
              encoder.uint32(this.logs[n].length);
              encoder.string(this.logs[n]);
            }
          }

          for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
            const messageSize = this.receipt_ids[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              this.receipt_ids[n].encodeU8Array(encoder);
            }
          }

          if (this.gas_burnt != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.gas_burnt);
          }

          if (this.tokens_burnt != null) {
            const f = this.tokens_burnt as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.executor_id.length > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(this.executor_id.length);
            encoder.string(this.executor_id);
          }

          if (this.unknown != null) {
            const f = this.unknown as UnknownExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.failure != null) {
            const f = this.failure as FailureExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.success_value != null) {
            const f = this.success_value as SuccessValueExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.success_receipt_id != null) {
            const f = this
              .success_receipt_id as SuccessReceiptIdExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xba);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.metadata != 0) {
            encoder.uint32(0x30);
            encoder.uint32(this.metadata);
          }

          return buf;
        } // encode ExecutionOutcome
      } // ExecutionOutcome

      export class SuccessValueExecutionStatus {
        public value: Array<u8> = new Array<u8>();

        // Decodes SuccessValueExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): SuccessValueExecutionStatus {
          return SuccessValueExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes SuccessValueExecutionStatus from a DataView
        static decodeDataView(view: DataView): SuccessValueExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new SuccessValueExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.value = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SuccessValueExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.value.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.value.length) +
                this.value.length
              : 0;

          return size;
        }

        // Encodes SuccessValueExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SuccessValueExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.value.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.value.length);
            encoder.bytes(this.value);
          }

          return buf;
        } // encode SuccessValueExecutionStatus
      } // SuccessValueExecutionStatus

      export class SuccessReceiptIdExecutionStatus {
        public id: CryptoHash = new CryptoHash();

        // Decodes SuccessReceiptIdExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): SuccessReceiptIdExecutionStatus {
          return SuccessReceiptIdExecutionStatus.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes SuccessReceiptIdExecutionStatus from a DataView
        static decodeDataView(view: DataView): SuccessReceiptIdExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new SuccessReceiptIdExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SuccessReceiptIdExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          if (this.id != null) {
            const f: CryptoHash = this.id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes SuccessReceiptIdExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SuccessReceiptIdExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.id != null) {
            const f = this.id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode SuccessReceiptIdExecutionStatus
      } // SuccessReceiptIdExecutionStatus

      export class UnknownExecutionStatus {
        // Decodes UnknownExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): UnknownExecutionStatus {
          return UnknownExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes UnknownExecutionStatus from a DataView
        static decodeDataView(view: DataView): UnknownExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new UnknownExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode UnknownExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes UnknownExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes UnknownExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode UnknownExecutionStatus
      } // UnknownExecutionStatus

      export class FailureExecutionStatus {
        public action_error: ActionError | null;
        public invalid_tx_error: u32;

        public __failure: string = "";
        public __failure_index: u8 = 0;

        static readonly FAILURE_ACTION_ERROR_INDEX: u8 = 1;
        static readonly FAILURE_INVALID_TX_ERROR_INDEX: u8 = 2;

        // Decodes FailureExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): FailureExecutionStatus {
          return FailureExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes FailureExecutionStatus from a DataView
        static decodeDataView(view: DataView): FailureExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new FailureExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.action_error = ActionError.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__failure = "action_error";
                obj.__failure_index = 1;
                break;
              }
              case 2: {
                obj.invalid_tx_error = decoder.uint32();
                obj.__failure = "invalid_tx_error";
                obj.__failure_index = 2;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FailureExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          if (this.action_error != null) {
            const f: ActionError = this.action_error as ActionError;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.invalid_tx_error == 0
              ? 0
              : 1 + __proto.Sizer.uint32(this.invalid_tx_error);

          return size;
        }

        // Encodes FailureExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FailureExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.action_error != null) {
            const f = this.action_error as ActionError;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.invalid_tx_error != 0) {
            encoder.uint32(0x10);
            encoder.uint32(this.invalid_tx_error);
          }

          return buf;
        } // encode FailureExecutionStatus
      } // FailureExecutionStatus

      export class ActionError {
        public index: u64;
        public account_already_exist: AccountAlreadyExistsErrorKind | null;
        public account_does_not_exist: AccountDoesNotExistErrorKind | null;
        public create_account_only_by_registrar: CreateAccountOnlyByRegistrarErrorKind | null;
        public create_account_not_allowed: CreateAccountNotAllowedErrorKind | null;
        public actor_no_permission: ActorNoPermissionErrorKind | null;
        public delete_key_does_not_exist: DeleteKeyDoesNotExistErrorKind | null;
        public add_key_already_exists: AddKeyAlreadyExistsErrorKind | null;
        public delete_account_staking: DeleteAccountStakingErrorKind | null;
        public lack_balance_for_state: LackBalanceForStateErrorKind | null;
        public tries_to_unstake: TriesToUnstakeErrorKind | null;
        public tries_to_stake: TriesToStakeErrorKind | null;
        public insufficient_stake: InsufficientStakeErrorKind | null;
        public function_call: FunctionCallErrorKind | null;
        public new_receipt_validation: NewReceiptValidationErrorKind | null;
        public only_implicit_account_creation_allowed: OnlyImplicitAccountCreationAllowedErrorKind | null;
        public delete_account_with_large_state: DeleteAccountWithLargeStateErrorKind | null;

        public __kind: string = "";
        public __kind_index: u8 = 0;

        static readonly KIND_ACCOUNT_ALREADY_EXIST_INDEX: u8 = 21;
        static readonly KIND_ACCOUNT_DOES_NOT_EXIST_INDEX: u8 = 22;
        static readonly KIND_CREATE_ACCOUNT_ONLY_BY_REGISTRAR_INDEX: u8 = 23;
        static readonly KIND_CREATE_ACCOUNT_NOT_ALLOWED_INDEX: u8 = 24;
        static readonly KIND_ACTOR_NO_PERMISSION_INDEX: u8 = 25;
        static readonly KIND_DELETE_KEY_DOES_NOT_EXIST_INDEX: u8 = 26;
        static readonly KIND_ADD_KEY_ALREADY_EXISTS_INDEX: u8 = 27;
        static readonly KIND_DELETE_ACCOUNT_STAKING_INDEX: u8 = 28;
        static readonly KIND_LACK_BALANCE_FOR_STATE_INDEX: u8 = 29;
        static readonly KIND_TRIES_TO_UNSTAKE_INDEX: u8 = 30;
        static readonly KIND_TRIES_TO_STAKE_INDEX: u8 = 31;
        static readonly KIND_INSUFFICIENT_STAKE_INDEX: u8 = 32;
        static readonly KIND_FUNCTION_CALL_INDEX: u8 = 33;
        static readonly KIND_NEW_RECEIPT_VALIDATION_INDEX: u8 = 34;
        static readonly KIND_ONLY_IMPLICIT_ACCOUNT_CREATION_ALLOWED_INDEX: u8 = 35;
        static readonly KIND_DELETE_ACCOUNT_WITH_LARGE_STATE_INDEX: u8 = 36;

        // Decodes ActionError from an ArrayBuffer
        static decode(buf: ArrayBuffer): ActionError {
          return ActionError.decodeDataView(new DataView(buf));
        }

        // Decodes ActionError from a DataView
        static decodeDataView(view: DataView): ActionError {
          const decoder = new __proto.Decoder(view);
          const obj = new ActionError();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.index = decoder.uint64();
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.account_already_exist =
                  AccountAlreadyExistsErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "account_already_exist";
                obj.__kind_index = 21;
                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.account_does_not_exist =
                  AccountDoesNotExistErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "account_does_not_exist";
                obj.__kind_index = 22;
                break;
              }
              case 23: {
                const length = decoder.uint32();
                obj.create_account_only_by_registrar =
                  CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "create_account_only_by_registrar";
                obj.__kind_index = 23;
                break;
              }
              case 24: {
                const length = decoder.uint32();
                obj.create_account_not_allowed =
                  CreateAccountNotAllowedErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "create_account_not_allowed";
                obj.__kind_index = 24;
                break;
              }
              case 25: {
                const length = decoder.uint32();
                obj.actor_no_permission =
                  ActorNoPermissionErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "actor_no_permission";
                obj.__kind_index = 25;
                break;
              }
              case 26: {
                const length = decoder.uint32();
                obj.delete_key_does_not_exist =
                  DeleteKeyDoesNotExistErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_key_does_not_exist";
                obj.__kind_index = 26;
                break;
              }
              case 27: {
                const length = decoder.uint32();
                obj.add_key_already_exists =
                  AddKeyAlreadyExistsErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "add_key_already_exists";
                obj.__kind_index = 27;
                break;
              }
              case 28: {
                const length = decoder.uint32();
                obj.delete_account_staking =
                  DeleteAccountStakingErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_account_staking";
                obj.__kind_index = 28;
                break;
              }
              case 29: {
                const length = decoder.uint32();
                obj.lack_balance_for_state =
                  LackBalanceForStateErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "lack_balance_for_state";
                obj.__kind_index = 29;
                break;
              }
              case 30: {
                const length = decoder.uint32();
                obj.tries_to_unstake = TriesToUnstakeErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "tries_to_unstake";
                obj.__kind_index = 30;
                break;
              }
              case 31: {
                const length = decoder.uint32();
                obj.tries_to_stake = TriesToStakeErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "tries_to_stake";
                obj.__kind_index = 31;
                break;
              }
              case 32: {
                const length = decoder.uint32();
                obj.insufficient_stake =
                  InsufficientStakeErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "insufficient_stake";
                obj.__kind_index = 32;
                break;
              }
              case 33: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "function_call";
                obj.__kind_index = 33;
                break;
              }
              case 34: {
                const length = decoder.uint32();
                obj.new_receipt_validation =
                  NewReceiptValidationErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "new_receipt_validation";
                obj.__kind_index = 34;
                break;
              }
              case 35: {
                const length = decoder.uint32();
                obj.only_implicit_account_creation_allowed =
                  OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "only_implicit_account_creation_allowed";
                obj.__kind_index = 35;
                break;
              }
              case 36: {
                const length = decoder.uint32();
                obj.delete_account_with_large_state =
                  DeleteAccountWithLargeStateErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_account_with_large_state";
                obj.__kind_index = 36;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ActionError

        public size(): u32 {
          let size: u32 = 0;

          size += this.index == 0 ? 0 : 1 + __proto.Sizer.uint64(this.index);

          if (this.account_already_exist != null) {
            const f: AccountAlreadyExistsErrorKind = this
              .account_already_exist as AccountAlreadyExistsErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.account_does_not_exist != null) {
            const f: AccountDoesNotExistErrorKind = this
              .account_does_not_exist as AccountDoesNotExistErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.create_account_only_by_registrar != null) {
            const f: CreateAccountOnlyByRegistrarErrorKind = this
              .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.create_account_not_allowed != null) {
            const f: CreateAccountNotAllowedErrorKind = this
              .create_account_not_allowed as CreateAccountNotAllowedErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.actor_no_permission != null) {
            const f: ActorNoPermissionErrorKind = this
              .actor_no_permission as ActorNoPermissionErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_key_does_not_exist != null) {
            const f: DeleteKeyDoesNotExistErrorKind = this
              .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.add_key_already_exists != null) {
            const f: AddKeyAlreadyExistsErrorKind = this
              .add_key_already_exists as AddKeyAlreadyExistsErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account_staking != null) {
            const f: DeleteAccountStakingErrorKind = this
              .delete_account_staking as DeleteAccountStakingErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.lack_balance_for_state != null) {
            const f: LackBalanceForStateErrorKind = this
              .lack_balance_for_state as LackBalanceForStateErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.tries_to_unstake != null) {
            const f: TriesToUnstakeErrorKind = this
              .tries_to_unstake as TriesToUnstakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.tries_to_stake != null) {
            const f: TriesToStakeErrorKind = this
              .tries_to_stake as TriesToStakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.insufficient_stake != null) {
            const f: InsufficientStakeErrorKind = this
              .insufficient_stake as InsufficientStakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.function_call != null) {
            const f: FunctionCallErrorKind = this
              .function_call as FunctionCallErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.new_receipt_validation != null) {
            const f: NewReceiptValidationErrorKind = this
              .new_receipt_validation as NewReceiptValidationErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.only_implicit_account_creation_allowed != null) {
            const f: OnlyImplicitAccountCreationAllowedErrorKind = this
              .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account_with_large_state != null) {
            const f: DeleteAccountWithLargeStateErrorKind = this
              .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ActionError to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ActionError to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.index != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.index);
          }

          if (this.account_already_exist != null) {
            const f = this
              .account_already_exist as AccountAlreadyExistsErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.account_does_not_exist != null) {
            const f = this
              .account_does_not_exist as AccountDoesNotExistErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.create_account_only_by_registrar != null) {
            const f = this
              .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xba);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.create_account_not_allowed != null) {
            const f = this
              .create_account_not_allowed as CreateAccountNotAllowedErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xc2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.actor_no_permission != null) {
            const f = this.actor_no_permission as ActorNoPermissionErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xca);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_key_does_not_exist != null) {
            const f = this
              .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xd2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.add_key_already_exists != null) {
            const f = this
              .add_key_already_exists as AddKeyAlreadyExistsErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xda);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account_staking != null) {
            const f = this
              .delete_account_staking as DeleteAccountStakingErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xe2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.lack_balance_for_state != null) {
            const f = this
              .lack_balance_for_state as LackBalanceForStateErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xea);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.tries_to_unstake != null) {
            const f = this.tries_to_unstake as TriesToUnstakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xf2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.tries_to_stake != null) {
            const f = this.tries_to_stake as TriesToStakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xfa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.insufficient_stake != null) {
            const f = this.insufficient_stake as InsufficientStakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x102);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x10a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.new_receipt_validation != null) {
            const f = this
              .new_receipt_validation as NewReceiptValidationErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x112);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.only_implicit_account_creation_allowed != null) {
            const f = this
              .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x11a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account_with_large_state != null) {
            const f = this
              .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x122);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ActionError
      } // ActionError

      export class AccountAlreadyExistsErrorKind {
        public account_id: string = "";

        // Decodes AccountAlreadyExistsErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccountAlreadyExistsErrorKind {
          return AccountAlreadyExistsErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes AccountAlreadyExistsErrorKind from a DataView
        static decodeDataView(view: DataView): AccountAlreadyExistsErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AccountAlreadyExistsErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccountAlreadyExistsErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes AccountAlreadyExistsErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccountAlreadyExistsErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode AccountAlreadyExistsErrorKind
      } // AccountAlreadyExistsErrorKind

      export class AccountDoesNotExistErrorKind {
        public account_id: string = "";

        // Decodes AccountDoesNotExistErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccountDoesNotExistErrorKind {
          return AccountDoesNotExistErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes AccountDoesNotExistErrorKind from a DataView
        static decodeDataView(view: DataView): AccountDoesNotExistErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AccountDoesNotExistErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccountDoesNotExistErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes AccountDoesNotExistErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccountDoesNotExistErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode AccountDoesNotExistErrorKind
      } // AccountDoesNotExistErrorKind

      // / A top-level account ID can only be created by registrar.
      export class CreateAccountOnlyByRegistrarErrorKind {
        public account_id: string = "";
        public registrar_account_id: string = "";
        public predecessor_id: string = "";

        // Decodes CreateAccountOnlyByRegistrarErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountOnlyByRegistrarErrorKind {
          return CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes CreateAccountOnlyByRegistrarErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): CreateAccountOnlyByRegistrarErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountOnlyByRegistrarErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.registrar_account_id = decoder.string();
                break;
              }
              case 3: {
                obj.predecessor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountOnlyByRegistrarErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.registrar_account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.registrar_account_id.length) +
                this.registrar_account_id.length
              : 0;
          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;

          return size;
        }

        // Encodes CreateAccountOnlyByRegistrarErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountOnlyByRegistrarErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.registrar_account_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.registrar_account_id.length);
            encoder.string(this.registrar_account_id);
          }
          if (this.predecessor_id.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }

          return buf;
        } // encode CreateAccountOnlyByRegistrarErrorKind
      } // CreateAccountOnlyByRegistrarErrorKind

      export class CreateAccountNotAllowedErrorKind {
        public account_id: string = "";
        public predecessor_id: string = "";

        // Decodes CreateAccountNotAllowedErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountNotAllowedErrorKind {
          return CreateAccountNotAllowedErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes CreateAccountNotAllowedErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): CreateAccountNotAllowedErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountNotAllowedErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.predecessor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountNotAllowedErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;

          return size;
        }

        // Encodes CreateAccountNotAllowedErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountNotAllowedErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.predecessor_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }

          return buf;
        } // encode CreateAccountNotAllowedErrorKind
      } // CreateAccountNotAllowedErrorKind

      export class ActorNoPermissionErrorKind {
        public account_id: string = "";
        public actor_id: string = "";

        // Decodes ActorNoPermissionErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): ActorNoPermissionErrorKind {
          return ActorNoPermissionErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes ActorNoPermissionErrorKind from a DataView
        static decodeDataView(view: DataView): ActorNoPermissionErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new ActorNoPermissionErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.actor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ActorNoPermissionErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.actor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.actor_id.length) +
                this.actor_id.length
              : 0;

          return size;
        }

        // Encodes ActorNoPermissionErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ActorNoPermissionErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.actor_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.actor_id.length);
            encoder.string(this.actor_id);
          }

          return buf;
        } // encode ActorNoPermissionErrorKind
      } // ActorNoPermissionErrorKind

      export class DeleteKeyDoesNotExistErrorKind {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes DeleteKeyDoesNotExistErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteKeyDoesNotExistErrorKind {
          return DeleteKeyDoesNotExistErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteKeyDoesNotExistErrorKind from a DataView
        static decodeDataView(view: DataView): DeleteKeyDoesNotExistErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteKeyDoesNotExistErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteKeyDoesNotExistErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes DeleteKeyDoesNotExistErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteKeyDoesNotExistErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode DeleteKeyDoesNotExistErrorKind
      } // DeleteKeyDoesNotExistErrorKind

      export class AddKeyAlreadyExistsErrorKind {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes AddKeyAlreadyExistsErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AddKeyAlreadyExistsErrorKind {
          return AddKeyAlreadyExistsErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes AddKeyAlreadyExistsErrorKind from a DataView
        static decodeDataView(view: DataView): AddKeyAlreadyExistsErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AddKeyAlreadyExistsErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AddKeyAlreadyExistsErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AddKeyAlreadyExistsErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AddKeyAlreadyExistsErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AddKeyAlreadyExistsErrorKind
      } // AddKeyAlreadyExistsErrorKind

      export class DeleteAccountStakingErrorKind {
        public account_id: string = "";

        // Decodes DeleteAccountStakingErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountStakingErrorKind {
          return DeleteAccountStakingErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteAccountStakingErrorKind from a DataView
        static decodeDataView(view: DataView): DeleteAccountStakingErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountStakingErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountStakingErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountStakingErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountStakingErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode DeleteAccountStakingErrorKind
      } // DeleteAccountStakingErrorKind

      export class LackBalanceForStateErrorKind {
        public account_id: string = "";
        public balance: BigInt = new BigInt();

        // Decodes LackBalanceForStateErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): LackBalanceForStateErrorKind {
          return LackBalanceForStateErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes LackBalanceForStateErrorKind from a DataView
        static decodeDataView(view: DataView): LackBalanceForStateErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new LackBalanceForStateErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.balance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode LackBalanceForStateErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.balance != null) {
            const f: BigInt = this.balance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes LackBalanceForStateErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes LackBalanceForStateErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.balance != null) {
            const f = this.balance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode LackBalanceForStateErrorKind
      } // LackBalanceForStateErrorKind

      export class TriesToUnstakeErrorKind {
        public account_id: string = "";

        // Decodes TriesToUnstakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): TriesToUnstakeErrorKind {
          return TriesToUnstakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes TriesToUnstakeErrorKind from a DataView
        static decodeDataView(view: DataView): TriesToUnstakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new TriesToUnstakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TriesToUnstakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes TriesToUnstakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TriesToUnstakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode TriesToUnstakeErrorKind
      } // TriesToUnstakeErrorKind

      export class TriesToStakeErrorKind {
        public account_id: string = "";
        public stake: BigInt = new BigInt();
        public locked: BigInt = new BigInt();
        public balance: BigInt = new BigInt();

        // Decodes TriesToStakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): TriesToStakeErrorKind {
          return TriesToStakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes TriesToStakeErrorKind from a DataView
        static decodeDataView(view: DataView): TriesToStakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new TriesToStakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.locked = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.balance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TriesToStakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.locked != null) {
            const f: BigInt = this.locked as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.balance != null) {
            const f: BigInt = this.balance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes TriesToStakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TriesToStakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.locked != null) {
            const f = this.locked as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.balance != null) {
            const f = this.balance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode TriesToStakeErrorKind
      } // TriesToStakeErrorKind

      export class InsufficientStakeErrorKind {
        public account_id: string = "";
        public stake: BigInt = new BigInt();
        public minimum_stake: BigInt = new BigInt();

        // Decodes InsufficientStakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): InsufficientStakeErrorKind {
          return InsufficientStakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes InsufficientStakeErrorKind from a DataView
        static decodeDataView(view: DataView): InsufficientStakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new InsufficientStakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.minimum_stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode InsufficientStakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.minimum_stake != null) {
            const f: BigInt = this.minimum_stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes InsufficientStakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes InsufficientStakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.minimum_stake != null) {
            const f = this.minimum_stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode InsufficientStakeErrorKind
      } // InsufficientStakeErrorKind

      export class FunctionCallErrorKind {
        public error: u32;

        // Decodes FunctionCallErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallErrorKind {
          return FunctionCallErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallErrorKind from a DataView
        static decodeDataView(view: DataView): FunctionCallErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.error = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

          return size;
        }

        // Encodes FunctionCallErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.error != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.error);
          }

          return buf;
        } // encode FunctionCallErrorKind
      } // FunctionCallErrorKind

      export class NewReceiptValidationErrorKind {
        public error: u32;

        // Decodes NewReceiptValidationErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): NewReceiptValidationErrorKind {
          return NewReceiptValidationErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes NewReceiptValidationErrorKind from a DataView
        static decodeDataView(view: DataView): NewReceiptValidationErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new NewReceiptValidationErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.error = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode NewReceiptValidationErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

          return size;
        }

        // Encodes NewReceiptValidationErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes NewReceiptValidationErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.error != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.error);
          }

          return buf;
        } // encode NewReceiptValidationErrorKind
      } // NewReceiptValidationErrorKind

      export class OnlyImplicitAccountCreationAllowedErrorKind {
        public account_id: string = "";

        // Decodes OnlyImplicitAccountCreationAllowedErrorKind from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): OnlyImplicitAccountCreationAllowedErrorKind {
          return OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes OnlyImplicitAccountCreationAllowedErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): OnlyImplicitAccountCreationAllowedErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new OnlyImplicitAccountCreationAllowedErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode OnlyImplicitAccountCreationAllowedErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode OnlyImplicitAccountCreationAllowedErrorKind
      } // OnlyImplicitAccountCreationAllowedErrorKind

      export class DeleteAccountWithLargeStateErrorKind {
        public account_id: string = "";

        // Decodes DeleteAccountWithLargeStateErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountWithLargeStateErrorKind {
          return DeleteAccountWithLargeStateErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteAccountWithLargeStateErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): DeleteAccountWithLargeStateErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountWithLargeStateErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountWithLargeStateErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountWithLargeStateErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountWithLargeStateErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode DeleteAccountWithLargeStateErrorKind
      } // DeleteAccountWithLargeStateErrorKind

      export class MerklePath {
        public path: Array<MerklePathItem> = new Array<MerklePathItem>();

        // Decodes MerklePath from an ArrayBuffer
        static decode(buf: ArrayBuffer): MerklePath {
          return MerklePath.decodeDataView(new DataView(buf));
        }

        // Decodes MerklePath from a DataView
        static decodeDataView(view: DataView): MerklePath {
          const decoder = new __proto.Decoder(view);
          const obj = new MerklePath();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.path.push(
                  MerklePathItem.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode MerklePath

        public size(): u32 {
          let size: u32 = 0;

          for (let n: i32 = 0; n < this.path.length; n++) {
            const messageSize = this.path[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes MerklePath to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes MerklePath to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          for (let n: i32 = 0; n < this.path.length; n++) {
            const messageSize = this.path[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              this.path[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode MerklePath
      } // MerklePath

      export class MerklePathItem {
        public hash: CryptoHash = new CryptoHash();
        public direction: u32;

        // Decodes MerklePathItem from an ArrayBuffer
        static decode(buf: ArrayBuffer): MerklePathItem {
          return MerklePathItem.decodeDataView(new DataView(buf));
        }

        // Decodes MerklePathItem from a DataView
        static decodeDataView(view: DataView): MerklePathItem {
          const decoder = new __proto.Decoder(view);
          const obj = new MerklePathItem();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.direction = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode MerklePathItem

        public size(): u32 {
          let size: u32 = 0;

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.direction == 0 ? 0 : 1 + __proto.Sizer.uint32(this.direction);

          return size;
        }

        // Encodes MerklePathItem to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes MerklePathItem to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.direction != 0) {
            encoder.uint32(0x10);
            encoder.uint32(this.direction);
          }

          return buf;
        } // encode MerklePathItem
      } // MerklePathItem

      export class Action {
        public create_account: CreateAccountAction | null;
        public deploy_contract: DeployContractAction | null;
        public function_call: FunctionCallAction | null;
        public transfer: TransferAction | null;
        public stake: StakeAction | null;
        public add_key: AddKeyAction | null;
        public delete_key: DeleteKeyAction | null;
        public delete_account: DeleteAccountAction | null;

        public __action: string = "";
        public __action_index: u8 = 0;

        static readonly ACTION_CREATE_ACCOUNT_INDEX: u8 = 1;
        static readonly ACTION_DEPLOY_CONTRACT_INDEX: u8 = 2;
        static readonly ACTION_FUNCTION_CALL_INDEX: u8 = 3;
        static readonly ACTION_TRANSFER_INDEX: u8 = 4;
        static readonly ACTION_STAKE_INDEX: u8 = 5;
        static readonly ACTION_ADD_KEY_INDEX: u8 = 6;
        static readonly ACTION_DELETE_KEY_INDEX: u8 = 7;
        static readonly ACTION_DELETE_ACCOUNT_INDEX: u8 = 8;

        // Decodes Action from an ArrayBuffer
        static decode(buf: ArrayBuffer): Action {
          return Action.decodeDataView(new DataView(buf));
        }

        // Decodes Action from a DataView
        static decodeDataView(view: DataView): Action {
          const decoder = new __proto.Decoder(view);
          const obj = new Action();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.create_account = CreateAccountAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "create_account";
                obj.__action_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.deploy_contract = DeployContractAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "deploy_contract";
                obj.__action_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "function_call";
                obj.__action_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.transfer = TransferAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "transfer";
                obj.__action_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.stake = StakeAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "stake";
                obj.__action_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.add_key = AddKeyAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "add_key";
                obj.__action_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.delete_key = DeleteKeyAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "delete_key";
                obj.__action_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.delete_account = DeleteAccountAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "delete_account";
                obj.__action_index = 8;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Action

        public size(): u32 {
          let size: u32 = 0;

          if (this.create_account != null) {
            const f: CreateAccountAction = this
              .create_account as CreateAccountAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.deploy_contract != null) {
            const f: DeployContractAction = this
              .deploy_contract as DeployContractAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.function_call != null) {
            const f: FunctionCallAction = this
              .function_call as FunctionCallAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.transfer != null) {
            const f: TransferAction = this.transfer as TransferAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.stake != null) {
            const f: StakeAction = this.stake as StakeAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.add_key != null) {
            const f: AddKeyAction = this.add_key as AddKeyAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_key != null) {
            const f: DeleteKeyAction = this.delete_key as DeleteKeyAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account != null) {
            const f: DeleteAccountAction = this
              .delete_account as DeleteAccountAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Action to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Action to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.create_account != null) {
            const f = this.create_account as CreateAccountAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.deploy_contract != null) {
            const f = this.deploy_contract as DeployContractAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.transfer != null) {
            const f = this.transfer as TransferAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.stake != null) {
            const f = this.stake as StakeAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.add_key != null) {
            const f = this.add_key as AddKeyAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_key != null) {
            const f = this.delete_key as DeleteKeyAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account != null) {
            const f = this.delete_account as DeleteAccountAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Action
      } // Action

      export class CreateAccountAction {
        // Decodes CreateAccountAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountAction {
          return CreateAccountAction.decodeDataView(new DataView(buf));
        }

        // Decodes CreateAccountAction from a DataView
        static decodeDataView(view: DataView): CreateAccountAction {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountAction

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes CreateAccountAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode CreateAccountAction
      } // CreateAccountAction

      export class DeployContractAction {
        public code: Array<u8> = new Array<u8>();

        // Decodes DeployContractAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeployContractAction {
          return DeployContractAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeployContractAction from a DataView
        static decodeDataView(view: DataView): DeployContractAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeployContractAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.code = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeployContractAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.code.length > 0
              ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
              : 0;

          return size;
        }

        // Encodes DeployContractAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeployContractAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.code.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.code.length);
            encoder.bytes(this.code);
          }

          return buf;
        } // encode DeployContractAction
      } // DeployContractAction

      export class FunctionCallAction {
        public method_name: string = "";
        public args: Array<u8> = new Array<u8>();
        public gas: u64;
        public deposit: BigInt = new BigInt();

        // Decodes FunctionCallAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallAction {
          return FunctionCallAction.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallAction from a DataView
        static decodeDataView(view: DataView): FunctionCallAction {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.method_name = decoder.string();
                break;
              }
              case 2: {
                obj.args = decoder.bytes();
                break;
              }
              case 3: {
                obj.gas = decoder.uint64();
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.deposit = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.method_name.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.method_name.length) +
                this.method_name.length
              : 0;
          size +=
            this.args.length > 0
              ? 1 + __proto.Sizer.varint64(this.args.length) + this.args.length
              : 0;
          size += this.gas == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas);

          if (this.deposit != null) {
            const f: BigInt = this.deposit as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes FunctionCallAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.method_name.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.method_name.length);
            encoder.string(this.method_name);
          }
          if (this.args.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.args.length);
            encoder.bytes(this.args);
          }
          if (this.gas != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.gas);
          }

          if (this.deposit != null) {
            const f = this.deposit as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode FunctionCallAction
      } // FunctionCallAction

      export class TransferAction {
        public deposit: BigInt = new BigInt();

        // Decodes TransferAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): TransferAction {
          return TransferAction.decodeDataView(new DataView(buf));
        }

        // Decodes TransferAction from a DataView
        static decodeDataView(view: DataView): TransferAction {
          const decoder = new __proto.Decoder(view);
          const obj = new TransferAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.deposit = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TransferAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.deposit != null) {
            const f: BigInt = this.deposit as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes TransferAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TransferAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.deposit != null) {
            const f = this.deposit as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode TransferAction
      } // TransferAction

      export class StakeAction {
        public stake: BigInt = new BigInt();
        public public_key: PublicKey = new PublicKey();

        // Decodes StakeAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): StakeAction {
          return StakeAction.decodeDataView(new DataView(buf));
        }

        // Decodes StakeAction from a DataView
        static decodeDataView(view: DataView): StakeAction {
          const decoder = new __proto.Decoder(view);
          const obj = new StakeAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StakeAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StakeAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StakeAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StakeAction
      } // StakeAction

      export class AddKeyAction {
        public public_key: PublicKey = new PublicKey();
        public access_key: AccessKey = new AccessKey();

        // Decodes AddKeyAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): AddKeyAction {
          return AddKeyAction.decodeDataView(new DataView(buf));
        }

        // Decodes AddKeyAction from a DataView
        static decodeDataView(view: DataView): AddKeyAction {
          const decoder = new __proto.Decoder(view);
          const obj = new AddKeyAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.access_key = AccessKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AddKeyAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key != null) {
            const f: AccessKey = this.access_key as AccessKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AddKeyAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AddKeyAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key != null) {
            const f = this.access_key as AccessKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AddKeyAction
      } // AddKeyAction

      export class DeleteKeyAction {
        public public_key: PublicKey = new PublicKey();

        // Decodes DeleteKeyAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteKeyAction {
          return DeleteKeyAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeleteKeyAction from a DataView
        static decodeDataView(view: DataView): DeleteKeyAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteKeyAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteKeyAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes DeleteKeyAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteKeyAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode DeleteKeyAction
      } // DeleteKeyAction

      export class DeleteAccountAction {
        public beneficiary_id: string = "";

        // Decodes DeleteAccountAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountAction {
          return DeleteAccountAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeleteAccountAction from a DataView
        static decodeDataView(view: DataView): DeleteAccountAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.beneficiary_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.beneficiary_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.beneficiary_id.length) +
                this.beneficiary_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.beneficiary_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.beneficiary_id.length);
            encoder.string(this.beneficiary_id);
          }

          return buf;
        } // encode DeleteAccountAction
      } // DeleteAccountAction

      export class AccessKey {
        public nonce: u64;
        public permission: AccessKeyPermission = new AccessKeyPermission();

        // Decodes AccessKey from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccessKey {
          return AccessKey.decodeDataView(new DataView(buf));
        }

        // Decodes AccessKey from a DataView
        static decodeDataView(view: DataView): AccessKey {
          const decoder = new __proto.Decoder(view);
          const obj = new AccessKey();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.nonce = decoder.uint64();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.permission = AccessKeyPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccessKey

        public size(): u32 {
          let size: u32 = 0;

          size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);

          if (this.permission != null) {
            const f: AccessKeyPermission = this
              .permission as AccessKeyPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AccessKey to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccessKey to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.nonce != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.nonce);
          }

          if (this.permission != null) {
            const f = this.permission as AccessKeyPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AccessKey
      } // AccessKey

      export class AccessKeyPermission {
        public function_call: FunctionCallPermission | null;
        public full_access: FullAccessPermission | null;

        public __permission: string = "";
        public __permission_index: u8 = 0;

        static readonly PERMISSION_FUNCTION_CALL_INDEX: u8 = 1;
        static readonly PERMISSION_FULL_ACCESS_INDEX: u8 = 2;

        // Decodes AccessKeyPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccessKeyPermission {
          return AccessKeyPermission.decodeDataView(new DataView(buf));
        }

        // Decodes AccessKeyPermission from a DataView
        static decodeDataView(view: DataView): AccessKeyPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new AccessKeyPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__permission = "function_call";
                obj.__permission_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.full_access = FullAccessPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__permission = "full_access";
                obj.__permission_index = 2;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccessKeyPermission

        public size(): u32 {
          let size: u32 = 0;

          if (this.function_call != null) {
            const f: FunctionCallPermission = this
              .function_call as FunctionCallPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.full_access != null) {
            const f: FullAccessPermission = this
              .full_access as FullAccessPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AccessKeyPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccessKeyPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.full_access != null) {
            const f = this.full_access as FullAccessPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AccessKeyPermission
      } // AccessKeyPermission

      export class FunctionCallPermission {
        public allowance: BigInt = new BigInt();
        public receiver_id: string = "";
        public method_names: Array<string> = new Array<string>();

        // Decodes FunctionCallPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallPermission {
          return FunctionCallPermission.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallPermission from a DataView
        static decodeDataView(view: DataView): FunctionCallPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.allowance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 3: {
                obj.method_names.push(decoder.string());
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallPermission

        public size(): u32 {
          let size: u32 = 0;

          if (this.allowance != null) {
            const f: BigInt = this.allowance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          size += __size_string_repeated(this.method_names);

          return size;
        }

        // Encodes FunctionCallPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.allowance != null) {
            const f = this.allowance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          if (this.method_names.length > 0) {
            for (let n: i32 = 0; n < this.method_names.length; n++) {
              encoder.uint32(0x1a);
              encoder.uint32(this.method_names[n].length);
              encoder.string(this.method_names[n]);
            }
          }

          return buf;
        } // encode FunctionCallPermission
      } // FunctionCallPermission

      export class FullAccessPermission {
        // Decodes FullAccessPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): FullAccessPermission {
          return FullAccessPermission.decodeDataView(new DataView(buf));
        }

        // Decodes FullAccessPermission from a DataView
        static decodeDataView(view: DataView): FullAccessPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new FullAccessPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FullAccessPermission

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes FullAccessPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FullAccessPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode FullAccessPermission
      } // FullAccessPermission
    } // v1
  } // near
  export namespace codec {
    export namespace v1 {
      export enum CurveKind {
        ED25519 = 0,
        SECP256K1 = 1,
      } // CurveKind
      export enum ExecutionMetadata {
        ExecutionMetadataV1 = 0,
      } // ExecutionMetadata
      // todo: add more detail?
      export enum FunctionCallErrorSer {
        CompilationError = 0,
        LinkError = 1,
        MethodResolveError = 2,
        WasmTrap = 3,
        WasmUnknownError = 4,
        HostError = 5,
        _EVMError = 6,
        ExecutionError = 7,
      } // FunctionCallErrorSer
      // todo: add more detail?
      export enum ReceiptValidationError {
        InvalidPredecessorId = 0,
        InvalidReceiverAccountId = 1,
        InvalidSignerAccountId = 2,
        InvalidDataReceiverId = 3,
        ReturnedValueLengthExceeded = 4,
        NumberInputDataDependenciesExceeded = 5,
        ActionsValidationError = 6,
      } // ReceiptValidationError
      // todo: add more detail?
      export enum InvalidTxError {
        InvalidAccessKeyError = 0,
        InvalidSignerId = 1,
        SignerDoesNotExist = 2,
        InvalidNonce = 3,
        NonceTooLarge = 4,
        InvalidReceiverId = 5,
        InvalidSignature = 6,
        NotEnoughBalance = 7,
        LackBalanceForState = 8,
        CostOverflow = 9,
        InvalidChain = 10,
        Expired = 11,
        ActionsValidation = 12,
        TransactionSizeExceeded = 13,
      } // InvalidTxError
      export enum Direction {
        left = 0,
        right = 1,
      } // Direction
      export class Block {
        public author: string = "";
        public header: BlockHeader = new BlockHeader();
        public chunk_headers: Array<ChunkHeader> = new Array<ChunkHeader>();
        public shards: Array<IndexerShard> = new Array<IndexerShard>();
        public state_changes: Array<StateChangeWithCause> =
          new Array<StateChangeWithCause>();

        // Decodes Block from an ArrayBuffer
        static decode(buf: ArrayBuffer): Block {
          return Block.decodeDataView(new DataView(buf));
        }

        // Decodes Block from a DataView
        static decodeDataView(view: DataView): Block {
          const decoder = new __proto.Decoder(view);
          const obj = new Block();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.author = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.header = BlockHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.chunk_headers.push(
                  ChunkHeader.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.shards.push(
                  IndexerShard.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.state_changes.push(
                  StateChangeWithCause.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Block

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.author.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.author.length) +
                this.author.length
              : 0;

          if (this.header != null) {
            const f: BlockHeader = this.header as BlockHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
            const messageSize = this.chunk_headers[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.shards.length; n++) {
            const messageSize = this.shards[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.state_changes.length; n++) {
            const messageSize = this.state_changes[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Block to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Block to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.author.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.author.length);
            encoder.string(this.author);
          }

          if (this.header != null) {
            const f = this.header as BlockHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
            const messageSize = this.chunk_headers[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.chunk_headers[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.shards.length; n++) {
            const messageSize = this.shards[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.shards[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.state_changes.length; n++) {
            const messageSize = this.state_changes[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.state_changes[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Block
      } // Block

      /**
       * HeaderOnlyBlock is a standard [Block] structure where all other fields are
       *  removed so that hydrating that object from a [Block] bytes payload will
       *  drastically reduced allocated memory required to hold the full block.
       *
       *  This can be used to unpack a [Block] when only the [BlockHeader] information
       *  is required and greatly reduced required memory.
       */
      export class HeaderOnlyBlock {
        public header: BlockHeader = new BlockHeader();

        // Decodes HeaderOnlyBlock from an ArrayBuffer
        static decode(buf: ArrayBuffer): HeaderOnlyBlock {
          return HeaderOnlyBlock.decodeDataView(new DataView(buf));
        }

        // Decodes HeaderOnlyBlock from a DataView
        static decodeDataView(view: DataView): HeaderOnlyBlock {
          const decoder = new __proto.Decoder(view);
          const obj = new HeaderOnlyBlock();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 2: {
                const length = decoder.uint32();
                obj.header = BlockHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode HeaderOnlyBlock

        public size(): u32 {
          let size: u32 = 0;

          if (this.header != null) {
            const f: BlockHeader = this.header as BlockHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes HeaderOnlyBlock to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes HeaderOnlyBlock to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.header != null) {
            const f = this.header as BlockHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode HeaderOnlyBlock
      } // HeaderOnlyBlock

      export class StateChangeWithCause {
        public value: StateChangeValue = new StateChangeValue();
        public cause: StateChangeCause = new StateChangeCause();

        // Decodes StateChangeWithCause from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeWithCause {
          return StateChangeWithCause.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeWithCause from a DataView
        static decodeDataView(view: DataView): StateChangeWithCause {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeWithCause();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.value = StateChangeValue.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.cause = StateChangeCause.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeWithCause

        public size(): u32 {
          let size: u32 = 0;

          if (this.value != null) {
            const f: StateChangeValue = this.value as StateChangeValue;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.cause != null) {
            const f: StateChangeCause = this.cause as StateChangeCause;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeWithCause to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeWithCause to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.value != null) {
            const f = this.value as StateChangeValue;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.cause != null) {
            const f = this.cause as StateChangeCause;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeWithCause
      } // StateChangeWithCause

      // / A top-level account ID can only be created by registrar.
      export class StateChangeCause {
        public not_writable_to_disk: StateChangeCause_NotWritableToDisk | null;
        public initial_state: StateChangeCause_InitialState | null;
        public transaction_processing: StateChangeCause_TransactionProcessing | null;
        public action_receipt_processing_started: StateChangeCause_ActionReceiptProcessingStarted | null;
        public action_receipt_gas_reward: StateChangeCause_ActionReceiptGasReward | null;
        public receipt_processing: StateChangeCause_ReceiptProcessing | null;
        public postponed_receipt: StateChangeCause_PostponedReceipt | null;
        public updated_delayed_receipts: StateChangeCause_UpdatedDelayedReceipts | null;
        public validator_accounts_update: StateChangeCause_ValidatorAccountsUpdate | null;
        public migration: StateChangeCause_Migration | null;

        public __cause: string = "";
        public __cause_index: u8 = 0;

        static readonly CAUSE_NOT_WRITABLE_TO_DISK_INDEX: u8 = 1;
        static readonly CAUSE_INITIAL_STATE_INDEX: u8 = 2;
        static readonly CAUSE_TRANSACTION_PROCESSING_INDEX: u8 = 3;
        static readonly CAUSE_ACTION_RECEIPT_PROCESSING_STARTED_INDEX: u8 = 4;
        static readonly CAUSE_ACTION_RECEIPT_GAS_REWARD_INDEX: u8 = 5;
        static readonly CAUSE_RECEIPT_PROCESSING_INDEX: u8 = 6;
        static readonly CAUSE_POSTPONED_RECEIPT_INDEX: u8 = 7;
        static readonly CAUSE_UPDATED_DELAYED_RECEIPTS_INDEX: u8 = 8;
        static readonly CAUSE_VALIDATOR_ACCOUNTS_UPDATE_INDEX: u8 = 9;
        static readonly CAUSE_MIGRATION_INDEX: u8 = 10;

        // Decodes StateChangeCause from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause {
          return StateChangeCause.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeCause from a DataView
        static decodeDataView(view: DataView): StateChangeCause {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.not_writable_to_disk =
                  StateChangeCause_NotWritableToDisk.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "not_writable_to_disk";
                obj.__cause_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.initial_state =
                  StateChangeCause_InitialState.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "initial_state";
                obj.__cause_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.transaction_processing =
                  StateChangeCause_TransactionProcessing.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "transaction_processing";
                obj.__cause_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.action_receipt_processing_started =
                  StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "action_receipt_processing_started";
                obj.__cause_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.action_receipt_gas_reward =
                  StateChangeCause_ActionReceiptGasReward.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "action_receipt_gas_reward";
                obj.__cause_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.receipt_processing =
                  StateChangeCause_ReceiptProcessing.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "receipt_processing";
                obj.__cause_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.postponed_receipt =
                  StateChangeCause_PostponedReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "postponed_receipt";
                obj.__cause_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.updated_delayed_receipts =
                  StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "updated_delayed_receipts";
                obj.__cause_index = 8;
                break;
              }
              case 9: {
                const length = decoder.uint32();
                obj.validator_accounts_update =
                  StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__cause = "validator_accounts_update";
                obj.__cause_index = 9;
                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.migration = StateChangeCause_Migration.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__cause = "migration";
                obj.__cause_index = 10;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause

        public size(): u32 {
          let size: u32 = 0;

          if (this.not_writable_to_disk != null) {
            const f: StateChangeCause_NotWritableToDisk = this
              .not_writable_to_disk as StateChangeCause_NotWritableToDisk;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.initial_state != null) {
            const f: StateChangeCause_InitialState = this
              .initial_state as StateChangeCause_InitialState;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.transaction_processing != null) {
            const f: StateChangeCause_TransactionProcessing = this
              .transaction_processing as StateChangeCause_TransactionProcessing;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action_receipt_processing_started != null) {
            const f: StateChangeCause_ActionReceiptProcessingStarted = this
              .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action_receipt_gas_reward != null) {
            const f: StateChangeCause_ActionReceiptGasReward = this
              .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt_processing != null) {
            const f: StateChangeCause_ReceiptProcessing = this
              .receipt_processing as StateChangeCause_ReceiptProcessing;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.postponed_receipt != null) {
            const f: StateChangeCause_PostponedReceipt = this
              .postponed_receipt as StateChangeCause_PostponedReceipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.updated_delayed_receipts != null) {
            const f: StateChangeCause_UpdatedDelayedReceipts = this
              .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.validator_accounts_update != null) {
            const f: StateChangeCause_ValidatorAccountsUpdate = this
              .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.migration != null) {
            const f: StateChangeCause_Migration = this
              .migration as StateChangeCause_Migration;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.not_writable_to_disk != null) {
            const f = this
              .not_writable_to_disk as StateChangeCause_NotWritableToDisk;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.initial_state != null) {
            const f = this.initial_state as StateChangeCause_InitialState;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.transaction_processing != null) {
            const f = this
              .transaction_processing as StateChangeCause_TransactionProcessing;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action_receipt_processing_started != null) {
            const f = this
              .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action_receipt_gas_reward != null) {
            const f = this
              .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt_processing != null) {
            const f = this
              .receipt_processing as StateChangeCause_ReceiptProcessing;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.postponed_receipt != null) {
            const f = this
              .postponed_receipt as StateChangeCause_PostponedReceipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.updated_delayed_receipts != null) {
            const f = this
              .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.validator_accounts_update != null) {
            const f = this
              .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x4a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.migration != null) {
            const f = this.migration as StateChangeCause_Migration;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause
      } // StateChangeCause

      export class StateChangeCause_NotWritableToDisk {
        // Decodes StateChangeCause_NotWritableToDisk from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_NotWritableToDisk {
          return StateChangeCause_NotWritableToDisk.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_NotWritableToDisk from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_NotWritableToDisk {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_NotWritableToDisk();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_NotWritableToDisk

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_NotWritableToDisk to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_NotWritableToDisk to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_NotWritableToDisk
      } // StateChangeCause_NotWritableToDisk

      export class StateChangeCause_InitialState {
        // Decodes StateChangeCause_InitialState from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_InitialState {
          return StateChangeCause_InitialState.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_InitialState from a DataView
        static decodeDataView(view: DataView): StateChangeCause_InitialState {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_InitialState();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_InitialState

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_InitialState to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_InitialState to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_InitialState
      } // StateChangeCause_InitialState

      export class StateChangeCause_TransactionProcessing {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_TransactionProcessing from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_TransactionProcessing {
          return StateChangeCause_TransactionProcessing.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_TransactionProcessing from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_TransactionProcessing {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_TransactionProcessing();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_TransactionProcessing

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_TransactionProcessing to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_TransactionProcessing to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_TransactionProcessing
      } // StateChangeCause_TransactionProcessing

      export class StateChangeCause_ActionReceiptProcessingStarted {
        public receipt_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ActionReceiptProcessingStarted from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ActionReceiptProcessingStarted {
          return StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ActionReceiptProcessingStarted from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ActionReceiptProcessingStarted {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ActionReceiptProcessingStarted();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.receipt_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ActionReceiptProcessingStarted

        public size(): u32 {
          let size: u32 = 0;

          if (this.receipt_hash != null) {
            const f: CryptoHash = this.receipt_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ActionReceiptProcessingStarted to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ActionReceiptProcessingStarted to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.receipt_hash != null) {
            const f = this.receipt_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ActionReceiptProcessingStarted
      } // StateChangeCause_ActionReceiptProcessingStarted

      export class StateChangeCause_ActionReceiptGasReward {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ActionReceiptGasReward from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ActionReceiptGasReward {
          return StateChangeCause_ActionReceiptGasReward.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ActionReceiptGasReward from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ActionReceiptGasReward {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ActionReceiptGasReward();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ActionReceiptGasReward

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ActionReceiptGasReward to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ActionReceiptGasReward to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ActionReceiptGasReward
      } // StateChangeCause_ActionReceiptGasReward

      export class StateChangeCause_ReceiptProcessing {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_ReceiptProcessing from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_ReceiptProcessing {
          return StateChangeCause_ReceiptProcessing.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ReceiptProcessing from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ReceiptProcessing {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ReceiptProcessing();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ReceiptProcessing

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_ReceiptProcessing to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ReceiptProcessing to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_ReceiptProcessing
      } // StateChangeCause_ReceiptProcessing

      export class StateChangeCause_PostponedReceipt {
        public tx_hash: CryptoHash = new CryptoHash();

        // Decodes StateChangeCause_PostponedReceipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_PostponedReceipt {
          return StateChangeCause_PostponedReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_PostponedReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_PostponedReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_PostponedReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.tx_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_PostponedReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.tx_hash != null) {
            const f: CryptoHash = this.tx_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeCause_PostponedReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_PostponedReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.tx_hash != null) {
            const f = this.tx_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeCause_PostponedReceipt
      } // StateChangeCause_PostponedReceipt

      export class StateChangeCause_UpdatedDelayedReceipts {
        // Decodes StateChangeCause_UpdatedDelayedReceipts from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_UpdatedDelayedReceipts {
          return StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_UpdatedDelayedReceipts from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_UpdatedDelayedReceipts {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_UpdatedDelayedReceipts();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_UpdatedDelayedReceipts

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_UpdatedDelayedReceipts to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_UpdatedDelayedReceipts to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_UpdatedDelayedReceipts
      } // StateChangeCause_UpdatedDelayedReceipts

      export class StateChangeCause_ValidatorAccountsUpdate {
        // Decodes StateChangeCause_ValidatorAccountsUpdate from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): StateChangeCause_ValidatorAccountsUpdate {
          return StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeCause_ValidatorAccountsUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeCause_ValidatorAccountsUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_ValidatorAccountsUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_ValidatorAccountsUpdate

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_ValidatorAccountsUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_ValidatorAccountsUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_ValidatorAccountsUpdate
      } // StateChangeCause_ValidatorAccountsUpdate

      export class StateChangeCause_Migration {
        // Decodes StateChangeCause_Migration from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeCause_Migration {
          return StateChangeCause_Migration.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeCause_Migration from a DataView
        static decodeDataView(view: DataView): StateChangeCause_Migration {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeCause_Migration();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeCause_Migration

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes StateChangeCause_Migration to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeCause_Migration to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode StateChangeCause_Migration
      } // StateChangeCause_Migration

      export class StateChangeValue {
        public account_update: StateChangeValue_AccountUpdate | null;
        public account_deletion: StateChangeValue_AccountDeletion | null;
        public access_key_update: StateChangeValue_AccessKeyUpdate | null;
        public access_key_deletion: StateChangeValue_AccessKeyDeletion | null;
        public data_update: StateChangeValue_DataUpdate | null;
        public data_deletion: StateChangeValue_DataDeletion | null;
        public contract_code_update: StateChangeValue_ContractCodeUpdate | null;
        public contract_deletion: StateChangeValue_ContractCodeDeletion | null;

        public __value: string = "";
        public __value_index: u8 = 0;

        static readonly VALUE_ACCOUNT_UPDATE_INDEX: u8 = 1;
        static readonly VALUE_ACCOUNT_DELETION_INDEX: u8 = 2;
        static readonly VALUE_ACCESS_KEY_UPDATE_INDEX: u8 = 3;
        static readonly VALUE_ACCESS_KEY_DELETION_INDEX: u8 = 4;
        static readonly VALUE_DATA_UPDATE_INDEX: u8 = 5;
        static readonly VALUE_DATA_DELETION_INDEX: u8 = 6;
        static readonly VALUE_CONTRACT_CODE_UPDATE_INDEX: u8 = 7;
        static readonly VALUE_CONTRACT_DELETION_INDEX: u8 = 8;

        // Decodes StateChangeValue from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue {
          return StateChangeValue.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeValue from a DataView
        static decodeDataView(view: DataView): StateChangeValue {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.account_update =
                  StateChangeValue_AccountUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "account_update";
                obj.__value_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.account_deletion =
                  StateChangeValue_AccountDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "account_deletion";
                obj.__value_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.access_key_update =
                  StateChangeValue_AccessKeyUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "access_key_update";
                obj.__value_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.access_key_deletion =
                  StateChangeValue_AccessKeyDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "access_key_deletion";
                obj.__value_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.data_update = StateChangeValue_DataUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__value = "data_update";
                obj.__value_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.data_deletion =
                  StateChangeValue_DataDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "data_deletion";
                obj.__value_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.contract_code_update =
                  StateChangeValue_ContractCodeUpdate.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "contract_code_update";
                obj.__value_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.contract_deletion =
                  StateChangeValue_ContractCodeDeletion.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__value = "contract_deletion";
                obj.__value_index = 8;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue

        public size(): u32 {
          let size: u32 = 0;

          if (this.account_update != null) {
            const f: StateChangeValue_AccountUpdate = this
              .account_update as StateChangeValue_AccountUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.account_deletion != null) {
            const f: StateChangeValue_AccountDeletion = this
              .account_deletion as StateChangeValue_AccountDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key_update != null) {
            const f: StateChangeValue_AccessKeyUpdate = this
              .access_key_update as StateChangeValue_AccessKeyUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key_deletion != null) {
            const f: StateChangeValue_AccessKeyDeletion = this
              .access_key_deletion as StateChangeValue_AccessKeyDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data_update != null) {
            const f: StateChangeValue_DataUpdate = this
              .data_update as StateChangeValue_DataUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data_deletion != null) {
            const f: StateChangeValue_DataDeletion = this
              .data_deletion as StateChangeValue_DataDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.contract_code_update != null) {
            const f: StateChangeValue_ContractCodeUpdate = this
              .contract_code_update as StateChangeValue_ContractCodeUpdate;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.contract_deletion != null) {
            const f: StateChangeValue_ContractCodeDeletion = this
              .contract_deletion as StateChangeValue_ContractCodeDeletion;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_update != null) {
            const f = this.account_update as StateChangeValue_AccountUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.account_deletion != null) {
            const f = this.account_deletion as StateChangeValue_AccountDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key_update != null) {
            const f = this
              .access_key_update as StateChangeValue_AccessKeyUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key_deletion != null) {
            const f = this
              .access_key_deletion as StateChangeValue_AccessKeyDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data_update != null) {
            const f = this.data_update as StateChangeValue_DataUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data_deletion != null) {
            const f = this.data_deletion as StateChangeValue_DataDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.contract_code_update != null) {
            const f = this
              .contract_code_update as StateChangeValue_ContractCodeUpdate;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.contract_deletion != null) {
            const f = this
              .contract_deletion as StateChangeValue_ContractCodeDeletion;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue
      } // StateChangeValue

      export class StateChangeValue_AccountUpdate {
        public account_id: string = "";
        public account: Account = new Account();

        // Decodes StateChangeValue_AccountUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccountUpdate {
          return StateChangeValue_AccountUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccountUpdate from a DataView
        static decodeDataView(view: DataView): StateChangeValue_AccountUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccountUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.account = Account.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccountUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.account != null) {
            const f: Account = this.account as Account;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccountUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccountUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.account != null) {
            const f = this.account as Account;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccountUpdate
      } // StateChangeValue_AccountUpdate

      export class StateChangeValue_AccountDeletion {
        public account_id: string = "";

        // Decodes StateChangeValue_AccountDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccountDeletion {
          return StateChangeValue_AccountDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccountDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccountDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccountDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccountDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_AccountDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccountDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode StateChangeValue_AccountDeletion
      } // StateChangeValue_AccountDeletion

      export class StateChangeValue_AccessKeyUpdate {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public access_key: AccessKey = new AccessKey();

        // Decodes StateChangeValue_AccessKeyUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyUpdate {
          return StateChangeValue_AccessKeyUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccessKeyUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccessKeyUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccessKeyUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.access_key = AccessKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccessKeyUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key != null) {
            const f: AccessKey = this.access_key as AccessKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccessKeyUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccessKeyUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key != null) {
            const f = this.access_key as AccessKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccessKeyUpdate
      } // StateChangeValue_AccessKeyUpdate

      export class StateChangeValue_AccessKeyDeletion {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes StateChangeValue_AccessKeyDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyDeletion {
          return StateChangeValue_AccessKeyDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_AccessKeyDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_AccessKeyDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_AccessKeyDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_AccessKeyDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StateChangeValue_AccessKeyDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_AccessKeyDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StateChangeValue_AccessKeyDeletion
      } // StateChangeValue_AccessKeyDeletion

      export class StateChangeValue_DataUpdate {
        public account_id: string = "";
        public key: Array<u8> = new Array<u8>();
        public value: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_DataUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_DataUpdate {
          return StateChangeValue_DataUpdate.decodeDataView(new DataView(buf));
        }

        // Decodes StateChangeValue_DataUpdate from a DataView
        static decodeDataView(view: DataView): StateChangeValue_DataUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_DataUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.key = decoder.bytes();
                break;
              }
              case 3: {
                obj.value = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_DataUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.key.length > 0
              ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
              : 0;
          size +=
            this.value.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.value.length) +
                this.value.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_DataUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_DataUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.key.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.key.length);
            encoder.bytes(this.key);
          }
          if (this.value.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.value.length);
            encoder.bytes(this.value);
          }

          return buf;
        } // encode StateChangeValue_DataUpdate
      } // StateChangeValue_DataUpdate

      export class StateChangeValue_DataDeletion {
        public account_id: string = "";
        public key: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_DataDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_DataDeletion {
          return StateChangeValue_DataDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_DataDeletion from a DataView
        static decodeDataView(view: DataView): StateChangeValue_DataDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_DataDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.key = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_DataDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.key.length > 0
              ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_DataDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_DataDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.key.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.key.length);
            encoder.bytes(this.key);
          }

          return buf;
        } // encode StateChangeValue_DataDeletion
      } // StateChangeValue_DataDeletion

      export class StateChangeValue_ContractCodeUpdate {
        public account_id: string = "";
        public code: Array<u8> = new Array<u8>();

        // Decodes StateChangeValue_ContractCodeUpdate from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeUpdate {
          return StateChangeValue_ContractCodeUpdate.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_ContractCodeUpdate from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_ContractCodeUpdate {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_ContractCodeUpdate();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.code = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_ContractCodeUpdate

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.code.length > 0
              ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_ContractCodeUpdate to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_ContractCodeUpdate to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.code.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.code.length);
            encoder.bytes(this.code);
          }

          return buf;
        } // encode StateChangeValue_ContractCodeUpdate
      } // StateChangeValue_ContractCodeUpdate

      export class StateChangeValue_ContractCodeDeletion {
        public account_id: string = "";

        // Decodes StateChangeValue_ContractCodeDeletion from an ArrayBuffer
        static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeDeletion {
          return StateChangeValue_ContractCodeDeletion.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes StateChangeValue_ContractCodeDeletion from a DataView
        static decodeDataView(
          view: DataView
        ): StateChangeValue_ContractCodeDeletion {
          const decoder = new __proto.Decoder(view);
          const obj = new StateChangeValue_ContractCodeDeletion();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StateChangeValue_ContractCodeDeletion

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes StateChangeValue_ContractCodeDeletion to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StateChangeValue_ContractCodeDeletion to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode StateChangeValue_ContractCodeDeletion
      } // StateChangeValue_ContractCodeDeletion

      export class Account {
        public amount: BigInt = new BigInt();
        public locked: BigInt = new BigInt();
        public code_hash: CryptoHash = new CryptoHash();
        public storage_usage: u64;

        // Decodes Account from an ArrayBuffer
        static decode(buf: ArrayBuffer): Account {
          return Account.decodeDataView(new DataView(buf));
        }

        // Decodes Account from a DataView
        static decodeDataView(view: DataView): Account {
          const decoder = new __proto.Decoder(view);
          const obj = new Account();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.amount = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.locked = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.code_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                obj.storage_usage = decoder.uint64();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Account

        public size(): u32 {
          let size: u32 = 0;

          if (this.amount != null) {
            const f: BigInt = this.amount as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.locked != null) {
            const f: BigInt = this.locked as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.code_hash != null) {
            const f: CryptoHash = this.code_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.storage_usage == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.storage_usage);

          return size;
        }

        // Encodes Account to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Account to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.amount != null) {
            const f = this.amount as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.locked != null) {
            const f = this.locked as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.code_hash != null) {
            const f = this.code_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.storage_usage != 0) {
            encoder.uint32(0x20);
            encoder.uint64(this.storage_usage);
          }

          return buf;
        } // encode Account
      } // Account

      export class BlockHeader {
        public height: u64;
        public prev_height: u64;
        public epoch_id: CryptoHash = new CryptoHash();
        public next_epoch_id: CryptoHash = new CryptoHash();
        public hash: CryptoHash = new CryptoHash();
        public prev_hash: CryptoHash = new CryptoHash();
        public prev_state_root: CryptoHash = new CryptoHash();
        public chunk_receipts_root: CryptoHash = new CryptoHash();
        public chunk_headers_root: CryptoHash = new CryptoHash();
        public chunk_tx_root: CryptoHash = new CryptoHash();
        public outcome_root: CryptoHash = new CryptoHash();
        public chunks_included: u64;
        public challenges_root: CryptoHash = new CryptoHash();
        public timestamp: u64;
        public timestamp_nanosec: u64;
        public random_value: CryptoHash = new CryptoHash();
        public validator_proposals: Array<ValidatorStake> =
          new Array<ValidatorStake>();
        public chunk_mask: Array<bool> = new Array<bool>();
        public gas_price: BigInt = new BigInt();
        public block_ordinal: u64;
        public total_supply: BigInt = new BigInt();
        public challenges_result: Array<SlashedValidator> =
          new Array<SlashedValidator>();
        public last_final_block_height: u64;
        public last_final_block: CryptoHash = new CryptoHash();
        public last_ds_final_block_height: u64;
        public last_ds_final_block: CryptoHash = new CryptoHash();
        public next_bp_hash: CryptoHash = new CryptoHash();
        public block_merkle_root: CryptoHash = new CryptoHash();
        public epoch_sync_data_hash: Array<u8> = new Array<u8>();
        public approvals: Array<Signature> = new Array<Signature>();
        public signature: Signature = new Signature();
        public latest_protocol_version: u32;

        // Decodes BlockHeader from an ArrayBuffer
        static decode(buf: ArrayBuffer): BlockHeader {
          return BlockHeader.decodeDataView(new DataView(buf));
        }

        // Decodes BlockHeader from a DataView
        static decodeDataView(view: DataView): BlockHeader {
          const decoder = new __proto.Decoder(view);
          const obj = new BlockHeader();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.height = decoder.uint64();
                break;
              }
              case 2: {
                obj.prev_height = decoder.uint64();
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.epoch_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.next_epoch_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.prev_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.prev_state_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.chunk_receipts_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 9: {
                const length = decoder.uint32();
                obj.chunk_headers_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.chunk_tx_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 11: {
                const length = decoder.uint32();
                obj.outcome_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 12: {
                obj.chunks_included = decoder.uint64();
                break;
              }
              case 13: {
                const length = decoder.uint32();
                obj.challenges_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 14: {
                obj.timestamp = decoder.uint64();
                break;
              }
              case 15: {
                obj.timestamp_nanosec = decoder.uint64();
                break;
              }
              case 16: {
                const length = decoder.uint32();
                obj.random_value = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 17: {
                const length = decoder.uint32();
                obj.validator_proposals.push(
                  ValidatorStake.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 18: {
                const endPos = decoder.pos + decoder.uint32();
                while (decoder.pos <= endPos) {
                  obj.chunk_mask.push(decoder.bool());
                }

                break;
              }
              case 19: {
                const length = decoder.uint32();
                obj.gas_price = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 20: {
                obj.block_ordinal = decoder.uint64();
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.total_supply = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.challenges_result.push(
                  SlashedValidator.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 23: {
                obj.last_final_block_height = decoder.uint64();
                break;
              }
              case 24: {
                const length = decoder.uint32();
                obj.last_final_block = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 25: {
                obj.last_ds_final_block_height = decoder.uint64();
                break;
              }
              case 26: {
                const length = decoder.uint32();
                obj.last_ds_final_block = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 27: {
                const length = decoder.uint32();
                obj.next_bp_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 28: {
                const length = decoder.uint32();
                obj.block_merkle_root = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 29: {
                obj.epoch_sync_data_hash = decoder.bytes();
                break;
              }
              case 30: {
                const length = decoder.uint32();
                obj.approvals.push(
                  Signature.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 31: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 32: {
                obj.latest_protocol_version = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode BlockHeader

        public size(): u32 {
          let size: u32 = 0;

          size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint64(this.height);
          size +=
            this.prev_height == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.prev_height);

          if (this.epoch_id != null) {
            const f: CryptoHash = this.epoch_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.next_epoch_id != null) {
            const f: CryptoHash = this.next_epoch_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.prev_hash != null) {
            const f: CryptoHash = this.prev_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.prev_state_root != null) {
            const f: CryptoHash = this.prev_state_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_receipts_root != null) {
            const f: CryptoHash = this.chunk_receipts_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_headers_root != null) {
            const f: CryptoHash = this.chunk_headers_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_tx_root != null) {
            const f: CryptoHash = this.chunk_tx_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome_root != null) {
            const f: CryptoHash = this.outcome_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.chunks_included == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.chunks_included);

          if (this.challenges_root != null) {
            const f: CryptoHash = this.challenges_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.timestamp == 0 ? 0 : 1 + __proto.Sizer.uint64(this.timestamp);
          size +=
            this.timestamp_nanosec == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.timestamp_nanosec);

          if (this.random_value != null) {
            const f: CryptoHash = this.random_value as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.chunk_mask.length > 0) {
            const packedSize = __size_bool_repeated_packed(this.chunk_mask);
            if (packedSize > 0) {
              size += 2 + __proto.Sizer.varint64(packedSize) + packedSize;
            }
          }

          if (this.gas_price != null) {
            const f: BigInt = this.gas_price as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.block_ordinal == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.block_ordinal);

          if (this.total_supply != null) {
            const f: BigInt = this.total_supply as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.challenges_result.length; n++) {
            const messageSize = this.challenges_result[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.last_final_block_height == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.last_final_block_height);

          if (this.last_final_block != null) {
            const f: CryptoHash = this.last_final_block as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.last_ds_final_block_height == 0
              ? 0
              : 2 + __proto.Sizer.uint64(this.last_ds_final_block_height);

          if (this.last_ds_final_block != null) {
            const f: CryptoHash = this.last_ds_final_block as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.next_bp_hash != null) {
            const f: CryptoHash = this.next_bp_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.block_merkle_root != null) {
            const f: CryptoHash = this.block_merkle_root as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.epoch_sync_data_hash.length > 0
              ? 2 +
                __proto.Sizer.varint64(this.epoch_sync_data_hash.length) +
                this.epoch_sync_data_hash.length
              : 0;

          for (let n: i32 = 0; n < this.approvals.length; n++) {
            const messageSize = this.approvals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.latest_protocol_version == 0
              ? 0
              : 2 + __proto.Sizer.uint32(this.latest_protocol_version);

          return size;
        }

        // Encodes BlockHeader to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes BlockHeader to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.height != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.height);
          }
          if (this.prev_height != 0) {
            encoder.uint32(0x10);
            encoder.uint64(this.prev_height);
          }

          if (this.epoch_id != null) {
            const f = this.epoch_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.next_epoch_id != null) {
            const f = this.next_epoch_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.prev_hash != null) {
            const f = this.prev_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.prev_state_root != null) {
            const f = this.prev_state_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_receipts_root != null) {
            const f = this.chunk_receipts_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_headers_root != null) {
            const f = this.chunk_headers_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x4a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunk_tx_root != null) {
            const f = this.chunk_tx_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome_root != null) {
            const f = this.outcome_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x5a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.chunks_included != 0) {
            encoder.uint32(0x60);
            encoder.uint64(this.chunks_included);
          }

          if (this.challenges_root != null) {
            const f = this.challenges_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x6a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.timestamp != 0) {
            encoder.uint32(0x70);
            encoder.uint64(this.timestamp);
          }
          if (this.timestamp_nanosec != 0) {
            encoder.uint32(0x78);
            encoder.uint64(this.timestamp_nanosec);
          }

          if (this.random_value != null) {
            const f = this.random_value as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x82);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x8a);
              encoder.uint32(messageSize);
              this.validator_proposals[n].encodeU8Array(encoder);
            }
          }

          if (this.chunk_mask.length > 0) {
            encoder.uint32(0x92);
            encoder.uint32(__size_bool_repeated_packed(this.chunk_mask));

            for (let n: i32 = 0; n < this.chunk_mask.length; n++) {
              encoder.bool(this.chunk_mask[n]);
            }
          }

          if (this.gas_price != null) {
            const f = this.gas_price as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x9a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_ordinal != 0) {
            encoder.uint32(0xa0);
            encoder.uint64(this.block_ordinal);
          }

          if (this.total_supply != null) {
            const f = this.total_supply as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.challenges_result.length; n++) {
            const messageSize = this.challenges_result[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              this.challenges_result[n].encodeU8Array(encoder);
            }
          }

          if (this.last_final_block_height != 0) {
            encoder.uint32(0xb8);
            encoder.uint64(this.last_final_block_height);
          }

          if (this.last_final_block != null) {
            const f = this.last_final_block as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xc2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.last_ds_final_block_height != 0) {
            encoder.uint32(0xc8);
            encoder.uint64(this.last_ds_final_block_height);
          }

          if (this.last_ds_final_block != null) {
            const f = this.last_ds_final_block as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xd2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.next_bp_hash != null) {
            const f = this.next_bp_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xda);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_merkle_root != null) {
            const f = this.block_merkle_root as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xe2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.epoch_sync_data_hash.length > 0) {
            encoder.uint32(0xea);
            encoder.uint32(this.epoch_sync_data_hash.length);
            encoder.bytes(this.epoch_sync_data_hash);
          }

          for (let n: i32 = 0; n < this.approvals.length; n++) {
            const messageSize = this.approvals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xf2);
              encoder.uint32(messageSize);
              this.approvals[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xfa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.latest_protocol_version != 0) {
            encoder.uint32(0x100);
            encoder.uint32(this.latest_protocol_version);
          }

          return buf;
        } // encode BlockHeader
      } // BlockHeader

      export class BigInt {
        public bytes: Array<u8> = new Array<u8>();

        // Decodes BigInt from an ArrayBuffer
        static decode(buf: ArrayBuffer): BigInt {
          return BigInt.decodeDataView(new DataView(buf));
        }

        // Decodes BigInt from a DataView
        static decodeDataView(view: DataView): BigInt {
          const decoder = new __proto.Decoder(view);
          const obj = new BigInt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode BigInt

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes BigInt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes BigInt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.bytes.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode BigInt
      } // BigInt

      export class CryptoHash {
        public bytes: Array<u8> = new Array<u8>();

        // Decodes CryptoHash from an ArrayBuffer
        static decode(buf: ArrayBuffer): CryptoHash {
          return CryptoHash.decodeDataView(new DataView(buf));
        }

        // Decodes CryptoHash from a DataView
        static decodeDataView(view: DataView): CryptoHash {
          const decoder = new __proto.Decoder(view);
          const obj = new CryptoHash();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CryptoHash

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes CryptoHash to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CryptoHash to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.bytes.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode CryptoHash
      } // CryptoHash

      export class Signature {
        public type: u32;
        public bytes: Array<u8> = new Array<u8>();

        // Decodes Signature from an ArrayBuffer
        static decode(buf: ArrayBuffer): Signature {
          return Signature.decodeDataView(new DataView(buf));
        }

        // Decodes Signature from a DataView
        static decodeDataView(view: DataView): Signature {
          const decoder = new __proto.Decoder(view);
          const obj = new Signature();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.type = decoder.uint32();
                break;
              }
              case 2: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Signature

        public size(): u32 {
          let size: u32 = 0;

          size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes Signature to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Signature to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.type != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.type);
          }
          if (this.bytes.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode Signature
      } // Signature

      export class PublicKey {
        public type: u32;
        public bytes: Array<u8> = new Array<u8>();

        // Decodes PublicKey from an ArrayBuffer
        static decode(buf: ArrayBuffer): PublicKey {
          return PublicKey.decodeDataView(new DataView(buf));
        }

        // Decodes PublicKey from a DataView
        static decodeDataView(view: DataView): PublicKey {
          const decoder = new __proto.Decoder(view);
          const obj = new PublicKey();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.type = decoder.uint32();
                break;
              }
              case 2: {
                obj.bytes = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode PublicKey

        public size(): u32 {
          let size: u32 = 0;

          size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
          size +=
            this.bytes.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.bytes.length) +
                this.bytes.length
              : 0;

          return size;
        }

        // Encodes PublicKey to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes PublicKey to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.type != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.type);
          }
          if (this.bytes.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.bytes.length);
            encoder.bytes(this.bytes);
          }

          return buf;
        } // encode PublicKey
      } // PublicKey

      export class ValidatorStake {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public stake: BigInt = new BigInt();

        // Decodes ValidatorStake from an ArrayBuffer
        static decode(buf: ArrayBuffer): ValidatorStake {
          return ValidatorStake.decodeDataView(new DataView(buf));
        }

        // Decodes ValidatorStake from a DataView
        static decodeDataView(view: DataView): ValidatorStake {
          const decoder = new __proto.Decoder(view);
          const obj = new ValidatorStake();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ValidatorStake

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ValidatorStake to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ValidatorStake to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ValidatorStake
      } // ValidatorStake

      export class SlashedValidator {
        public account_id: string = "";
        public is_double_sign: bool;

        // Decodes SlashedValidator from an ArrayBuffer
        static decode(buf: ArrayBuffer): SlashedValidator {
          return SlashedValidator.decodeDataView(new DataView(buf));
        }

        // Decodes SlashedValidator from a DataView
        static decodeDataView(view: DataView): SlashedValidator {
          const decoder = new __proto.Decoder(view);
          const obj = new SlashedValidator();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.is_double_sign = decoder.bool();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SlashedValidator

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size += this.is_double_sign == 0 ? 0 : 1 + 1;

          return size;
        }

        // Encodes SlashedValidator to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SlashedValidator to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.is_double_sign != 0) {
            encoder.uint32(0x10);
            encoder.bool(this.is_double_sign);
          }

          return buf;
        } // encode SlashedValidator
      } // SlashedValidator

      export class ChunkHeader {
        public chunk_hash: Array<u8> = new Array<u8>();
        public prev_block_hash: Array<u8> = new Array<u8>();
        public outcome_root: Array<u8> = new Array<u8>();
        public prev_state_root: Array<u8> = new Array<u8>();
        public encoded_merkle_root: Array<u8> = new Array<u8>();
        public encoded_length: u64;
        public height_created: u64;
        public height_included: u64;
        public shard_id: u64;
        public gas_used: u64;
        public gas_limit: u64;
        public validator_reward: BigInt = new BigInt();
        public balance_burnt: BigInt = new BigInt();
        public outgoing_receipts_root: Array<u8> = new Array<u8>();
        public tx_root: Array<u8> = new Array<u8>();
        public validator_proposals: Array<ValidatorStake> =
          new Array<ValidatorStake>();
        public signature: Signature = new Signature();

        // Decodes ChunkHeader from an ArrayBuffer
        static decode(buf: ArrayBuffer): ChunkHeader {
          return ChunkHeader.decodeDataView(new DataView(buf));
        }

        // Decodes ChunkHeader from a DataView
        static decodeDataView(view: DataView): ChunkHeader {
          const decoder = new __proto.Decoder(view);
          const obj = new ChunkHeader();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.chunk_hash = decoder.bytes();
                break;
              }
              case 2: {
                obj.prev_block_hash = decoder.bytes();
                break;
              }
              case 3: {
                obj.outcome_root = decoder.bytes();
                break;
              }
              case 4: {
                obj.prev_state_root = decoder.bytes();
                break;
              }
              case 5: {
                obj.encoded_merkle_root = decoder.bytes();
                break;
              }
              case 6: {
                obj.encoded_length = decoder.uint64();
                break;
              }
              case 7: {
                obj.height_created = decoder.uint64();
                break;
              }
              case 8: {
                obj.height_included = decoder.uint64();
                break;
              }
              case 9: {
                obj.shard_id = decoder.uint64();
                break;
              }
              case 10: {
                obj.gas_used = decoder.uint64();
                break;
              }
              case 11: {
                obj.gas_limit = decoder.uint64();
                break;
              }
              case 12: {
                const length = decoder.uint32();
                obj.validator_reward = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 13: {
                const length = decoder.uint32();
                obj.balance_burnt = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 14: {
                obj.outgoing_receipts_root = decoder.bytes();
                break;
              }
              case 15: {
                obj.tx_root = decoder.bytes();
                break;
              }
              case 16: {
                const length = decoder.uint32();
                obj.validator_proposals.push(
                  ValidatorStake.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 17: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ChunkHeader

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.chunk_hash.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.chunk_hash.length) +
                this.chunk_hash.length
              : 0;
          size +=
            this.prev_block_hash.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.prev_block_hash.length) +
                this.prev_block_hash.length
              : 0;
          size +=
            this.outcome_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.outcome_root.length) +
                this.outcome_root.length
              : 0;
          size +=
            this.prev_state_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.prev_state_root.length) +
                this.prev_state_root.length
              : 0;
          size +=
            this.encoded_merkle_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.encoded_merkle_root.length) +
                this.encoded_merkle_root.length
              : 0;
          size +=
            this.encoded_length == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.encoded_length);
          size +=
            this.height_created == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.height_created);
          size +=
            this.height_included == 0
              ? 0
              : 1 + __proto.Sizer.uint64(this.height_included);
          size +=
            this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);
          size +=
            this.gas_used == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_used);
          size +=
            this.gas_limit == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_limit);

          if (this.validator_reward != null) {
            const f: BigInt = this.validator_reward as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.balance_burnt != null) {
            const f: BigInt = this.balance_burnt as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.outgoing_receipts_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.outgoing_receipts_root.length) +
                this.outgoing_receipts_root.length
              : 0;
          size +=
            this.tx_root.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.tx_root.length) +
                this.tx_root.length
              : 0;

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ChunkHeader to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ChunkHeader to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.chunk_hash.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.chunk_hash.length);
            encoder.bytes(this.chunk_hash);
          }
          if (this.prev_block_hash.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.prev_block_hash.length);
            encoder.bytes(this.prev_block_hash);
          }
          if (this.outcome_root.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.outcome_root.length);
            encoder.bytes(this.outcome_root);
          }
          if (this.prev_state_root.length > 0) {
            encoder.uint32(0x22);
            encoder.uint32(this.prev_state_root.length);
            encoder.bytes(this.prev_state_root);
          }
          if (this.encoded_merkle_root.length > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(this.encoded_merkle_root.length);
            encoder.bytes(this.encoded_merkle_root);
          }
          if (this.encoded_length != 0) {
            encoder.uint32(0x30);
            encoder.uint64(this.encoded_length);
          }
          if (this.height_created != 0) {
            encoder.uint32(0x38);
            encoder.uint64(this.height_created);
          }
          if (this.height_included != 0) {
            encoder.uint32(0x40);
            encoder.uint64(this.height_included);
          }
          if (this.shard_id != 0) {
            encoder.uint32(0x48);
            encoder.uint64(this.shard_id);
          }
          if (this.gas_used != 0) {
            encoder.uint32(0x50);
            encoder.uint64(this.gas_used);
          }
          if (this.gas_limit != 0) {
            encoder.uint32(0x58);
            encoder.uint64(this.gas_limit);
          }

          if (this.validator_reward != null) {
            const f = this.validator_reward as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x62);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.balance_burnt != null) {
            const f = this.balance_burnt as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x6a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outgoing_receipts_root.length > 0) {
            encoder.uint32(0x72);
            encoder.uint32(this.outgoing_receipts_root.length);
            encoder.bytes(this.outgoing_receipts_root);
          }
          if (this.tx_root.length > 0) {
            encoder.uint32(0x7a);
            encoder.uint32(this.tx_root.length);
            encoder.bytes(this.tx_root);
          }

          for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
            const messageSize = this.validator_proposals[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x82);
              encoder.uint32(messageSize);
              this.validator_proposals[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x8a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ChunkHeader
      } // ChunkHeader

      export class IndexerShard {
        public shard_id: u64;
        public chunk: IndexerChunk = new IndexerChunk();
        public receipt_execution_outcomes: Array<IndexerExecutionOutcomeWithReceipt> =
          new Array<IndexerExecutionOutcomeWithReceipt>();

        // Decodes IndexerShard from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerShard {
          return IndexerShard.decodeDataView(new DataView(buf));
        }

        // Decodes IndexerShard from a DataView
        static decodeDataView(view: DataView): IndexerShard {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerShard();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.shard_id = decoder.uint64();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.chunk = IndexerChunk.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.receipt_execution_outcomes.push(
                  IndexerExecutionOutcomeWithReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerShard

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);

          if (this.chunk != null) {
            const f: IndexerChunk = this.chunk as IndexerChunk;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (
            let n: i32 = 0;
            n < this.receipt_execution_outcomes.length;
            n++
          ) {
            const messageSize = this.receipt_execution_outcomes[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerShard to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerShard to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.shard_id != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.shard_id);
          }

          if (this.chunk != null) {
            const f = this.chunk as IndexerChunk;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (
            let n: i32 = 0;
            n < this.receipt_execution_outcomes.length;
            n++
          ) {
            const messageSize = this.receipt_execution_outcomes[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.receipt_execution_outcomes[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerShard
      } // IndexerShard

      export class IndexerExecutionOutcomeWithReceipt {
        public execution_outcome: ExecutionOutcomeWithId =
          new ExecutionOutcomeWithId();
        public receipt: Receipt = new Receipt();

        // Decodes IndexerExecutionOutcomeWithReceipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerExecutionOutcomeWithReceipt {
          return IndexerExecutionOutcomeWithReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerExecutionOutcomeWithReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): IndexerExecutionOutcomeWithReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerExecutionOutcomeWithReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt = Receipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerExecutionOutcomeWithReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.execution_outcome != null) {
            const f: ExecutionOutcomeWithId = this
              .execution_outcome as ExecutionOutcomeWithId;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt != null) {
            const f: Receipt = this.receipt as Receipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerExecutionOutcomeWithReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerExecutionOutcomeWithReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.execution_outcome != null) {
            const f = this.execution_outcome as ExecutionOutcomeWithId;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt != null) {
            const f = this.receipt as Receipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerExecutionOutcomeWithReceipt
      } // IndexerExecutionOutcomeWithReceipt

      export class IndexerChunk {
        public author: string = "";
        public header: ChunkHeader = new ChunkHeader();
        public transactions: Array<IndexerTransactionWithOutcome> =
          new Array<IndexerTransactionWithOutcome>();
        public receipts: Array<Receipt> = new Array<Receipt>();

        // Decodes IndexerChunk from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerChunk {
          return IndexerChunk.decodeDataView(new DataView(buf));
        }

        // Decodes IndexerChunk from a DataView
        static decodeDataView(view: DataView): IndexerChunk {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerChunk();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.author = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.header = ChunkHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.transactions.push(
                  IndexerTransactionWithOutcome.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.receipts.push(
                  Receipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerChunk

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.author.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.author.length) +
                this.author.length
              : 0;

          if (this.header != null) {
            const f: ChunkHeader = this.header as ChunkHeader;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.transactions.length; n++) {
            const messageSize = this.transactions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.receipts.length; n++) {
            const messageSize = this.receipts[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerChunk to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerChunk to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.author.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.author.length);
            encoder.string(this.author);
          }

          if (this.header != null) {
            const f = this.header as ChunkHeader;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.transactions.length; n++) {
            const messageSize = this.transactions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              this.transactions[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.receipts.length; n++) {
            const messageSize = this.receipts[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.receipts[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerChunk
      } // IndexerChunk

      export class IndexerTransactionWithOutcome {
        public transaction: SignedTransaction = new SignedTransaction();
        public outcome: IndexerExecutionOutcomeWithOptionalReceipt =
          new IndexerExecutionOutcomeWithOptionalReceipt();

        // Decodes IndexerTransactionWithOutcome from an ArrayBuffer
        static decode(buf: ArrayBuffer): IndexerTransactionWithOutcome {
          return IndexerTransactionWithOutcome.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerTransactionWithOutcome from a DataView
        static decodeDataView(view: DataView): IndexerTransactionWithOutcome {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerTransactionWithOutcome();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.transaction = SignedTransaction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.outcome =
                  IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerTransactionWithOutcome

        public size(): u32 {
          let size: u32 = 0;

          if (this.transaction != null) {
            const f: SignedTransaction = this.transaction as SignedTransaction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome != null) {
            const f: IndexerExecutionOutcomeWithOptionalReceipt = this
              .outcome as IndexerExecutionOutcomeWithOptionalReceipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerTransactionWithOutcome to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerTransactionWithOutcome to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.transaction != null) {
            const f = this.transaction as SignedTransaction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome != null) {
            const f = this
              .outcome as IndexerExecutionOutcomeWithOptionalReceipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerTransactionWithOutcome
      } // IndexerTransactionWithOutcome

      export class SignedTransaction {
        public signer_id: string = "";
        public public_key: PublicKey = new PublicKey();
        public nonce: u64;
        public receiver_id: string = "";
        public actions: Array<Action> = new Array<Action>();
        public signature: Signature = new Signature();
        public hash: CryptoHash = new CryptoHash();

        // Decodes SignedTransaction from an ArrayBuffer
        static decode(buf: ArrayBuffer): SignedTransaction {
          return SignedTransaction.decodeDataView(new DataView(buf));
        }

        // Decodes SignedTransaction from a DataView
        static decodeDataView(view: DataView): SignedTransaction {
          const decoder = new __proto.Decoder(view);
          const obj = new SignedTransaction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.signer_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                obj.nonce = decoder.uint64();
                break;
              }
              case 4: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.actions.push(
                  Action.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.signature = Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SignedTransaction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.signer_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.signer_id.length) +
                this.signer_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);
          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.signature != null) {
            const f: Signature = this.signature as Signature;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes SignedTransaction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SignedTransaction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.signer_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.signer_id.length);
            encoder.string(this.signer_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.nonce != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.nonce);
          }
          if (this.receiver_id.length > 0) {
            encoder.uint32(0x22);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.actions[n].encodeU8Array(encoder);
            }
          }

          if (this.signature != null) {
            const f = this.signature as Signature;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode SignedTransaction
      } // SignedTransaction

      export class IndexerExecutionOutcomeWithOptionalReceipt {
        public execution_outcome: ExecutionOutcomeWithId =
          new ExecutionOutcomeWithId();
        public receipt: Receipt = new Receipt();

        // Decodes IndexerExecutionOutcomeWithOptionalReceipt from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): IndexerExecutionOutcomeWithOptionalReceipt {
          return IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes IndexerExecutionOutcomeWithOptionalReceipt from a DataView
        static decodeDataView(
          view: DataView
        ): IndexerExecutionOutcomeWithOptionalReceipt {
          const decoder = new __proto.Decoder(view);
          const obj = new IndexerExecutionOutcomeWithOptionalReceipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt = Receipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode IndexerExecutionOutcomeWithOptionalReceipt

        public size(): u32 {
          let size: u32 = 0;

          if (this.execution_outcome != null) {
            const f: ExecutionOutcomeWithId = this
              .execution_outcome as ExecutionOutcomeWithId;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.receipt != null) {
            const f: Receipt = this.receipt as Receipt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.execution_outcome != null) {
            const f = this.execution_outcome as ExecutionOutcomeWithId;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receipt != null) {
            const f = this.receipt as Receipt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode IndexerExecutionOutcomeWithOptionalReceipt
      } // IndexerExecutionOutcomeWithOptionalReceipt

      export class Receipt {
        public predecessor_id: string = "";
        public receiver_id: string = "";
        public receipt_id: CryptoHash = new CryptoHash();
        public action: ReceiptAction | null;
        public data: ReceiptData | null;

        public __receipt: string = "";
        public __receipt_index: u8 = 0;

        static readonly RECEIPT_ACTION_INDEX: u8 = 10;
        static readonly RECEIPT_DATA_INDEX: u8 = 11;

        // Decodes Receipt from an ArrayBuffer
        static decode(buf: ArrayBuffer): Receipt {
          return Receipt.decodeDataView(new DataView(buf));
        }

        // Decodes Receipt from a DataView
        static decodeDataView(view: DataView): Receipt {
          const decoder = new __proto.Decoder(view);
          const obj = new Receipt();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.predecessor_id = decoder.string();
                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.receipt_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 10: {
                const length = decoder.uint32();
                obj.action = ReceiptAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__receipt = "action";
                obj.__receipt_index = 10;
                break;
              }
              case 11: {
                const length = decoder.uint32();
                obj.data = ReceiptData.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__receipt = "data";
                obj.__receipt_index = 11;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Receipt

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;
          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          if (this.receipt_id != null) {
            const f: CryptoHash = this.receipt_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.action != null) {
            const f: ReceiptAction = this.action as ReceiptAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.data != null) {
            const f: ReceiptData = this.data as ReceiptData;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Receipt to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Receipt to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.predecessor_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }
          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          if (this.receipt_id != null) {
            const f = this.receipt_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.action != null) {
            const f = this.action as ReceiptAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x52);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data != null) {
            const f = this.data as ReceiptData;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x5a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Receipt
      } // Receipt

      export class ReceiptData {
        public data_id: CryptoHash = new CryptoHash();
        public data: Array<u8> = new Array<u8>();

        // Decodes ReceiptData from an ArrayBuffer
        static decode(buf: ArrayBuffer): ReceiptData {
          return ReceiptData.decodeDataView(new DataView(buf));
        }

        // Decodes ReceiptData from a DataView
        static decodeDataView(view: DataView): ReceiptData {
          const decoder = new __proto.Decoder(view);
          const obj = new ReceiptData();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.data_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.data = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ReceiptData

        public size(): u32 {
          let size: u32 = 0;

          if (this.data_id != null) {
            const f: CryptoHash = this.data_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.data.length > 0
              ? 1 + __proto.Sizer.varint64(this.data.length) + this.data.length
              : 0;

          return size;
        }

        // Encodes ReceiptData to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ReceiptData to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.data_id != null) {
            const f = this.data_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.data.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.data.length);
            encoder.bytes(this.data);
          }

          return buf;
        } // encode ReceiptData
      } // ReceiptData

      export class ReceiptAction {
        public signer_id: string = "";
        public signer_public_key: PublicKey = new PublicKey();
        public gas_price: BigInt = new BigInt();
        public output_data_receivers: Array<DataReceiver> =
          new Array<DataReceiver>();
        public input_data_ids: Array<CryptoHash> = new Array<CryptoHash>();
        public actions: Array<Action> = new Array<Action>();

        // Decodes ReceiptAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): ReceiptAction {
          return ReceiptAction.decodeDataView(new DataView(buf));
        }

        // Decodes ReceiptAction from a DataView
        static decodeDataView(view: DataView): ReceiptAction {
          const decoder = new __proto.Decoder(view);
          const obj = new ReceiptAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.signer_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.signer_public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.gas_price = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.output_data_receivers.push(
                  DataReceiver.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.input_data_ids.push(
                  CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.actions.push(
                  Action.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ReceiptAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.signer_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.signer_id.length) +
                this.signer_id.length
              : 0;

          if (this.signer_public_key != null) {
            const f: PublicKey = this.signer_public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.gas_price != null) {
            const f: BigInt = this.gas_price as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
            const messageSize = this.output_data_receivers[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
            const messageSize = this.input_data_ids[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ReceiptAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ReceiptAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.signer_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.signer_id.length);
            encoder.string(this.signer_id);
          }

          if (this.signer_public_key != null) {
            const f = this.signer_public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.gas_price != null) {
            const f = this.gas_price as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
            const messageSize = this.output_data_receivers[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              this.output_data_receivers[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
            const messageSize = this.input_data_ids[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              this.input_data_ids[n].encodeU8Array(encoder);
            }
          }

          for (let n: i32 = 0; n < this.actions.length; n++) {
            const messageSize = this.actions[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              this.actions[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ReceiptAction
      } // ReceiptAction

      export class DataReceiver {
        public data_id: CryptoHash = new CryptoHash();
        public receiver_id: string = "";

        // Decodes DataReceiver from an ArrayBuffer
        static decode(buf: ArrayBuffer): DataReceiver {
          return DataReceiver.decodeDataView(new DataView(buf));
        }

        // Decodes DataReceiver from a DataView
        static decodeDataView(view: DataView): DataReceiver {
          const decoder = new __proto.Decoder(view);
          const obj = new DataReceiver();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.data_id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DataReceiver

        public size(): u32 {
          let size: u32 = 0;

          if (this.data_id != null) {
            const f: CryptoHash = this.data_id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          return size;
        }

        // Encodes DataReceiver to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DataReceiver to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.data_id != null) {
            const f = this.data_id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          return buf;
        } // encode DataReceiver
      } // DataReceiver

      export class ExecutionOutcomeWithId {
        public proof: MerklePath = new MerklePath();
        public block_hash: CryptoHash = new CryptoHash();
        public id: CryptoHash = new CryptoHash();
        public outcome: ExecutionOutcome = new ExecutionOutcome();

        // Decodes ExecutionOutcomeWithId from an ArrayBuffer
        static decode(buf: ArrayBuffer): ExecutionOutcomeWithId {
          return ExecutionOutcomeWithId.decodeDataView(new DataView(buf));
        }

        // Decodes ExecutionOutcomeWithId from a DataView
        static decodeDataView(view: DataView): ExecutionOutcomeWithId {
          const decoder = new __proto.Decoder(view);
          const obj = new ExecutionOutcomeWithId();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.proof = MerklePath.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.block_hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.outcome = ExecutionOutcome.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ExecutionOutcomeWithId

        public size(): u32 {
          let size: u32 = 0;

          if (this.proof != null) {
            const f: MerklePath = this.proof as MerklePath;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.block_hash != null) {
            const f: CryptoHash = this.block_hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.id != null) {
            const f: CryptoHash = this.id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.outcome != null) {
            const f: ExecutionOutcome = this.outcome as ExecutionOutcome;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ExecutionOutcomeWithId to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ExecutionOutcomeWithId to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.proof != null) {
            const f = this.proof as MerklePath;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.block_hash != null) {
            const f = this.block_hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.id != null) {
            const f = this.id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.outcome != null) {
            const f = this.outcome as ExecutionOutcome;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ExecutionOutcomeWithId
      } // ExecutionOutcomeWithId

      export class ExecutionOutcome {
        public logs: Array<string> = new Array<string>();
        public receipt_ids: Array<CryptoHash> = new Array<CryptoHash>();
        public gas_burnt: u64;
        public tokens_burnt: BigInt = new BigInt();
        public executor_id: string = "";
        public unknown: UnknownExecutionStatus | null;
        public failure: FailureExecutionStatus | null;
        public success_value: SuccessValueExecutionStatus | null;
        public success_receipt_id: SuccessReceiptIdExecutionStatus | null;
        public metadata: u32;

        public __status: string = "";
        public __status_index: u8 = 0;

        static readonly STATUS_UNKNOWN_INDEX: u8 = 20;
        static readonly STATUS_FAILURE_INDEX: u8 = 21;
        static readonly STATUS_SUCCESS_VALUE_INDEX: u8 = 22;
        static readonly STATUS_SUCCESS_RECEIPT_ID_INDEX: u8 = 23;

        // Decodes ExecutionOutcome from an ArrayBuffer
        static decode(buf: ArrayBuffer): ExecutionOutcome {
          return ExecutionOutcome.decodeDataView(new DataView(buf));
        }

        // Decodes ExecutionOutcome from a DataView
        static decodeDataView(view: DataView): ExecutionOutcome {
          const decoder = new __proto.Decoder(view);
          const obj = new ExecutionOutcome();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.logs.push(decoder.string());
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.receipt_ids.push(
                  CryptoHash.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                obj.gas_burnt = decoder.uint64();
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.tokens_burnt = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 5: {
                obj.executor_id = decoder.string();
                break;
              }
              case 20: {
                const length = decoder.uint32();
                obj.unknown = UnknownExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "unknown";
                obj.__status_index = 20;
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.failure = FailureExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "failure";
                obj.__status_index = 21;
                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.success_value = SuccessValueExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__status = "success_value";
                obj.__status_index = 22;
                break;
              }
              case 23: {
                const length = decoder.uint32();
                obj.success_receipt_id =
                  SuccessReceiptIdExecutionStatus.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__status = "success_receipt_id";
                obj.__status_index = 23;
                break;
              }
              case 6: {
                obj.metadata = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ExecutionOutcome

        public size(): u32 {
          let size: u32 = 0;

          size += __size_string_repeated(this.logs);

          for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
            const messageSize = this.receipt_ids[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.gas_burnt == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_burnt);

          if (this.tokens_burnt != null) {
            const f: BigInt = this.tokens_burnt as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.executor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.executor_id.length) +
                this.executor_id.length
              : 0;

          if (this.unknown != null) {
            const f: UnknownExecutionStatus = this
              .unknown as UnknownExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.failure != null) {
            const f: FailureExecutionStatus = this
              .failure as FailureExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.success_value != null) {
            const f: SuccessValueExecutionStatus = this
              .success_value as SuccessValueExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.success_receipt_id != null) {
            const f: SuccessReceiptIdExecutionStatus = this
              .success_receipt_id as SuccessReceiptIdExecutionStatus;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.metadata == 0 ? 0 : 1 + __proto.Sizer.uint32(this.metadata);

          return size;
        }

        // Encodes ExecutionOutcome to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ExecutionOutcome to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.logs.length > 0) {
            for (let n: i32 = 0; n < this.logs.length; n++) {
              encoder.uint32(0xa);
              encoder.uint32(this.logs[n].length);
              encoder.string(this.logs[n]);
            }
          }

          for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
            const messageSize = this.receipt_ids[n].size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              this.receipt_ids[n].encodeU8Array(encoder);
            }
          }

          if (this.gas_burnt != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.gas_burnt);
          }

          if (this.tokens_burnt != null) {
            const f = this.tokens_burnt as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.executor_id.length > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(this.executor_id.length);
            encoder.string(this.executor_id);
          }

          if (this.unknown != null) {
            const f = this.unknown as UnknownExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.failure != null) {
            const f = this.failure as FailureExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.success_value != null) {
            const f = this.success_value as SuccessValueExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.success_receipt_id != null) {
            const f = this
              .success_receipt_id as SuccessReceiptIdExecutionStatus;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xba);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.metadata != 0) {
            encoder.uint32(0x30);
            encoder.uint32(this.metadata);
          }

          return buf;
        } // encode ExecutionOutcome
      } // ExecutionOutcome

      export class SuccessValueExecutionStatus {
        public value: Array<u8> = new Array<u8>();

        // Decodes SuccessValueExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): SuccessValueExecutionStatus {
          return SuccessValueExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes SuccessValueExecutionStatus from a DataView
        static decodeDataView(view: DataView): SuccessValueExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new SuccessValueExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.value = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SuccessValueExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.value.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.value.length) +
                this.value.length
              : 0;

          return size;
        }

        // Encodes SuccessValueExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SuccessValueExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.value.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.value.length);
            encoder.bytes(this.value);
          }

          return buf;
        } // encode SuccessValueExecutionStatus
      } // SuccessValueExecutionStatus

      export class SuccessReceiptIdExecutionStatus {
        public id: CryptoHash = new CryptoHash();

        // Decodes SuccessReceiptIdExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): SuccessReceiptIdExecutionStatus {
          return SuccessReceiptIdExecutionStatus.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes SuccessReceiptIdExecutionStatus from a DataView
        static decodeDataView(view: DataView): SuccessReceiptIdExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new SuccessReceiptIdExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.id = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode SuccessReceiptIdExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          if (this.id != null) {
            const f: CryptoHash = this.id as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes SuccessReceiptIdExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes SuccessReceiptIdExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.id != null) {
            const f = this.id as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode SuccessReceiptIdExecutionStatus
      } // SuccessReceiptIdExecutionStatus

      export class UnknownExecutionStatus {
        // Decodes UnknownExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): UnknownExecutionStatus {
          return UnknownExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes UnknownExecutionStatus from a DataView
        static decodeDataView(view: DataView): UnknownExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new UnknownExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode UnknownExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes UnknownExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes UnknownExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode UnknownExecutionStatus
      } // UnknownExecutionStatus

      export class FailureExecutionStatus {
        public action_error: ActionError | null;
        public invalid_tx_error: u32;

        public __failure: string = "";
        public __failure_index: u8 = 0;

        static readonly FAILURE_ACTION_ERROR_INDEX: u8 = 1;
        static readonly FAILURE_INVALID_TX_ERROR_INDEX: u8 = 2;

        // Decodes FailureExecutionStatus from an ArrayBuffer
        static decode(buf: ArrayBuffer): FailureExecutionStatus {
          return FailureExecutionStatus.decodeDataView(new DataView(buf));
        }

        // Decodes FailureExecutionStatus from a DataView
        static decodeDataView(view: DataView): FailureExecutionStatus {
          const decoder = new __proto.Decoder(view);
          const obj = new FailureExecutionStatus();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.action_error = ActionError.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__failure = "action_error";
                obj.__failure_index = 1;
                break;
              }
              case 2: {
                obj.invalid_tx_error = decoder.uint32();
                obj.__failure = "invalid_tx_error";
                obj.__failure_index = 2;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FailureExecutionStatus

        public size(): u32 {
          let size: u32 = 0;

          if (this.action_error != null) {
            const f: ActionError = this.action_error as ActionError;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.invalid_tx_error == 0
              ? 0
              : 1 + __proto.Sizer.uint32(this.invalid_tx_error);

          return size;
        }

        // Encodes FailureExecutionStatus to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FailureExecutionStatus to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.action_error != null) {
            const f = this.action_error as ActionError;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.invalid_tx_error != 0) {
            encoder.uint32(0x10);
            encoder.uint32(this.invalid_tx_error);
          }

          return buf;
        } // encode FailureExecutionStatus
      } // FailureExecutionStatus

      export class ActionError {
        public index: u64;
        public account_already_exist: AccountAlreadyExistsErrorKind | null;
        public account_does_not_exist: AccountDoesNotExistErrorKind | null;
        public create_account_only_by_registrar: CreateAccountOnlyByRegistrarErrorKind | null;
        public create_account_not_allowed: CreateAccountNotAllowedErrorKind | null;
        public actor_no_permission: ActorNoPermissionErrorKind | null;
        public delete_key_does_not_exist: DeleteKeyDoesNotExistErrorKind | null;
        public add_key_already_exists: AddKeyAlreadyExistsErrorKind | null;
        public delete_account_staking: DeleteAccountStakingErrorKind | null;
        public lack_balance_for_state: LackBalanceForStateErrorKind | null;
        public tries_to_unstake: TriesToUnstakeErrorKind | null;
        public tries_to_stake: TriesToStakeErrorKind | null;
        public insufficient_stake: InsufficientStakeErrorKind | null;
        public function_call: FunctionCallErrorKind | null;
        public new_receipt_validation: NewReceiptValidationErrorKind | null;
        public only_implicit_account_creation_allowed: OnlyImplicitAccountCreationAllowedErrorKind | null;
        public delete_account_with_large_state: DeleteAccountWithLargeStateErrorKind | null;

        public __kind: string = "";
        public __kind_index: u8 = 0;

        static readonly KIND_ACCOUNT_ALREADY_EXIST_INDEX: u8 = 21;
        static readonly KIND_ACCOUNT_DOES_NOT_EXIST_INDEX: u8 = 22;
        static readonly KIND_CREATE_ACCOUNT_ONLY_BY_REGISTRAR_INDEX: u8 = 23;
        static readonly KIND_CREATE_ACCOUNT_NOT_ALLOWED_INDEX: u8 = 24;
        static readonly KIND_ACTOR_NO_PERMISSION_INDEX: u8 = 25;
        static readonly KIND_DELETE_KEY_DOES_NOT_EXIST_INDEX: u8 = 26;
        static readonly KIND_ADD_KEY_ALREADY_EXISTS_INDEX: u8 = 27;
        static readonly KIND_DELETE_ACCOUNT_STAKING_INDEX: u8 = 28;
        static readonly KIND_LACK_BALANCE_FOR_STATE_INDEX: u8 = 29;
        static readonly KIND_TRIES_TO_UNSTAKE_INDEX: u8 = 30;
        static readonly KIND_TRIES_TO_STAKE_INDEX: u8 = 31;
        static readonly KIND_INSUFFICIENT_STAKE_INDEX: u8 = 32;
        static readonly KIND_FUNCTION_CALL_INDEX: u8 = 33;
        static readonly KIND_NEW_RECEIPT_VALIDATION_INDEX: u8 = 34;
        static readonly KIND_ONLY_IMPLICIT_ACCOUNT_CREATION_ALLOWED_INDEX: u8 = 35;
        static readonly KIND_DELETE_ACCOUNT_WITH_LARGE_STATE_INDEX: u8 = 36;

        // Decodes ActionError from an ArrayBuffer
        static decode(buf: ArrayBuffer): ActionError {
          return ActionError.decodeDataView(new DataView(buf));
        }

        // Decodes ActionError from a DataView
        static decodeDataView(view: DataView): ActionError {
          const decoder = new __proto.Decoder(view);
          const obj = new ActionError();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.index = decoder.uint64();
                break;
              }
              case 21: {
                const length = decoder.uint32();
                obj.account_already_exist =
                  AccountAlreadyExistsErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "account_already_exist";
                obj.__kind_index = 21;
                break;
              }
              case 22: {
                const length = decoder.uint32();
                obj.account_does_not_exist =
                  AccountDoesNotExistErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "account_does_not_exist";
                obj.__kind_index = 22;
                break;
              }
              case 23: {
                const length = decoder.uint32();
                obj.create_account_only_by_registrar =
                  CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "create_account_only_by_registrar";
                obj.__kind_index = 23;
                break;
              }
              case 24: {
                const length = decoder.uint32();
                obj.create_account_not_allowed =
                  CreateAccountNotAllowedErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "create_account_not_allowed";
                obj.__kind_index = 24;
                break;
              }
              case 25: {
                const length = decoder.uint32();
                obj.actor_no_permission =
                  ActorNoPermissionErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "actor_no_permission";
                obj.__kind_index = 25;
                break;
              }
              case 26: {
                const length = decoder.uint32();
                obj.delete_key_does_not_exist =
                  DeleteKeyDoesNotExistErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_key_does_not_exist";
                obj.__kind_index = 26;
                break;
              }
              case 27: {
                const length = decoder.uint32();
                obj.add_key_already_exists =
                  AddKeyAlreadyExistsErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "add_key_already_exists";
                obj.__kind_index = 27;
                break;
              }
              case 28: {
                const length = decoder.uint32();
                obj.delete_account_staking =
                  DeleteAccountStakingErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_account_staking";
                obj.__kind_index = 28;
                break;
              }
              case 29: {
                const length = decoder.uint32();
                obj.lack_balance_for_state =
                  LackBalanceForStateErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "lack_balance_for_state";
                obj.__kind_index = 29;
                break;
              }
              case 30: {
                const length = decoder.uint32();
                obj.tries_to_unstake = TriesToUnstakeErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "tries_to_unstake";
                obj.__kind_index = 30;
                break;
              }
              case 31: {
                const length = decoder.uint32();
                obj.tries_to_stake = TriesToStakeErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "tries_to_stake";
                obj.__kind_index = 31;
                break;
              }
              case 32: {
                const length = decoder.uint32();
                obj.insufficient_stake =
                  InsufficientStakeErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "insufficient_stake";
                obj.__kind_index = 32;
                break;
              }
              case 33: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__kind = "function_call";
                obj.__kind_index = 33;
                break;
              }
              case 34: {
                const length = decoder.uint32();
                obj.new_receipt_validation =
                  NewReceiptValidationErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "new_receipt_validation";
                obj.__kind_index = 34;
                break;
              }
              case 35: {
                const length = decoder.uint32();
                obj.only_implicit_account_creation_allowed =
                  OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "only_implicit_account_creation_allowed";
                obj.__kind_index = 35;
                break;
              }
              case 36: {
                const length = decoder.uint32();
                obj.delete_account_with_large_state =
                  DeleteAccountWithLargeStateErrorKind.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  );
                decoder.skip(length);

                obj.__kind = "delete_account_with_large_state";
                obj.__kind_index = 36;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ActionError

        public size(): u32 {
          let size: u32 = 0;

          size += this.index == 0 ? 0 : 1 + __proto.Sizer.uint64(this.index);

          if (this.account_already_exist != null) {
            const f: AccountAlreadyExistsErrorKind = this
              .account_already_exist as AccountAlreadyExistsErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.account_does_not_exist != null) {
            const f: AccountDoesNotExistErrorKind = this
              .account_does_not_exist as AccountDoesNotExistErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.create_account_only_by_registrar != null) {
            const f: CreateAccountOnlyByRegistrarErrorKind = this
              .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.create_account_not_allowed != null) {
            const f: CreateAccountNotAllowedErrorKind = this
              .create_account_not_allowed as CreateAccountNotAllowedErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.actor_no_permission != null) {
            const f: ActorNoPermissionErrorKind = this
              .actor_no_permission as ActorNoPermissionErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_key_does_not_exist != null) {
            const f: DeleteKeyDoesNotExistErrorKind = this
              .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.add_key_already_exists != null) {
            const f: AddKeyAlreadyExistsErrorKind = this
              .add_key_already_exists as AddKeyAlreadyExistsErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account_staking != null) {
            const f: DeleteAccountStakingErrorKind = this
              .delete_account_staking as DeleteAccountStakingErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.lack_balance_for_state != null) {
            const f: LackBalanceForStateErrorKind = this
              .lack_balance_for_state as LackBalanceForStateErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.tries_to_unstake != null) {
            const f: TriesToUnstakeErrorKind = this
              .tries_to_unstake as TriesToUnstakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.tries_to_stake != null) {
            const f: TriesToStakeErrorKind = this
              .tries_to_stake as TriesToStakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.insufficient_stake != null) {
            const f: InsufficientStakeErrorKind = this
              .insufficient_stake as InsufficientStakeErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.function_call != null) {
            const f: FunctionCallErrorKind = this
              .function_call as FunctionCallErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.new_receipt_validation != null) {
            const f: NewReceiptValidationErrorKind = this
              .new_receipt_validation as NewReceiptValidationErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.only_implicit_account_creation_allowed != null) {
            const f: OnlyImplicitAccountCreationAllowedErrorKind = this
              .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account_with_large_state != null) {
            const f: DeleteAccountWithLargeStateErrorKind = this
              .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes ActionError to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ActionError to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.index != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.index);
          }

          if (this.account_already_exist != null) {
            const f = this
              .account_already_exist as AccountAlreadyExistsErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xaa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.account_does_not_exist != null) {
            const f = this
              .account_does_not_exist as AccountDoesNotExistErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xb2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.create_account_only_by_registrar != null) {
            const f = this
              .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xba);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.create_account_not_allowed != null) {
            const f = this
              .create_account_not_allowed as CreateAccountNotAllowedErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xc2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.actor_no_permission != null) {
            const f = this.actor_no_permission as ActorNoPermissionErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xca);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_key_does_not_exist != null) {
            const f = this
              .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xd2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.add_key_already_exists != null) {
            const f = this
              .add_key_already_exists as AddKeyAlreadyExistsErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xda);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account_staking != null) {
            const f = this
              .delete_account_staking as DeleteAccountStakingErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xe2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.lack_balance_for_state != null) {
            const f = this
              .lack_balance_for_state as LackBalanceForStateErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xea);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.tries_to_unstake != null) {
            const f = this.tries_to_unstake as TriesToUnstakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xf2);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.tries_to_stake != null) {
            const f = this.tries_to_stake as TriesToStakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xfa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.insufficient_stake != null) {
            const f = this.insufficient_stake as InsufficientStakeErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x102);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x10a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.new_receipt_validation != null) {
            const f = this
              .new_receipt_validation as NewReceiptValidationErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x112);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.only_implicit_account_creation_allowed != null) {
            const f = this
              .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x11a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account_with_large_state != null) {
            const f = this
              .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x122);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode ActionError
      } // ActionError

      export class AccountAlreadyExistsErrorKind {
        public account_id: string = "";

        // Decodes AccountAlreadyExistsErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccountAlreadyExistsErrorKind {
          return AccountAlreadyExistsErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes AccountAlreadyExistsErrorKind from a DataView
        static decodeDataView(view: DataView): AccountAlreadyExistsErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AccountAlreadyExistsErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccountAlreadyExistsErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes AccountAlreadyExistsErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccountAlreadyExistsErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode AccountAlreadyExistsErrorKind
      } // AccountAlreadyExistsErrorKind

      export class AccountDoesNotExistErrorKind {
        public account_id: string = "";

        // Decodes AccountDoesNotExistErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccountDoesNotExistErrorKind {
          return AccountDoesNotExistErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes AccountDoesNotExistErrorKind from a DataView
        static decodeDataView(view: DataView): AccountDoesNotExistErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AccountDoesNotExistErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccountDoesNotExistErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes AccountDoesNotExistErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccountDoesNotExistErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode AccountDoesNotExistErrorKind
      } // AccountDoesNotExistErrorKind

      // / A top-level account ID can only be created by registrar.
      export class CreateAccountOnlyByRegistrarErrorKind {
        public account_id: string = "";
        public registrar_account_id: string = "";
        public predecessor_id: string = "";

        // Decodes CreateAccountOnlyByRegistrarErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountOnlyByRegistrarErrorKind {
          return CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes CreateAccountOnlyByRegistrarErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): CreateAccountOnlyByRegistrarErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountOnlyByRegistrarErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.registrar_account_id = decoder.string();
                break;
              }
              case 3: {
                obj.predecessor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountOnlyByRegistrarErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.registrar_account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.registrar_account_id.length) +
                this.registrar_account_id.length
              : 0;
          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;

          return size;
        }

        // Encodes CreateAccountOnlyByRegistrarErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountOnlyByRegistrarErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.registrar_account_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.registrar_account_id.length);
            encoder.string(this.registrar_account_id);
          }
          if (this.predecessor_id.length > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }

          return buf;
        } // encode CreateAccountOnlyByRegistrarErrorKind
      } // CreateAccountOnlyByRegistrarErrorKind

      export class CreateAccountNotAllowedErrorKind {
        public account_id: string = "";
        public predecessor_id: string = "";

        // Decodes CreateAccountNotAllowedErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountNotAllowedErrorKind {
          return CreateAccountNotAllowedErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes CreateAccountNotAllowedErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): CreateAccountNotAllowedErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountNotAllowedErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.predecessor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountNotAllowedErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.predecessor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.predecessor_id.length) +
                this.predecessor_id.length
              : 0;

          return size;
        }

        // Encodes CreateAccountNotAllowedErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountNotAllowedErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.predecessor_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.predecessor_id.length);
            encoder.string(this.predecessor_id);
          }

          return buf;
        } // encode CreateAccountNotAllowedErrorKind
      } // CreateAccountNotAllowedErrorKind

      export class ActorNoPermissionErrorKind {
        public account_id: string = "";
        public actor_id: string = "";

        // Decodes ActorNoPermissionErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): ActorNoPermissionErrorKind {
          return ActorNoPermissionErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes ActorNoPermissionErrorKind from a DataView
        static decodeDataView(view: DataView): ActorNoPermissionErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new ActorNoPermissionErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                obj.actor_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode ActorNoPermissionErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;
          size +=
            this.actor_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.actor_id.length) +
                this.actor_id.length
              : 0;

          return size;
        }

        // Encodes ActorNoPermissionErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes ActorNoPermissionErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }
          if (this.actor_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.actor_id.length);
            encoder.string(this.actor_id);
          }

          return buf;
        } // encode ActorNoPermissionErrorKind
      } // ActorNoPermissionErrorKind

      export class DeleteKeyDoesNotExistErrorKind {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes DeleteKeyDoesNotExistErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteKeyDoesNotExistErrorKind {
          return DeleteKeyDoesNotExistErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteKeyDoesNotExistErrorKind from a DataView
        static decodeDataView(view: DataView): DeleteKeyDoesNotExistErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteKeyDoesNotExistErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteKeyDoesNotExistErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes DeleteKeyDoesNotExistErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteKeyDoesNotExistErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode DeleteKeyDoesNotExistErrorKind
      } // DeleteKeyDoesNotExistErrorKind

      export class AddKeyAlreadyExistsErrorKind {
        public account_id: string = "";
        public public_key: PublicKey = new PublicKey();

        // Decodes AddKeyAlreadyExistsErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): AddKeyAlreadyExistsErrorKind {
          return AddKeyAlreadyExistsErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes AddKeyAlreadyExistsErrorKind from a DataView
        static decodeDataView(view: DataView): AddKeyAlreadyExistsErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new AddKeyAlreadyExistsErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AddKeyAlreadyExistsErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AddKeyAlreadyExistsErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AddKeyAlreadyExistsErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AddKeyAlreadyExistsErrorKind
      } // AddKeyAlreadyExistsErrorKind

      export class DeleteAccountStakingErrorKind {
        public account_id: string = "";

        // Decodes DeleteAccountStakingErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountStakingErrorKind {
          return DeleteAccountStakingErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteAccountStakingErrorKind from a DataView
        static decodeDataView(view: DataView): DeleteAccountStakingErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountStakingErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountStakingErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountStakingErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountStakingErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode DeleteAccountStakingErrorKind
      } // DeleteAccountStakingErrorKind

      export class LackBalanceForStateErrorKind {
        public account_id: string = "";
        public balance: BigInt = new BigInt();

        // Decodes LackBalanceForStateErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): LackBalanceForStateErrorKind {
          return LackBalanceForStateErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes LackBalanceForStateErrorKind from a DataView
        static decodeDataView(view: DataView): LackBalanceForStateErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new LackBalanceForStateErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.balance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode LackBalanceForStateErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.balance != null) {
            const f: BigInt = this.balance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes LackBalanceForStateErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes LackBalanceForStateErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.balance != null) {
            const f = this.balance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode LackBalanceForStateErrorKind
      } // LackBalanceForStateErrorKind

      export class TriesToUnstakeErrorKind {
        public account_id: string = "";

        // Decodes TriesToUnstakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): TriesToUnstakeErrorKind {
          return TriesToUnstakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes TriesToUnstakeErrorKind from a DataView
        static decodeDataView(view: DataView): TriesToUnstakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new TriesToUnstakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TriesToUnstakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes TriesToUnstakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TriesToUnstakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode TriesToUnstakeErrorKind
      } // TriesToUnstakeErrorKind

      export class TriesToStakeErrorKind {
        public account_id: string = "";
        public stake: BigInt = new BigInt();
        public locked: BigInt = new BigInt();
        public balance: BigInt = new BigInt();

        // Decodes TriesToStakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): TriesToStakeErrorKind {
          return TriesToStakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes TriesToStakeErrorKind from a DataView
        static decodeDataView(view: DataView): TriesToStakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new TriesToStakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.locked = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.balance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TriesToStakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.locked != null) {
            const f: BigInt = this.locked as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.balance != null) {
            const f: BigInt = this.balance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes TriesToStakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TriesToStakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.locked != null) {
            const f = this.locked as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.balance != null) {
            const f = this.balance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode TriesToStakeErrorKind
      } // TriesToStakeErrorKind

      export class InsufficientStakeErrorKind {
        public account_id: string = "";
        public stake: BigInt = new BigInt();
        public minimum_stake: BigInt = new BigInt();

        // Decodes InsufficientStakeErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): InsufficientStakeErrorKind {
          return InsufficientStakeErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes InsufficientStakeErrorKind from a DataView
        static decodeDataView(view: DataView): InsufficientStakeErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new InsufficientStakeErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.minimum_stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode InsufficientStakeErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.minimum_stake != null) {
            const f: BigInt = this.minimum_stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes InsufficientStakeErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes InsufficientStakeErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.minimum_stake != null) {
            const f = this.minimum_stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode InsufficientStakeErrorKind
      } // InsufficientStakeErrorKind

      export class FunctionCallErrorKind {
        public error: u32;

        // Decodes FunctionCallErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallErrorKind {
          return FunctionCallErrorKind.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallErrorKind from a DataView
        static decodeDataView(view: DataView): FunctionCallErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.error = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

          return size;
        }

        // Encodes FunctionCallErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.error != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.error);
          }

          return buf;
        } // encode FunctionCallErrorKind
      } // FunctionCallErrorKind

      export class NewReceiptValidationErrorKind {
        public error: u32;

        // Decodes NewReceiptValidationErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): NewReceiptValidationErrorKind {
          return NewReceiptValidationErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes NewReceiptValidationErrorKind from a DataView
        static decodeDataView(view: DataView): NewReceiptValidationErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new NewReceiptValidationErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.error = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode NewReceiptValidationErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

          return size;
        }

        // Encodes NewReceiptValidationErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes NewReceiptValidationErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.error != 0) {
            encoder.uint32(0x8);
            encoder.uint32(this.error);
          }

          return buf;
        } // encode NewReceiptValidationErrorKind
      } // NewReceiptValidationErrorKind

      export class OnlyImplicitAccountCreationAllowedErrorKind {
        public account_id: string = "";

        // Decodes OnlyImplicitAccountCreationAllowedErrorKind from an ArrayBuffer
        static decode(
          buf: ArrayBuffer
        ): OnlyImplicitAccountCreationAllowedErrorKind {
          return OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes OnlyImplicitAccountCreationAllowedErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): OnlyImplicitAccountCreationAllowedErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new OnlyImplicitAccountCreationAllowedErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode OnlyImplicitAccountCreationAllowedErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode OnlyImplicitAccountCreationAllowedErrorKind
      } // OnlyImplicitAccountCreationAllowedErrorKind

      export class DeleteAccountWithLargeStateErrorKind {
        public account_id: string = "";

        // Decodes DeleteAccountWithLargeStateErrorKind from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountWithLargeStateErrorKind {
          return DeleteAccountWithLargeStateErrorKind.decodeDataView(
            new DataView(buf)
          );
        }

        // Decodes DeleteAccountWithLargeStateErrorKind from a DataView
        static decodeDataView(
          view: DataView
        ): DeleteAccountWithLargeStateErrorKind {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountWithLargeStateErrorKind();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.account_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountWithLargeStateErrorKind

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.account_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.account_id.length) +
                this.account_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountWithLargeStateErrorKind to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountWithLargeStateErrorKind to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.account_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.account_id.length);
            encoder.string(this.account_id);
          }

          return buf;
        } // encode DeleteAccountWithLargeStateErrorKind
      } // DeleteAccountWithLargeStateErrorKind

      export class MerklePath {
        public path: Array<MerklePathItem> = new Array<MerklePathItem>();

        // Decodes MerklePath from an ArrayBuffer
        static decode(buf: ArrayBuffer): MerklePath {
          return MerklePath.decodeDataView(new DataView(buf));
        }

        // Decodes MerklePath from a DataView
        static decodeDataView(view: DataView): MerklePath {
          const decoder = new __proto.Decoder(view);
          const obj = new MerklePath();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.path.push(
                  MerklePathItem.decodeDataView(
                    new DataView(
                      decoder.view.buffer,
                      decoder.pos + decoder.view.byteOffset,
                      length
                    )
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode MerklePath

        public size(): u32 {
          let size: u32 = 0;

          for (let n: i32 = 0; n < this.path.length; n++) {
            const messageSize = this.path[n].size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes MerklePath to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes MerklePath to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          for (let n: i32 = 0; n < this.path.length; n++) {
            const messageSize = this.path[n].size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              this.path[n].encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode MerklePath
      } // MerklePath

      export class MerklePathItem {
        public hash: CryptoHash = new CryptoHash();
        public direction: u32;

        // Decodes MerklePathItem from an ArrayBuffer
        static decode(buf: ArrayBuffer): MerklePathItem {
          return MerklePathItem.decodeDataView(new DataView(buf));
        }

        // Decodes MerklePathItem from a DataView
        static decodeDataView(view: DataView): MerklePathItem {
          const decoder = new __proto.Decoder(view);
          const obj = new MerklePathItem();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.hash = CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.direction = decoder.uint32();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode MerklePathItem

        public size(): u32 {
          let size: u32 = 0;

          if (this.hash != null) {
            const f: CryptoHash = this.hash as CryptoHash;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.direction == 0 ? 0 : 1 + __proto.Sizer.uint32(this.direction);

          return size;
        }

        // Encodes MerklePathItem to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes MerklePathItem to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.hash != null) {
            const f = this.hash as CryptoHash;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.direction != 0) {
            encoder.uint32(0x10);
            encoder.uint32(this.direction);
          }

          return buf;
        } // encode MerklePathItem
      } // MerklePathItem

      export class Action {
        public create_account: CreateAccountAction | null;
        public deploy_contract: DeployContractAction | null;
        public function_call: FunctionCallAction | null;
        public transfer: TransferAction | null;
        public stake: StakeAction | null;
        public add_key: AddKeyAction | null;
        public delete_key: DeleteKeyAction | null;
        public delete_account: DeleteAccountAction | null;

        public __action: string = "";
        public __action_index: u8 = 0;

        static readonly ACTION_CREATE_ACCOUNT_INDEX: u8 = 1;
        static readonly ACTION_DEPLOY_CONTRACT_INDEX: u8 = 2;
        static readonly ACTION_FUNCTION_CALL_INDEX: u8 = 3;
        static readonly ACTION_TRANSFER_INDEX: u8 = 4;
        static readonly ACTION_STAKE_INDEX: u8 = 5;
        static readonly ACTION_ADD_KEY_INDEX: u8 = 6;
        static readonly ACTION_DELETE_KEY_INDEX: u8 = 7;
        static readonly ACTION_DELETE_ACCOUNT_INDEX: u8 = 8;

        // Decodes Action from an ArrayBuffer
        static decode(buf: ArrayBuffer): Action {
          return Action.decodeDataView(new DataView(buf));
        }

        // Decodes Action from a DataView
        static decodeDataView(view: DataView): Action {
          const decoder = new __proto.Decoder(view);
          const obj = new Action();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.create_account = CreateAccountAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "create_account";
                obj.__action_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.deploy_contract = DeployContractAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "deploy_contract";
                obj.__action_index = 2;
                break;
              }
              case 3: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "function_call";
                obj.__action_index = 3;
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.transfer = TransferAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "transfer";
                obj.__action_index = 4;
                break;
              }
              case 5: {
                const length = decoder.uint32();
                obj.stake = StakeAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "stake";
                obj.__action_index = 5;
                break;
              }
              case 6: {
                const length = decoder.uint32();
                obj.add_key = AddKeyAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "add_key";
                obj.__action_index = 6;
                break;
              }
              case 7: {
                const length = decoder.uint32();
                obj.delete_key = DeleteKeyAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "delete_key";
                obj.__action_index = 7;
                break;
              }
              case 8: {
                const length = decoder.uint32();
                obj.delete_account = DeleteAccountAction.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__action = "delete_account";
                obj.__action_index = 8;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode Action

        public size(): u32 {
          let size: u32 = 0;

          if (this.create_account != null) {
            const f: CreateAccountAction = this
              .create_account as CreateAccountAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.deploy_contract != null) {
            const f: DeployContractAction = this
              .deploy_contract as DeployContractAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.function_call != null) {
            const f: FunctionCallAction = this
              .function_call as FunctionCallAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.transfer != null) {
            const f: TransferAction = this.transfer as TransferAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.stake != null) {
            const f: StakeAction = this.stake as StakeAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.add_key != null) {
            const f: AddKeyAction = this.add_key as AddKeyAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_key != null) {
            const f: DeleteKeyAction = this.delete_key as DeleteKeyAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.delete_account != null) {
            const f: DeleteAccountAction = this
              .delete_account as DeleteAccountAction;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes Action to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes Action to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.create_account != null) {
            const f = this.create_account as CreateAccountAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.deploy_contract != null) {
            const f = this.deploy_contract as DeployContractAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x1a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.transfer != null) {
            const f = this.transfer as TransferAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.stake != null) {
            const f = this.stake as StakeAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x2a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.add_key != null) {
            const f = this.add_key as AddKeyAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x32);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_key != null) {
            const f = this.delete_key as DeleteKeyAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x3a);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.delete_account != null) {
            const f = this.delete_account as DeleteAccountAction;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x42);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode Action
      } // Action

      export class CreateAccountAction {
        // Decodes CreateAccountAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): CreateAccountAction {
          return CreateAccountAction.decodeDataView(new DataView(buf));
        }

        // Decodes CreateAccountAction from a DataView
        static decodeDataView(view: DataView): CreateAccountAction {
          const decoder = new __proto.Decoder(view);
          const obj = new CreateAccountAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode CreateAccountAction

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes CreateAccountAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes CreateAccountAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode CreateAccountAction
      } // CreateAccountAction

      export class DeployContractAction {
        public code: Array<u8> = new Array<u8>();

        // Decodes DeployContractAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeployContractAction {
          return DeployContractAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeployContractAction from a DataView
        static decodeDataView(view: DataView): DeployContractAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeployContractAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.code = decoder.bytes();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeployContractAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.code.length > 0
              ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
              : 0;

          return size;
        }

        // Encodes DeployContractAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeployContractAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.code.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.code.length);
            encoder.bytes(this.code);
          }

          return buf;
        } // encode DeployContractAction
      } // DeployContractAction

      export class FunctionCallAction {
        public method_name: string = "";
        public args: Array<u8> = new Array<u8>();
        public gas: u64;
        public deposit: BigInt = new BigInt();

        // Decodes FunctionCallAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallAction {
          return FunctionCallAction.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallAction from a DataView
        static decodeDataView(view: DataView): FunctionCallAction {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.method_name = decoder.string();
                break;
              }
              case 2: {
                obj.args = decoder.bytes();
                break;
              }
              case 3: {
                obj.gas = decoder.uint64();
                break;
              }
              case 4: {
                const length = decoder.uint32();
                obj.deposit = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.method_name.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.method_name.length) +
                this.method_name.length
              : 0;
          size +=
            this.args.length > 0
              ? 1 + __proto.Sizer.varint64(this.args.length) + this.args.length
              : 0;
          size += this.gas == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas);

          if (this.deposit != null) {
            const f: BigInt = this.deposit as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes FunctionCallAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.method_name.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.method_name.length);
            encoder.string(this.method_name);
          }
          if (this.args.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.args.length);
            encoder.bytes(this.args);
          }
          if (this.gas != 0) {
            encoder.uint32(0x18);
            encoder.uint64(this.gas);
          }

          if (this.deposit != null) {
            const f = this.deposit as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x22);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode FunctionCallAction
      } // FunctionCallAction

      export class TransferAction {
        public deposit: BigInt = new BigInt();

        // Decodes TransferAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): TransferAction {
          return TransferAction.decodeDataView(new DataView(buf));
        }

        // Decodes TransferAction from a DataView
        static decodeDataView(view: DataView): TransferAction {
          const decoder = new __proto.Decoder(view);
          const obj = new TransferAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.deposit = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode TransferAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.deposit != null) {
            const f: BigInt = this.deposit as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes TransferAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes TransferAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.deposit != null) {
            const f = this.deposit as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode TransferAction
      } // TransferAction

      export class StakeAction {
        public stake: BigInt = new BigInt();
        public public_key: PublicKey = new PublicKey();

        // Decodes StakeAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): StakeAction {
          return StakeAction.decodeDataView(new DataView(buf));
        }

        // Decodes StakeAction from a DataView
        static decodeDataView(view: DataView): StakeAction {
          const decoder = new __proto.Decoder(view);
          const obj = new StakeAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.stake = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode StakeAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.stake != null) {
            const f: BigInt = this.stake as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes StakeAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes StakeAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.stake != null) {
            const f = this.stake as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode StakeAction
      } // StakeAction

      export class AddKeyAction {
        public public_key: PublicKey = new PublicKey();
        public access_key: AccessKey = new AccessKey();

        // Decodes AddKeyAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): AddKeyAction {
          return AddKeyAction.decodeDataView(new DataView(buf));
        }

        // Decodes AddKeyAction from a DataView
        static decodeDataView(view: DataView): AddKeyAction {
          const decoder = new __proto.Decoder(view);
          const obj = new AddKeyAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.access_key = AccessKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AddKeyAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.access_key != null) {
            const f: AccessKey = this.access_key as AccessKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AddKeyAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AddKeyAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.access_key != null) {
            const f = this.access_key as AccessKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AddKeyAction
      } // AddKeyAction

      export class DeleteKeyAction {
        public public_key: PublicKey = new PublicKey();

        // Decodes DeleteKeyAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteKeyAction {
          return DeleteKeyAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeleteKeyAction from a DataView
        static decodeDataView(view: DataView): DeleteKeyAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteKeyAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.public_key = PublicKey.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteKeyAction

        public size(): u32 {
          let size: u32 = 0;

          if (this.public_key != null) {
            const f: PublicKey = this.public_key as PublicKey;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes DeleteKeyAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteKeyAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.public_key != null) {
            const f = this.public_key as PublicKey;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode DeleteKeyAction
      } // DeleteKeyAction

      export class DeleteAccountAction {
        public beneficiary_id: string = "";

        // Decodes DeleteAccountAction from an ArrayBuffer
        static decode(buf: ArrayBuffer): DeleteAccountAction {
          return DeleteAccountAction.decodeDataView(new DataView(buf));
        }

        // Decodes DeleteAccountAction from a DataView
        static decodeDataView(view: DataView): DeleteAccountAction {
          const decoder = new __proto.Decoder(view);
          const obj = new DeleteAccountAction();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.beneficiary_id = decoder.string();
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode DeleteAccountAction

        public size(): u32 {
          let size: u32 = 0;

          size +=
            this.beneficiary_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.beneficiary_id.length) +
                this.beneficiary_id.length
              : 0;

          return size;
        }

        // Encodes DeleteAccountAction to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes DeleteAccountAction to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.beneficiary_id.length > 0) {
            encoder.uint32(0xa);
            encoder.uint32(this.beneficiary_id.length);
            encoder.string(this.beneficiary_id);
          }

          return buf;
        } // encode DeleteAccountAction
      } // DeleteAccountAction

      export class AccessKey {
        public nonce: u64;
        public permission: AccessKeyPermission = new AccessKeyPermission();

        // Decodes AccessKey from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccessKey {
          return AccessKey.decodeDataView(new DataView(buf));
        }

        // Decodes AccessKey from a DataView
        static decodeDataView(view: DataView): AccessKey {
          const decoder = new __proto.Decoder(view);
          const obj = new AccessKey();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                obj.nonce = decoder.uint64();
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.permission = AccessKeyPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccessKey

        public size(): u32 {
          let size: u32 = 0;

          size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);

          if (this.permission != null) {
            const f: AccessKeyPermission = this
              .permission as AccessKeyPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AccessKey to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccessKey to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.nonce != 0) {
            encoder.uint32(0x8);
            encoder.uint64(this.nonce);
          }

          if (this.permission != null) {
            const f = this.permission as AccessKeyPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AccessKey
      } // AccessKey

      export class AccessKeyPermission {
        public function_call: FunctionCallPermission | null;
        public full_access: FullAccessPermission | null;

        public __permission: string = "";
        public __permission_index: u8 = 0;

        static readonly PERMISSION_FUNCTION_CALL_INDEX: u8 = 1;
        static readonly PERMISSION_FULL_ACCESS_INDEX: u8 = 2;

        // Decodes AccessKeyPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): AccessKeyPermission {
          return AccessKeyPermission.decodeDataView(new DataView(buf));
        }

        // Decodes AccessKeyPermission from a DataView
        static decodeDataView(view: DataView): AccessKeyPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new AccessKeyPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.function_call = FunctionCallPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__permission = "function_call";
                obj.__permission_index = 1;
                break;
              }
              case 2: {
                const length = decoder.uint32();
                obj.full_access = FullAccessPermission.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                obj.__permission = "full_access";
                obj.__permission_index = 2;
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode AccessKeyPermission

        public size(): u32 {
          let size: u32 = 0;

          if (this.function_call != null) {
            const f: FunctionCallPermission = this
              .function_call as FunctionCallPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          if (this.full_access != null) {
            const f: FullAccessPermission = this
              .full_access as FullAccessPermission;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          return size;
        }

        // Encodes AccessKeyPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes AccessKeyPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.function_call != null) {
            const f = this.function_call as FunctionCallPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.full_access != null) {
            const f = this.full_access as FullAccessPermission;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0x12);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          return buf;
        } // encode AccessKeyPermission
      } // AccessKeyPermission

      export class FunctionCallPermission {
        public allowance: BigInt = new BigInt();
        public receiver_id: string = "";
        public method_names: Array<string> = new Array<string>();

        // Decodes FunctionCallPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): FunctionCallPermission {
          return FunctionCallPermission.decodeDataView(new DataView(buf));
        }

        // Decodes FunctionCallPermission from a DataView
        static decodeDataView(view: DataView): FunctionCallPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new FunctionCallPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              case 1: {
                const length = decoder.uint32();
                obj.allowance = BigInt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
                decoder.skip(length);

                break;
              }
              case 2: {
                obj.receiver_id = decoder.string();
                break;
              }
              case 3: {
                obj.method_names.push(decoder.string());
                break;
              }

              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FunctionCallPermission

        public size(): u32 {
          let size: u32 = 0;

          if (this.allowance != null) {
            const f: BigInt = this.allowance as BigInt;
            const messageSize = f.size();

            if (messageSize > 0) {
              size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
            }
          }

          size +=
            this.receiver_id.length > 0
              ? 1 +
                __proto.Sizer.varint64(this.receiver_id.length) +
                this.receiver_id.length
              : 0;

          size += __size_string_repeated(this.method_names);

          return size;
        }

        // Encodes FunctionCallPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FunctionCallPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          if (this.allowance != null) {
            const f = this.allowance as BigInt;

            const messageSize = f.size();

            if (messageSize > 0) {
              encoder.uint32(0xa);
              encoder.uint32(messageSize);
              f.encodeU8Array(encoder);
            }
          }

          if (this.receiver_id.length > 0) {
            encoder.uint32(0x12);
            encoder.uint32(this.receiver_id.length);
            encoder.string(this.receiver_id);
          }

          if (this.method_names.length > 0) {
            for (let n: i32 = 0; n < this.method_names.length; n++) {
              encoder.uint32(0x1a);
              encoder.uint32(this.method_names[n].length);
              encoder.string(this.method_names[n]);
            }
          }

          return buf;
        } // encode FunctionCallPermission
      } // FunctionCallPermission

      export class FullAccessPermission {
        // Decodes FullAccessPermission from an ArrayBuffer
        static decode(buf: ArrayBuffer): FullAccessPermission {
          return FullAccessPermission.decodeDataView(new DataView(buf));
        }

        // Decodes FullAccessPermission from a DataView
        static decodeDataView(view: DataView): FullAccessPermission {
          const decoder = new __proto.Decoder(view);
          const obj = new FullAccessPermission();

          while (!decoder.eof()) {
            const tag = decoder.tag();
            const number = tag >>> 3;

            switch (number) {
              default:
                decoder.skipType(tag & 7);
                break;
            }
          }
          return obj;
        } // decode FullAccessPermission

        public size(): u32 {
          let size: u32 = 0;

          return size;
        }

        // Encodes FullAccessPermission to the ArrayBuffer
        encode(): ArrayBuffer {
          return changetype<ArrayBuffer>(
            StaticArray.fromArray<u8>(this.encodeU8Array())
          );
        }

        // Encodes FullAccessPermission to the Array<u8>
        encodeU8Array(
          encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
        ): Array<u8> {
          const buf = encoder.buf;

          return buf;
        } // encode FullAccessPermission
      } // FullAccessPermission
    } // v1
  } // codec
  export namespace v1 {
    export enum CurveKind {
      ED25519 = 0,
      SECP256K1 = 1,
    } // CurveKind
    export enum ExecutionMetadata {
      ExecutionMetadataV1 = 0,
    } // ExecutionMetadata
    // todo: add more detail?
    export enum FunctionCallErrorSer {
      CompilationError = 0,
      LinkError = 1,
      MethodResolveError = 2,
      WasmTrap = 3,
      WasmUnknownError = 4,
      HostError = 5,
      _EVMError = 6,
      ExecutionError = 7,
    } // FunctionCallErrorSer
    // todo: add more detail?
    export enum ReceiptValidationError {
      InvalidPredecessorId = 0,
      InvalidReceiverAccountId = 1,
      InvalidSignerAccountId = 2,
      InvalidDataReceiverId = 3,
      ReturnedValueLengthExceeded = 4,
      NumberInputDataDependenciesExceeded = 5,
      ActionsValidationError = 6,
    } // ReceiptValidationError
    // todo: add more detail?
    export enum InvalidTxError {
      InvalidAccessKeyError = 0,
      InvalidSignerId = 1,
      SignerDoesNotExist = 2,
      InvalidNonce = 3,
      NonceTooLarge = 4,
      InvalidReceiverId = 5,
      InvalidSignature = 6,
      NotEnoughBalance = 7,
      LackBalanceForState = 8,
      CostOverflow = 9,
      InvalidChain = 10,
      Expired = 11,
      ActionsValidation = 12,
      TransactionSizeExceeded = 13,
    } // InvalidTxError
    export enum Direction {
      left = 0,
      right = 1,
    } // Direction
    export class Block {
      public author: string = "";
      public header: BlockHeader = new BlockHeader();
      public chunk_headers: Array<ChunkHeader> = new Array<ChunkHeader>();
      public shards: Array<IndexerShard> = new Array<IndexerShard>();
      public state_changes: Array<StateChangeWithCause> =
        new Array<StateChangeWithCause>();

      // Decodes Block from an ArrayBuffer
      static decode(buf: ArrayBuffer): Block {
        return Block.decodeDataView(new DataView(buf));
      }

      // Decodes Block from a DataView
      static decodeDataView(view: DataView): Block {
        const decoder = new __proto.Decoder(view);
        const obj = new Block();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.author = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.header = BlockHeader.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.chunk_headers.push(
                ChunkHeader.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.shards.push(
                IndexerShard.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.state_changes.push(
                StateChangeWithCause.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode Block

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.author.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.author.length) +
              this.author.length
            : 0;

        if (this.header != null) {
          const f: BlockHeader = this.header as BlockHeader;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
          const messageSize = this.chunk_headers[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.shards.length; n++) {
          const messageSize = this.shards[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.state_changes.length; n++) {
          const messageSize = this.state_changes[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes Block to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes Block to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.author.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.author.length);
          encoder.string(this.author);
        }

        if (this.header != null) {
          const f = this.header as BlockHeader;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.chunk_headers.length; n++) {
          const messageSize = this.chunk_headers[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            this.chunk_headers[n].encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.shards.length; n++) {
          const messageSize = this.shards[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            this.shards[n].encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.state_changes.length; n++) {
          const messageSize = this.state_changes[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            this.state_changes[n].encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode Block
    } // Block

    /**
     * HeaderOnlyBlock is a standard [Block] structure where all other fields are
     *  removed so that hydrating that object from a [Block] bytes payload will
     *  drastically reduced allocated memory required to hold the full block.
     *
     *  This can be used to unpack a [Block] when only the [BlockHeader] information
     *  is required and greatly reduced required memory.
     */
    export class HeaderOnlyBlock {
      public header: BlockHeader = new BlockHeader();

      // Decodes HeaderOnlyBlock from an ArrayBuffer
      static decode(buf: ArrayBuffer): HeaderOnlyBlock {
        return HeaderOnlyBlock.decodeDataView(new DataView(buf));
      }

      // Decodes HeaderOnlyBlock from a DataView
      static decodeDataView(view: DataView): HeaderOnlyBlock {
        const decoder = new __proto.Decoder(view);
        const obj = new HeaderOnlyBlock();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 2: {
              const length = decoder.uint32();
              obj.header = BlockHeader.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode HeaderOnlyBlock

      public size(): u32 {
        let size: u32 = 0;

        if (this.header != null) {
          const f: BlockHeader = this.header as BlockHeader;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes HeaderOnlyBlock to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes HeaderOnlyBlock to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.header != null) {
          const f = this.header as BlockHeader;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode HeaderOnlyBlock
    } // HeaderOnlyBlock

    export class StateChangeWithCause {
      public value: StateChangeValue = new StateChangeValue();
      public cause: StateChangeCause = new StateChangeCause();

      // Decodes StateChangeWithCause from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeWithCause {
        return StateChangeWithCause.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeWithCause from a DataView
      static decodeDataView(view: DataView): StateChangeWithCause {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeWithCause();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.value = StateChangeValue.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.cause = StateChangeCause.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeWithCause

      public size(): u32 {
        let size: u32 = 0;

        if (this.value != null) {
          const f: StateChangeValue = this.value as StateChangeValue;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.cause != null) {
          const f: StateChangeCause = this.cause as StateChangeCause;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeWithCause to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeWithCause to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.value != null) {
          const f = this.value as StateChangeValue;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.cause != null) {
          const f = this.cause as StateChangeCause;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeWithCause
    } // StateChangeWithCause

    // / A top-level account ID can only be created by registrar.
    export class StateChangeCause {
      public not_writable_to_disk: StateChangeCause_NotWritableToDisk | null;
      public initial_state: StateChangeCause_InitialState | null;
      public transaction_processing: StateChangeCause_TransactionProcessing | null;
      public action_receipt_processing_started: StateChangeCause_ActionReceiptProcessingStarted | null;
      public action_receipt_gas_reward: StateChangeCause_ActionReceiptGasReward | null;
      public receipt_processing: StateChangeCause_ReceiptProcessing | null;
      public postponed_receipt: StateChangeCause_PostponedReceipt | null;
      public updated_delayed_receipts: StateChangeCause_UpdatedDelayedReceipts | null;
      public validator_accounts_update: StateChangeCause_ValidatorAccountsUpdate | null;
      public migration: StateChangeCause_Migration | null;

      public __cause: string = "";
      public __cause_index: u8 = 0;

      static readonly CAUSE_NOT_WRITABLE_TO_DISK_INDEX: u8 = 1;
      static readonly CAUSE_INITIAL_STATE_INDEX: u8 = 2;
      static readonly CAUSE_TRANSACTION_PROCESSING_INDEX: u8 = 3;
      static readonly CAUSE_ACTION_RECEIPT_PROCESSING_STARTED_INDEX: u8 = 4;
      static readonly CAUSE_ACTION_RECEIPT_GAS_REWARD_INDEX: u8 = 5;
      static readonly CAUSE_RECEIPT_PROCESSING_INDEX: u8 = 6;
      static readonly CAUSE_POSTPONED_RECEIPT_INDEX: u8 = 7;
      static readonly CAUSE_UPDATED_DELAYED_RECEIPTS_INDEX: u8 = 8;
      static readonly CAUSE_VALIDATOR_ACCOUNTS_UPDATE_INDEX: u8 = 9;
      static readonly CAUSE_MIGRATION_INDEX: u8 = 10;

      // Decodes StateChangeCause from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause {
        return StateChangeCause.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeCause from a DataView
      static decodeDataView(view: DataView): StateChangeCause {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.not_writable_to_disk =
                StateChangeCause_NotWritableToDisk.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "not_writable_to_disk";
              obj.__cause_index = 1;
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.initial_state = StateChangeCause_InitialState.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__cause = "initial_state";
              obj.__cause_index = 2;
              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.transaction_processing =
                StateChangeCause_TransactionProcessing.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "transaction_processing";
              obj.__cause_index = 3;
              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.action_receipt_processing_started =
                StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "action_receipt_processing_started";
              obj.__cause_index = 4;
              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.action_receipt_gas_reward =
                StateChangeCause_ActionReceiptGasReward.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "action_receipt_gas_reward";
              obj.__cause_index = 5;
              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.receipt_processing =
                StateChangeCause_ReceiptProcessing.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "receipt_processing";
              obj.__cause_index = 6;
              break;
            }
            case 7: {
              const length = decoder.uint32();
              obj.postponed_receipt =
                StateChangeCause_PostponedReceipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "postponed_receipt";
              obj.__cause_index = 7;
              break;
            }
            case 8: {
              const length = decoder.uint32();
              obj.updated_delayed_receipts =
                StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "updated_delayed_receipts";
              obj.__cause_index = 8;
              break;
            }
            case 9: {
              const length = decoder.uint32();
              obj.validator_accounts_update =
                StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__cause = "validator_accounts_update";
              obj.__cause_index = 9;
              break;
            }
            case 10: {
              const length = decoder.uint32();
              obj.migration = StateChangeCause_Migration.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__cause = "migration";
              obj.__cause_index = 10;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause

      public size(): u32 {
        let size: u32 = 0;

        if (this.not_writable_to_disk != null) {
          const f: StateChangeCause_NotWritableToDisk = this
            .not_writable_to_disk as StateChangeCause_NotWritableToDisk;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.initial_state != null) {
          const f: StateChangeCause_InitialState = this
            .initial_state as StateChangeCause_InitialState;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.transaction_processing != null) {
          const f: StateChangeCause_TransactionProcessing = this
            .transaction_processing as StateChangeCause_TransactionProcessing;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.action_receipt_processing_started != null) {
          const f: StateChangeCause_ActionReceiptProcessingStarted = this
            .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.action_receipt_gas_reward != null) {
          const f: StateChangeCause_ActionReceiptGasReward = this
            .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.receipt_processing != null) {
          const f: StateChangeCause_ReceiptProcessing = this
            .receipt_processing as StateChangeCause_ReceiptProcessing;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.postponed_receipt != null) {
          const f: StateChangeCause_PostponedReceipt = this
            .postponed_receipt as StateChangeCause_PostponedReceipt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.updated_delayed_receipts != null) {
          const f: StateChangeCause_UpdatedDelayedReceipts = this
            .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.validator_accounts_update != null) {
          const f: StateChangeCause_ValidatorAccountsUpdate = this
            .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.migration != null) {
          const f: StateChangeCause_Migration = this
            .migration as StateChangeCause_Migration;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.not_writable_to_disk != null) {
          const f = this
            .not_writable_to_disk as StateChangeCause_NotWritableToDisk;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.initial_state != null) {
          const f = this.initial_state as StateChangeCause_InitialState;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.transaction_processing != null) {
          const f = this
            .transaction_processing as StateChangeCause_TransactionProcessing;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.action_receipt_processing_started != null) {
          const f = this
            .action_receipt_processing_started as StateChangeCause_ActionReceiptProcessingStarted;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.action_receipt_gas_reward != null) {
          const f = this
            .action_receipt_gas_reward as StateChangeCause_ActionReceiptGasReward;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.receipt_processing != null) {
          const f = this
            .receipt_processing as StateChangeCause_ReceiptProcessing;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.postponed_receipt != null) {
          const f = this.postponed_receipt as StateChangeCause_PostponedReceipt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x3a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.updated_delayed_receipts != null) {
          const f = this
            .updated_delayed_receipts as StateChangeCause_UpdatedDelayedReceipts;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x42);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.validator_accounts_update != null) {
          const f = this
            .validator_accounts_update as StateChangeCause_ValidatorAccountsUpdate;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x4a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.migration != null) {
          const f = this.migration as StateChangeCause_Migration;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x52);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause
    } // StateChangeCause

    export class StateChangeCause_NotWritableToDisk {
      // Decodes StateChangeCause_NotWritableToDisk from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_NotWritableToDisk {
        return StateChangeCause_NotWritableToDisk.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_NotWritableToDisk from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_NotWritableToDisk {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_NotWritableToDisk();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_NotWritableToDisk

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes StateChangeCause_NotWritableToDisk to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_NotWritableToDisk to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode StateChangeCause_NotWritableToDisk
    } // StateChangeCause_NotWritableToDisk

    export class StateChangeCause_InitialState {
      // Decodes StateChangeCause_InitialState from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_InitialState {
        return StateChangeCause_InitialState.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeCause_InitialState from a DataView
      static decodeDataView(view: DataView): StateChangeCause_InitialState {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_InitialState();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_InitialState

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes StateChangeCause_InitialState to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_InitialState to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode StateChangeCause_InitialState
    } // StateChangeCause_InitialState

    export class StateChangeCause_TransactionProcessing {
      public tx_hash: CryptoHash = new CryptoHash();

      // Decodes StateChangeCause_TransactionProcessing from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_TransactionProcessing {
        return StateChangeCause_TransactionProcessing.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_TransactionProcessing from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_TransactionProcessing {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_TransactionProcessing();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.tx_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_TransactionProcessing

      public size(): u32 {
        let size: u32 = 0;

        if (this.tx_hash != null) {
          const f: CryptoHash = this.tx_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause_TransactionProcessing to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_TransactionProcessing to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.tx_hash != null) {
          const f = this.tx_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause_TransactionProcessing
    } // StateChangeCause_TransactionProcessing

    export class StateChangeCause_ActionReceiptProcessingStarted {
      public receipt_hash: CryptoHash = new CryptoHash();

      // Decodes StateChangeCause_ActionReceiptProcessingStarted from an ArrayBuffer
      static decode(
        buf: ArrayBuffer
      ): StateChangeCause_ActionReceiptProcessingStarted {
        return StateChangeCause_ActionReceiptProcessingStarted.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_ActionReceiptProcessingStarted from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_ActionReceiptProcessingStarted {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_ActionReceiptProcessingStarted();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.receipt_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_ActionReceiptProcessingStarted

      public size(): u32 {
        let size: u32 = 0;

        if (this.receipt_hash != null) {
          const f: CryptoHash = this.receipt_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause_ActionReceiptProcessingStarted to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_ActionReceiptProcessingStarted to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.receipt_hash != null) {
          const f = this.receipt_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause_ActionReceiptProcessingStarted
    } // StateChangeCause_ActionReceiptProcessingStarted

    export class StateChangeCause_ActionReceiptGasReward {
      public tx_hash: CryptoHash = new CryptoHash();

      // Decodes StateChangeCause_ActionReceiptGasReward from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_ActionReceiptGasReward {
        return StateChangeCause_ActionReceiptGasReward.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_ActionReceiptGasReward from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_ActionReceiptGasReward {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_ActionReceiptGasReward();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.tx_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_ActionReceiptGasReward

      public size(): u32 {
        let size: u32 = 0;

        if (this.tx_hash != null) {
          const f: CryptoHash = this.tx_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause_ActionReceiptGasReward to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_ActionReceiptGasReward to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.tx_hash != null) {
          const f = this.tx_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause_ActionReceiptGasReward
    } // StateChangeCause_ActionReceiptGasReward

    export class StateChangeCause_ReceiptProcessing {
      public tx_hash: CryptoHash = new CryptoHash();

      // Decodes StateChangeCause_ReceiptProcessing from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_ReceiptProcessing {
        return StateChangeCause_ReceiptProcessing.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_ReceiptProcessing from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_ReceiptProcessing {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_ReceiptProcessing();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.tx_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_ReceiptProcessing

      public size(): u32 {
        let size: u32 = 0;

        if (this.tx_hash != null) {
          const f: CryptoHash = this.tx_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause_ReceiptProcessing to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_ReceiptProcessing to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.tx_hash != null) {
          const f = this.tx_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause_ReceiptProcessing
    } // StateChangeCause_ReceiptProcessing

    export class StateChangeCause_PostponedReceipt {
      public tx_hash: CryptoHash = new CryptoHash();

      // Decodes StateChangeCause_PostponedReceipt from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_PostponedReceipt {
        return StateChangeCause_PostponedReceipt.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_PostponedReceipt from a DataView
      static decodeDataView(view: DataView): StateChangeCause_PostponedReceipt {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_PostponedReceipt();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.tx_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_PostponedReceipt

      public size(): u32 {
        let size: u32 = 0;

        if (this.tx_hash != null) {
          const f: CryptoHash = this.tx_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeCause_PostponedReceipt to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_PostponedReceipt to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.tx_hash != null) {
          const f = this.tx_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeCause_PostponedReceipt
    } // StateChangeCause_PostponedReceipt

    export class StateChangeCause_UpdatedDelayedReceipts {
      // Decodes StateChangeCause_UpdatedDelayedReceipts from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_UpdatedDelayedReceipts {
        return StateChangeCause_UpdatedDelayedReceipts.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_UpdatedDelayedReceipts from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_UpdatedDelayedReceipts {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_UpdatedDelayedReceipts();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_UpdatedDelayedReceipts

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes StateChangeCause_UpdatedDelayedReceipts to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_UpdatedDelayedReceipts to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode StateChangeCause_UpdatedDelayedReceipts
    } // StateChangeCause_UpdatedDelayedReceipts

    export class StateChangeCause_ValidatorAccountsUpdate {
      // Decodes StateChangeCause_ValidatorAccountsUpdate from an ArrayBuffer
      static decode(
        buf: ArrayBuffer
      ): StateChangeCause_ValidatorAccountsUpdate {
        return StateChangeCause_ValidatorAccountsUpdate.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeCause_ValidatorAccountsUpdate from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeCause_ValidatorAccountsUpdate {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_ValidatorAccountsUpdate();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_ValidatorAccountsUpdate

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes StateChangeCause_ValidatorAccountsUpdate to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_ValidatorAccountsUpdate to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode StateChangeCause_ValidatorAccountsUpdate
    } // StateChangeCause_ValidatorAccountsUpdate

    export class StateChangeCause_Migration {
      // Decodes StateChangeCause_Migration from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeCause_Migration {
        return StateChangeCause_Migration.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeCause_Migration from a DataView
      static decodeDataView(view: DataView): StateChangeCause_Migration {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeCause_Migration();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeCause_Migration

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes StateChangeCause_Migration to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeCause_Migration to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode StateChangeCause_Migration
    } // StateChangeCause_Migration

    export class StateChangeValue {
      public account_update: StateChangeValue_AccountUpdate | null;
      public account_deletion: StateChangeValue_AccountDeletion | null;
      public access_key_update: StateChangeValue_AccessKeyUpdate | null;
      public access_key_deletion: StateChangeValue_AccessKeyDeletion | null;
      public data_update: StateChangeValue_DataUpdate | null;
      public data_deletion: StateChangeValue_DataDeletion | null;
      public contract_code_update: StateChangeValue_ContractCodeUpdate | null;
      public contract_deletion: StateChangeValue_ContractCodeDeletion | null;

      public __value: string = "";
      public __value_index: u8 = 0;

      static readonly VALUE_ACCOUNT_UPDATE_INDEX: u8 = 1;
      static readonly VALUE_ACCOUNT_DELETION_INDEX: u8 = 2;
      static readonly VALUE_ACCESS_KEY_UPDATE_INDEX: u8 = 3;
      static readonly VALUE_ACCESS_KEY_DELETION_INDEX: u8 = 4;
      static readonly VALUE_DATA_UPDATE_INDEX: u8 = 5;
      static readonly VALUE_DATA_DELETION_INDEX: u8 = 6;
      static readonly VALUE_CONTRACT_CODE_UPDATE_INDEX: u8 = 7;
      static readonly VALUE_CONTRACT_DELETION_INDEX: u8 = 8;

      // Decodes StateChangeValue from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue {
        return StateChangeValue.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeValue from a DataView
      static decodeDataView(view: DataView): StateChangeValue {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.account_update =
                StateChangeValue_AccountUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "account_update";
              obj.__value_index = 1;
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.account_deletion =
                StateChangeValue_AccountDeletion.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "account_deletion";
              obj.__value_index = 2;
              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.access_key_update =
                StateChangeValue_AccessKeyUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "access_key_update";
              obj.__value_index = 3;
              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.access_key_deletion =
                StateChangeValue_AccessKeyDeletion.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "access_key_deletion";
              obj.__value_index = 4;
              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.data_update = StateChangeValue_DataUpdate.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__value = "data_update";
              obj.__value_index = 5;
              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.data_deletion = StateChangeValue_DataDeletion.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__value = "data_deletion";
              obj.__value_index = 6;
              break;
            }
            case 7: {
              const length = decoder.uint32();
              obj.contract_code_update =
                StateChangeValue_ContractCodeUpdate.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "contract_code_update";
              obj.__value_index = 7;
              break;
            }
            case 8: {
              const length = decoder.uint32();
              obj.contract_deletion =
                StateChangeValue_ContractCodeDeletion.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__value = "contract_deletion";
              obj.__value_index = 8;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue

      public size(): u32 {
        let size: u32 = 0;

        if (this.account_update != null) {
          const f: StateChangeValue_AccountUpdate = this
            .account_update as StateChangeValue_AccountUpdate;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.account_deletion != null) {
          const f: StateChangeValue_AccountDeletion = this
            .account_deletion as StateChangeValue_AccountDeletion;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.access_key_update != null) {
          const f: StateChangeValue_AccessKeyUpdate = this
            .access_key_update as StateChangeValue_AccessKeyUpdate;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.access_key_deletion != null) {
          const f: StateChangeValue_AccessKeyDeletion = this
            .access_key_deletion as StateChangeValue_AccessKeyDeletion;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.data_update != null) {
          const f: StateChangeValue_DataUpdate = this
            .data_update as StateChangeValue_DataUpdate;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.data_deletion != null) {
          const f: StateChangeValue_DataDeletion = this
            .data_deletion as StateChangeValue_DataDeletion;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.contract_code_update != null) {
          const f: StateChangeValue_ContractCodeUpdate = this
            .contract_code_update as StateChangeValue_ContractCodeUpdate;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.contract_deletion != null) {
          const f: StateChangeValue_ContractCodeDeletion = this
            .contract_deletion as StateChangeValue_ContractCodeDeletion;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeValue to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_update != null) {
          const f = this.account_update as StateChangeValue_AccountUpdate;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.account_deletion != null) {
          const f = this.account_deletion as StateChangeValue_AccountDeletion;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.access_key_update != null) {
          const f = this.access_key_update as StateChangeValue_AccessKeyUpdate;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.access_key_deletion != null) {
          const f = this
            .access_key_deletion as StateChangeValue_AccessKeyDeletion;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.data_update != null) {
          const f = this.data_update as StateChangeValue_DataUpdate;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.data_deletion != null) {
          const f = this.data_deletion as StateChangeValue_DataDeletion;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.contract_code_update != null) {
          const f = this
            .contract_code_update as StateChangeValue_ContractCodeUpdate;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x3a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.contract_deletion != null) {
          const f = this
            .contract_deletion as StateChangeValue_ContractCodeDeletion;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x42);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeValue
    } // StateChangeValue

    export class StateChangeValue_AccountUpdate {
      public account_id: string = "";
      public account: Account = new Account();

      // Decodes StateChangeValue_AccountUpdate from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_AccountUpdate {
        return StateChangeValue_AccountUpdate.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeValue_AccountUpdate from a DataView
      static decodeDataView(view: DataView): StateChangeValue_AccountUpdate {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_AccountUpdate();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.account = Account.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_AccountUpdate

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.account != null) {
          const f: Account = this.account as Account;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeValue_AccountUpdate to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_AccountUpdate to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.account != null) {
          const f = this.account as Account;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeValue_AccountUpdate
    } // StateChangeValue_AccountUpdate

    export class StateChangeValue_AccountDeletion {
      public account_id: string = "";

      // Decodes StateChangeValue_AccountDeletion from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_AccountDeletion {
        return StateChangeValue_AccountDeletion.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeValue_AccountDeletion from a DataView
      static decodeDataView(view: DataView): StateChangeValue_AccountDeletion {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_AccountDeletion();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_AccountDeletion

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes StateChangeValue_AccountDeletion to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_AccountDeletion to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode StateChangeValue_AccountDeletion
    } // StateChangeValue_AccountDeletion

    export class StateChangeValue_AccessKeyUpdate {
      public account_id: string = "";
      public public_key: PublicKey = new PublicKey();
      public access_key: AccessKey = new AccessKey();

      // Decodes StateChangeValue_AccessKeyUpdate from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyUpdate {
        return StateChangeValue_AccessKeyUpdate.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeValue_AccessKeyUpdate from a DataView
      static decodeDataView(view: DataView): StateChangeValue_AccessKeyUpdate {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_AccessKeyUpdate();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.access_key = AccessKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_AccessKeyUpdate

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.access_key != null) {
          const f: AccessKey = this.access_key as AccessKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeValue_AccessKeyUpdate to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_AccessKeyUpdate to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.access_key != null) {
          const f = this.access_key as AccessKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeValue_AccessKeyUpdate
    } // StateChangeValue_AccessKeyUpdate

    export class StateChangeValue_AccessKeyDeletion {
      public account_id: string = "";
      public public_key: PublicKey = new PublicKey();

      // Decodes StateChangeValue_AccessKeyDeletion from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_AccessKeyDeletion {
        return StateChangeValue_AccessKeyDeletion.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeValue_AccessKeyDeletion from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeValue_AccessKeyDeletion {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_AccessKeyDeletion();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_AccessKeyDeletion

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StateChangeValue_AccessKeyDeletion to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_AccessKeyDeletion to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StateChangeValue_AccessKeyDeletion
    } // StateChangeValue_AccessKeyDeletion

    export class StateChangeValue_DataUpdate {
      public account_id: string = "";
      public key: Array<u8> = new Array<u8>();
      public value: Array<u8> = new Array<u8>();

      // Decodes StateChangeValue_DataUpdate from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_DataUpdate {
        return StateChangeValue_DataUpdate.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeValue_DataUpdate from a DataView
      static decodeDataView(view: DataView): StateChangeValue_DataUpdate {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_DataUpdate();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.key = decoder.bytes();
              break;
            }
            case 3: {
              obj.value = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_DataUpdate

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.key.length > 0
            ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
            : 0;
        size +=
          this.value.length > 0
            ? 1 + __proto.Sizer.varint64(this.value.length) + this.value.length
            : 0;

        return size;
      }

      // Encodes StateChangeValue_DataUpdate to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_DataUpdate to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.key.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.key.length);
          encoder.bytes(this.key);
        }
        if (this.value.length > 0) {
          encoder.uint32(0x1a);
          encoder.uint32(this.value.length);
          encoder.bytes(this.value);
        }

        return buf;
      } // encode StateChangeValue_DataUpdate
    } // StateChangeValue_DataUpdate

    export class StateChangeValue_DataDeletion {
      public account_id: string = "";
      public key: Array<u8> = new Array<u8>();

      // Decodes StateChangeValue_DataDeletion from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_DataDeletion {
        return StateChangeValue_DataDeletion.decodeDataView(new DataView(buf));
      }

      // Decodes StateChangeValue_DataDeletion from a DataView
      static decodeDataView(view: DataView): StateChangeValue_DataDeletion {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_DataDeletion();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.key = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_DataDeletion

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.key.length > 0
            ? 1 + __proto.Sizer.varint64(this.key.length) + this.key.length
            : 0;

        return size;
      }

      // Encodes StateChangeValue_DataDeletion to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_DataDeletion to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.key.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.key.length);
          encoder.bytes(this.key);
        }

        return buf;
      } // encode StateChangeValue_DataDeletion
    } // StateChangeValue_DataDeletion

    export class StateChangeValue_ContractCodeUpdate {
      public account_id: string = "";
      public code: Array<u8> = new Array<u8>();

      // Decodes StateChangeValue_ContractCodeUpdate from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeUpdate {
        return StateChangeValue_ContractCodeUpdate.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeValue_ContractCodeUpdate from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeValue_ContractCodeUpdate {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_ContractCodeUpdate();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.code = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_ContractCodeUpdate

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.code.length > 0
            ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
            : 0;

        return size;
      }

      // Encodes StateChangeValue_ContractCodeUpdate to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_ContractCodeUpdate to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.code.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.code.length);
          encoder.bytes(this.code);
        }

        return buf;
      } // encode StateChangeValue_ContractCodeUpdate
    } // StateChangeValue_ContractCodeUpdate

    export class StateChangeValue_ContractCodeDeletion {
      public account_id: string = "";

      // Decodes StateChangeValue_ContractCodeDeletion from an ArrayBuffer
      static decode(buf: ArrayBuffer): StateChangeValue_ContractCodeDeletion {
        return StateChangeValue_ContractCodeDeletion.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes StateChangeValue_ContractCodeDeletion from a DataView
      static decodeDataView(
        view: DataView
      ): StateChangeValue_ContractCodeDeletion {
        const decoder = new __proto.Decoder(view);
        const obj = new StateChangeValue_ContractCodeDeletion();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StateChangeValue_ContractCodeDeletion

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes StateChangeValue_ContractCodeDeletion to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StateChangeValue_ContractCodeDeletion to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode StateChangeValue_ContractCodeDeletion
    } // StateChangeValue_ContractCodeDeletion

    export class Account {
      public amount: BigInt = new BigInt();
      public locked: BigInt = new BigInt();
      public code_hash: CryptoHash = new CryptoHash();
      public storage_usage: u64;

      // Decodes Account from an ArrayBuffer
      static decode(buf: ArrayBuffer): Account {
        return Account.decodeDataView(new DataView(buf));
      }

      // Decodes Account from a DataView
      static decodeDataView(view: DataView): Account {
        const decoder = new __proto.Decoder(view);
        const obj = new Account();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.amount = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.locked = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.code_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              obj.storage_usage = decoder.uint64();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode Account

      public size(): u32 {
        let size: u32 = 0;

        if (this.amount != null) {
          const f: BigInt = this.amount as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.locked != null) {
          const f: BigInt = this.locked as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.code_hash != null) {
          const f: CryptoHash = this.code_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.storage_usage == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.storage_usage);

        return size;
      }

      // Encodes Account to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes Account to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.amount != null) {
          const f = this.amount as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.locked != null) {
          const f = this.locked as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.code_hash != null) {
          const f = this.code_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.storage_usage != 0) {
          encoder.uint32(0x20);
          encoder.uint64(this.storage_usage);
        }

        return buf;
      } // encode Account
    } // Account

    export class BlockHeader {
      public height: u64;
      public prev_height: u64;
      public epoch_id: CryptoHash = new CryptoHash();
      public next_epoch_id: CryptoHash = new CryptoHash();
      public hash: CryptoHash = new CryptoHash();
      public prev_hash: CryptoHash = new CryptoHash();
      public prev_state_root: CryptoHash = new CryptoHash();
      public chunk_receipts_root: CryptoHash = new CryptoHash();
      public chunk_headers_root: CryptoHash = new CryptoHash();
      public chunk_tx_root: CryptoHash = new CryptoHash();
      public outcome_root: CryptoHash = new CryptoHash();
      public chunks_included: u64;
      public challenges_root: CryptoHash = new CryptoHash();
      public timestamp: u64;
      public timestamp_nanosec: u64;
      public random_value: CryptoHash = new CryptoHash();
      public validator_proposals: Array<ValidatorStake> =
        new Array<ValidatorStake>();
      public chunk_mask: Array<bool> = new Array<bool>();
      public gas_price: BigInt = new BigInt();
      public block_ordinal: u64;
      public total_supply: BigInt = new BigInt();
      public challenges_result: Array<SlashedValidator> =
        new Array<SlashedValidator>();
      public last_final_block_height: u64;
      public last_final_block: CryptoHash = new CryptoHash();
      public last_ds_final_block_height: u64;
      public last_ds_final_block: CryptoHash = new CryptoHash();
      public next_bp_hash: CryptoHash = new CryptoHash();
      public block_merkle_root: CryptoHash = new CryptoHash();
      public epoch_sync_data_hash: Array<u8> = new Array<u8>();
      public approvals: Array<Signature> = new Array<Signature>();
      public signature: Signature = new Signature();
      public latest_protocol_version: u32;

      // Decodes BlockHeader from an ArrayBuffer
      static decode(buf: ArrayBuffer): BlockHeader {
        return BlockHeader.decodeDataView(new DataView(buf));
      }

      // Decodes BlockHeader from a DataView
      static decodeDataView(view: DataView): BlockHeader {
        const decoder = new __proto.Decoder(view);
        const obj = new BlockHeader();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.height = decoder.uint64();
              break;
            }
            case 2: {
              obj.prev_height = decoder.uint64();
              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.epoch_id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.next_epoch_id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.prev_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 7: {
              const length = decoder.uint32();
              obj.prev_state_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 8: {
              const length = decoder.uint32();
              obj.chunk_receipts_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 9: {
              const length = decoder.uint32();
              obj.chunk_headers_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 10: {
              const length = decoder.uint32();
              obj.chunk_tx_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 11: {
              const length = decoder.uint32();
              obj.outcome_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 12: {
              obj.chunks_included = decoder.uint64();
              break;
            }
            case 13: {
              const length = decoder.uint32();
              obj.challenges_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 14: {
              obj.timestamp = decoder.uint64();
              break;
            }
            case 15: {
              obj.timestamp_nanosec = decoder.uint64();
              break;
            }
            case 16: {
              const length = decoder.uint32();
              obj.random_value = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 17: {
              const length = decoder.uint32();
              obj.validator_proposals.push(
                ValidatorStake.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 18: {
              const endPos = decoder.pos + decoder.uint32();
              while (decoder.pos <= endPos) {
                obj.chunk_mask.push(decoder.bool());
              }

              break;
            }
            case 19: {
              const length = decoder.uint32();
              obj.gas_price = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 20: {
              obj.block_ordinal = decoder.uint64();
              break;
            }
            case 21: {
              const length = decoder.uint32();
              obj.total_supply = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 22: {
              const length = decoder.uint32();
              obj.challenges_result.push(
                SlashedValidator.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 23: {
              obj.last_final_block_height = decoder.uint64();
              break;
            }
            case 24: {
              const length = decoder.uint32();
              obj.last_final_block = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 25: {
              obj.last_ds_final_block_height = decoder.uint64();
              break;
            }
            case 26: {
              const length = decoder.uint32();
              obj.last_ds_final_block = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 27: {
              const length = decoder.uint32();
              obj.next_bp_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 28: {
              const length = decoder.uint32();
              obj.block_merkle_root = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 29: {
              obj.epoch_sync_data_hash = decoder.bytes();
              break;
            }
            case 30: {
              const length = decoder.uint32();
              obj.approvals.push(
                Signature.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 31: {
              const length = decoder.uint32();
              obj.signature = Signature.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 32: {
              obj.latest_protocol_version = decoder.uint32();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode BlockHeader

      public size(): u32 {
        let size: u32 = 0;

        size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint64(this.height);
        size +=
          this.prev_height == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.prev_height);

        if (this.epoch_id != null) {
          const f: CryptoHash = this.epoch_id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.next_epoch_id != null) {
          const f: CryptoHash = this.next_epoch_id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.hash != null) {
          const f: CryptoHash = this.hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.prev_hash != null) {
          const f: CryptoHash = this.prev_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.prev_state_root != null) {
          const f: CryptoHash = this.prev_state_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.chunk_receipts_root != null) {
          const f: CryptoHash = this.chunk_receipts_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.chunk_headers_root != null) {
          const f: CryptoHash = this.chunk_headers_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.chunk_tx_root != null) {
          const f: CryptoHash = this.chunk_tx_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.outcome_root != null) {
          const f: CryptoHash = this.outcome_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.chunks_included == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.chunks_included);

        if (this.challenges_root != null) {
          const f: CryptoHash = this.challenges_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.timestamp == 0 ? 0 : 1 + __proto.Sizer.uint64(this.timestamp);
        size +=
          this.timestamp_nanosec == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.timestamp_nanosec);

        if (this.random_value != null) {
          const f: CryptoHash = this.random_value as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
          const messageSize = this.validator_proposals[n].size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.chunk_mask.length > 0) {
          const packedSize = __size_bool_repeated_packed(this.chunk_mask);
          if (packedSize > 0) {
            size += 2 + __proto.Sizer.varint64(packedSize) + packedSize;
          }
        }

        if (this.gas_price != null) {
          const f: BigInt = this.gas_price as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.block_ordinal == 0
            ? 0
            : 2 + __proto.Sizer.uint64(this.block_ordinal);

        if (this.total_supply != null) {
          const f: BigInt = this.total_supply as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.challenges_result.length; n++) {
          const messageSize = this.challenges_result[n].size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.last_final_block_height == 0
            ? 0
            : 2 + __proto.Sizer.uint64(this.last_final_block_height);

        if (this.last_final_block != null) {
          const f: CryptoHash = this.last_final_block as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.last_ds_final_block_height == 0
            ? 0
            : 2 + __proto.Sizer.uint64(this.last_ds_final_block_height);

        if (this.last_ds_final_block != null) {
          const f: CryptoHash = this.last_ds_final_block as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.next_bp_hash != null) {
          const f: CryptoHash = this.next_bp_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.block_merkle_root != null) {
          const f: CryptoHash = this.block_merkle_root as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.epoch_sync_data_hash.length > 0
            ? 2 +
              __proto.Sizer.varint64(this.epoch_sync_data_hash.length) +
              this.epoch_sync_data_hash.length
            : 0;

        for (let n: i32 = 0; n < this.approvals.length; n++) {
          const messageSize = this.approvals[n].size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.signature != null) {
          const f: Signature = this.signature as Signature;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.latest_protocol_version == 0
            ? 0
            : 2 + __proto.Sizer.uint32(this.latest_protocol_version);

        return size;
      }

      // Encodes BlockHeader to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes BlockHeader to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.height != 0) {
          encoder.uint32(0x8);
          encoder.uint64(this.height);
        }
        if (this.prev_height != 0) {
          encoder.uint32(0x10);
          encoder.uint64(this.prev_height);
        }

        if (this.epoch_id != null) {
          const f = this.epoch_id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.next_epoch_id != null) {
          const f = this.next_epoch_id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.hash != null) {
          const f = this.hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.prev_hash != null) {
          const f = this.prev_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.prev_state_root != null) {
          const f = this.prev_state_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x3a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.chunk_receipts_root != null) {
          const f = this.chunk_receipts_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x42);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.chunk_headers_root != null) {
          const f = this.chunk_headers_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x4a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.chunk_tx_root != null) {
          const f = this.chunk_tx_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x52);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.outcome_root != null) {
          const f = this.outcome_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x5a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.chunks_included != 0) {
          encoder.uint32(0x60);
          encoder.uint64(this.chunks_included);
        }

        if (this.challenges_root != null) {
          const f = this.challenges_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x6a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.timestamp != 0) {
          encoder.uint32(0x70);
          encoder.uint64(this.timestamp);
        }
        if (this.timestamp_nanosec != 0) {
          encoder.uint32(0x78);
          encoder.uint64(this.timestamp_nanosec);
        }

        if (this.random_value != null) {
          const f = this.random_value as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x82);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
          const messageSize = this.validator_proposals[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x8a);
            encoder.uint32(messageSize);
            this.validator_proposals[n].encodeU8Array(encoder);
          }
        }

        if (this.chunk_mask.length > 0) {
          encoder.uint32(0x92);
          encoder.uint32(__size_bool_repeated_packed(this.chunk_mask));

          for (let n: i32 = 0; n < this.chunk_mask.length; n++) {
            encoder.bool(this.chunk_mask[n]);
          }
        }

        if (this.gas_price != null) {
          const f = this.gas_price as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x9a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.block_ordinal != 0) {
          encoder.uint32(0xa0);
          encoder.uint64(this.block_ordinal);
        }

        if (this.total_supply != null) {
          const f = this.total_supply as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xaa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.challenges_result.length; n++) {
          const messageSize = this.challenges_result[n].size();

          if (messageSize > 0) {
            encoder.uint32(0xb2);
            encoder.uint32(messageSize);
            this.challenges_result[n].encodeU8Array(encoder);
          }
        }

        if (this.last_final_block_height != 0) {
          encoder.uint32(0xb8);
          encoder.uint64(this.last_final_block_height);
        }

        if (this.last_final_block != null) {
          const f = this.last_final_block as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xc2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.last_ds_final_block_height != 0) {
          encoder.uint32(0xc8);
          encoder.uint64(this.last_ds_final_block_height);
        }

        if (this.last_ds_final_block != null) {
          const f = this.last_ds_final_block as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xd2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.next_bp_hash != null) {
          const f = this.next_bp_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xda);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.block_merkle_root != null) {
          const f = this.block_merkle_root as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xe2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.epoch_sync_data_hash.length > 0) {
          encoder.uint32(0xea);
          encoder.uint32(this.epoch_sync_data_hash.length);
          encoder.bytes(this.epoch_sync_data_hash);
        }

        for (let n: i32 = 0; n < this.approvals.length; n++) {
          const messageSize = this.approvals[n].size();

          if (messageSize > 0) {
            encoder.uint32(0xf2);
            encoder.uint32(messageSize);
            this.approvals[n].encodeU8Array(encoder);
          }
        }

        if (this.signature != null) {
          const f = this.signature as Signature;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xfa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.latest_protocol_version != 0) {
          encoder.uint32(0x100);
          encoder.uint32(this.latest_protocol_version);
        }

        return buf;
      } // encode BlockHeader
    } // BlockHeader

    export class BigInt {
      public bytes: Array<u8> = new Array<u8>();

      // Decodes BigInt from an ArrayBuffer
      static decode(buf: ArrayBuffer): BigInt {
        return BigInt.decodeDataView(new DataView(buf));
      }

      // Decodes BigInt from a DataView
      static decodeDataView(view: DataView): BigInt {
        const decoder = new __proto.Decoder(view);
        const obj = new BigInt();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.bytes = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode BigInt

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.bytes.length > 0
            ? 1 + __proto.Sizer.varint64(this.bytes.length) + this.bytes.length
            : 0;

        return size;
      }

      // Encodes BigInt to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes BigInt to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.bytes.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.bytes.length);
          encoder.bytes(this.bytes);
        }

        return buf;
      } // encode BigInt
    } // BigInt

    export class CryptoHash {
      public bytes: Array<u8> = new Array<u8>();

      // Decodes CryptoHash from an ArrayBuffer
      static decode(buf: ArrayBuffer): CryptoHash {
        return CryptoHash.decodeDataView(new DataView(buf));
      }

      // Decodes CryptoHash from a DataView
      static decodeDataView(view: DataView): CryptoHash {
        const decoder = new __proto.Decoder(view);
        const obj = new CryptoHash();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.bytes = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode CryptoHash

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.bytes.length > 0
            ? 1 + __proto.Sizer.varint64(this.bytes.length) + this.bytes.length
            : 0;

        return size;
      }

      // Encodes CryptoHash to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes CryptoHash to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.bytes.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.bytes.length);
          encoder.bytes(this.bytes);
        }

        return buf;
      } // encode CryptoHash
    } // CryptoHash

    export class Signature {
      public type: u32;
      public bytes: Array<u8> = new Array<u8>();

      // Decodes Signature from an ArrayBuffer
      static decode(buf: ArrayBuffer): Signature {
        return Signature.decodeDataView(new DataView(buf));
      }

      // Decodes Signature from a DataView
      static decodeDataView(view: DataView): Signature {
        const decoder = new __proto.Decoder(view);
        const obj = new Signature();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.type = decoder.uint32();
              break;
            }
            case 2: {
              obj.bytes = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode Signature

      public size(): u32 {
        let size: u32 = 0;

        size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
        size +=
          this.bytes.length > 0
            ? 1 + __proto.Sizer.varint64(this.bytes.length) + this.bytes.length
            : 0;

        return size;
      }

      // Encodes Signature to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes Signature to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.type != 0) {
          encoder.uint32(0x8);
          encoder.uint32(this.type);
        }
        if (this.bytes.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.bytes.length);
          encoder.bytes(this.bytes);
        }

        return buf;
      } // encode Signature
    } // Signature

    export class PublicKey {
      public type: u32;
      public bytes: Array<u8> = new Array<u8>();

      // Decodes PublicKey from an ArrayBuffer
      static decode(buf: ArrayBuffer): PublicKey {
        return PublicKey.decodeDataView(new DataView(buf));
      }

      // Decodes PublicKey from a DataView
      static decodeDataView(view: DataView): PublicKey {
        const decoder = new __proto.Decoder(view);
        const obj = new PublicKey();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.type = decoder.uint32();
              break;
            }
            case 2: {
              obj.bytes = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode PublicKey

      public size(): u32 {
        let size: u32 = 0;

        size += this.type == 0 ? 0 : 1 + __proto.Sizer.uint32(this.type);
        size +=
          this.bytes.length > 0
            ? 1 + __proto.Sizer.varint64(this.bytes.length) + this.bytes.length
            : 0;

        return size;
      }

      // Encodes PublicKey to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes PublicKey to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.type != 0) {
          encoder.uint32(0x8);
          encoder.uint32(this.type);
        }
        if (this.bytes.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.bytes.length);
          encoder.bytes(this.bytes);
        }

        return buf;
      } // encode PublicKey
    } // PublicKey

    export class ValidatorStake {
      public account_id: string = "";
      public public_key: PublicKey = new PublicKey();
      public stake: BigInt = new BigInt();

      // Decodes ValidatorStake from an ArrayBuffer
      static decode(buf: ArrayBuffer): ValidatorStake {
        return ValidatorStake.decodeDataView(new DataView(buf));
      }

      // Decodes ValidatorStake from a DataView
      static decodeDataView(view: DataView): ValidatorStake {
        const decoder = new __proto.Decoder(view);
        const obj = new ValidatorStake();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.stake = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ValidatorStake

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.stake != null) {
          const f: BigInt = this.stake as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes ValidatorStake to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ValidatorStake to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.stake != null) {
          const f = this.stake as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode ValidatorStake
    } // ValidatorStake

    export class SlashedValidator {
      public account_id: string = "";
      public is_double_sign: bool;

      // Decodes SlashedValidator from an ArrayBuffer
      static decode(buf: ArrayBuffer): SlashedValidator {
        return SlashedValidator.decodeDataView(new DataView(buf));
      }

      // Decodes SlashedValidator from a DataView
      static decodeDataView(view: DataView): SlashedValidator {
        const decoder = new __proto.Decoder(view);
        const obj = new SlashedValidator();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.is_double_sign = decoder.bool();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode SlashedValidator

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size += this.is_double_sign == 0 ? 0 : 1 + 1;

        return size;
      }

      // Encodes SlashedValidator to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes SlashedValidator to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.is_double_sign != 0) {
          encoder.uint32(0x10);
          encoder.bool(this.is_double_sign);
        }

        return buf;
      } // encode SlashedValidator
    } // SlashedValidator

    export class ChunkHeader {
      public chunk_hash: Array<u8> = new Array<u8>();
      public prev_block_hash: Array<u8> = new Array<u8>();
      public outcome_root: Array<u8> = new Array<u8>();
      public prev_state_root: Array<u8> = new Array<u8>();
      public encoded_merkle_root: Array<u8> = new Array<u8>();
      public encoded_length: u64;
      public height_created: u64;
      public height_included: u64;
      public shard_id: u64;
      public gas_used: u64;
      public gas_limit: u64;
      public validator_reward: BigInt = new BigInt();
      public balance_burnt: BigInt = new BigInt();
      public outgoing_receipts_root: Array<u8> = new Array<u8>();
      public tx_root: Array<u8> = new Array<u8>();
      public validator_proposals: Array<ValidatorStake> =
        new Array<ValidatorStake>();
      public signature: Signature = new Signature();

      // Decodes ChunkHeader from an ArrayBuffer
      static decode(buf: ArrayBuffer): ChunkHeader {
        return ChunkHeader.decodeDataView(new DataView(buf));
      }

      // Decodes ChunkHeader from a DataView
      static decodeDataView(view: DataView): ChunkHeader {
        const decoder = new __proto.Decoder(view);
        const obj = new ChunkHeader();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.chunk_hash = decoder.bytes();
              break;
            }
            case 2: {
              obj.prev_block_hash = decoder.bytes();
              break;
            }
            case 3: {
              obj.outcome_root = decoder.bytes();
              break;
            }
            case 4: {
              obj.prev_state_root = decoder.bytes();
              break;
            }
            case 5: {
              obj.encoded_merkle_root = decoder.bytes();
              break;
            }
            case 6: {
              obj.encoded_length = decoder.uint64();
              break;
            }
            case 7: {
              obj.height_created = decoder.uint64();
              break;
            }
            case 8: {
              obj.height_included = decoder.uint64();
              break;
            }
            case 9: {
              obj.shard_id = decoder.uint64();
              break;
            }
            case 10: {
              obj.gas_used = decoder.uint64();
              break;
            }
            case 11: {
              obj.gas_limit = decoder.uint64();
              break;
            }
            case 12: {
              const length = decoder.uint32();
              obj.validator_reward = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 13: {
              const length = decoder.uint32();
              obj.balance_burnt = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 14: {
              obj.outgoing_receipts_root = decoder.bytes();
              break;
            }
            case 15: {
              obj.tx_root = decoder.bytes();
              break;
            }
            case 16: {
              const length = decoder.uint32();
              obj.validator_proposals.push(
                ValidatorStake.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 17: {
              const length = decoder.uint32();
              obj.signature = Signature.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ChunkHeader

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.chunk_hash.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.chunk_hash.length) +
              this.chunk_hash.length
            : 0;
        size +=
          this.prev_block_hash.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.prev_block_hash.length) +
              this.prev_block_hash.length
            : 0;
        size +=
          this.outcome_root.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.outcome_root.length) +
              this.outcome_root.length
            : 0;
        size +=
          this.prev_state_root.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.prev_state_root.length) +
              this.prev_state_root.length
            : 0;
        size +=
          this.encoded_merkle_root.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.encoded_merkle_root.length) +
              this.encoded_merkle_root.length
            : 0;
        size +=
          this.encoded_length == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.encoded_length);
        size +=
          this.height_created == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.height_created);
        size +=
          this.height_included == 0
            ? 0
            : 1 + __proto.Sizer.uint64(this.height_included);
        size +=
          this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);
        size +=
          this.gas_used == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_used);
        size +=
          this.gas_limit == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_limit);

        if (this.validator_reward != null) {
          const f: BigInt = this.validator_reward as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.balance_burnt != null) {
          const f: BigInt = this.balance_burnt as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.outgoing_receipts_root.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.outgoing_receipts_root.length) +
              this.outgoing_receipts_root.length
            : 0;
        size +=
          this.tx_root.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.tx_root.length) +
              this.tx_root.length
            : 0;

        for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
          const messageSize = this.validator_proposals[n].size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.signature != null) {
          const f: Signature = this.signature as Signature;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes ChunkHeader to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ChunkHeader to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.chunk_hash.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.chunk_hash.length);
          encoder.bytes(this.chunk_hash);
        }
        if (this.prev_block_hash.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.prev_block_hash.length);
          encoder.bytes(this.prev_block_hash);
        }
        if (this.outcome_root.length > 0) {
          encoder.uint32(0x1a);
          encoder.uint32(this.outcome_root.length);
          encoder.bytes(this.outcome_root);
        }
        if (this.prev_state_root.length > 0) {
          encoder.uint32(0x22);
          encoder.uint32(this.prev_state_root.length);
          encoder.bytes(this.prev_state_root);
        }
        if (this.encoded_merkle_root.length > 0) {
          encoder.uint32(0x2a);
          encoder.uint32(this.encoded_merkle_root.length);
          encoder.bytes(this.encoded_merkle_root);
        }
        if (this.encoded_length != 0) {
          encoder.uint32(0x30);
          encoder.uint64(this.encoded_length);
        }
        if (this.height_created != 0) {
          encoder.uint32(0x38);
          encoder.uint64(this.height_created);
        }
        if (this.height_included != 0) {
          encoder.uint32(0x40);
          encoder.uint64(this.height_included);
        }
        if (this.shard_id != 0) {
          encoder.uint32(0x48);
          encoder.uint64(this.shard_id);
        }
        if (this.gas_used != 0) {
          encoder.uint32(0x50);
          encoder.uint64(this.gas_used);
        }
        if (this.gas_limit != 0) {
          encoder.uint32(0x58);
          encoder.uint64(this.gas_limit);
        }

        if (this.validator_reward != null) {
          const f = this.validator_reward as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x62);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.balance_burnt != null) {
          const f = this.balance_burnt as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x6a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.outgoing_receipts_root.length > 0) {
          encoder.uint32(0x72);
          encoder.uint32(this.outgoing_receipts_root.length);
          encoder.bytes(this.outgoing_receipts_root);
        }
        if (this.tx_root.length > 0) {
          encoder.uint32(0x7a);
          encoder.uint32(this.tx_root.length);
          encoder.bytes(this.tx_root);
        }

        for (let n: i32 = 0; n < this.validator_proposals.length; n++) {
          const messageSize = this.validator_proposals[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x82);
            encoder.uint32(messageSize);
            this.validator_proposals[n].encodeU8Array(encoder);
          }
        }

        if (this.signature != null) {
          const f = this.signature as Signature;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x8a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode ChunkHeader
    } // ChunkHeader

    export class IndexerShard {
      public shard_id: u64;
      public chunk: IndexerChunk = new IndexerChunk();
      public receipt_execution_outcomes: Array<IndexerExecutionOutcomeWithReceipt> =
        new Array<IndexerExecutionOutcomeWithReceipt>();

      // Decodes IndexerShard from an ArrayBuffer
      static decode(buf: ArrayBuffer): IndexerShard {
        return IndexerShard.decodeDataView(new DataView(buf));
      }

      // Decodes IndexerShard from a DataView
      static decodeDataView(view: DataView): IndexerShard {
        const decoder = new __proto.Decoder(view);
        const obj = new IndexerShard();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.shard_id = decoder.uint64();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.chunk = IndexerChunk.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.receipt_execution_outcomes.push(
                IndexerExecutionOutcomeWithReceipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode IndexerShard

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.shard_id == 0 ? 0 : 1 + __proto.Sizer.uint64(this.shard_id);

        if (this.chunk != null) {
          const f: IndexerChunk = this.chunk as IndexerChunk;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.receipt_execution_outcomes.length; n++) {
          const messageSize = this.receipt_execution_outcomes[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes IndexerShard to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes IndexerShard to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.shard_id != 0) {
          encoder.uint32(0x8);
          encoder.uint64(this.shard_id);
        }

        if (this.chunk != null) {
          const f = this.chunk as IndexerChunk;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.receipt_execution_outcomes.length; n++) {
          const messageSize = this.receipt_execution_outcomes[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            this.receipt_execution_outcomes[n].encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode IndexerShard
    } // IndexerShard

    export class IndexerExecutionOutcomeWithReceipt {
      public execution_outcome: ExecutionOutcomeWithId =
        new ExecutionOutcomeWithId();
      public receipt: Receipt = new Receipt();

      // Decodes IndexerExecutionOutcomeWithReceipt from an ArrayBuffer
      static decode(buf: ArrayBuffer): IndexerExecutionOutcomeWithReceipt {
        return IndexerExecutionOutcomeWithReceipt.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes IndexerExecutionOutcomeWithReceipt from a DataView
      static decodeDataView(
        view: DataView
      ): IndexerExecutionOutcomeWithReceipt {
        const decoder = new __proto.Decoder(view);
        const obj = new IndexerExecutionOutcomeWithReceipt();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.receipt = Receipt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode IndexerExecutionOutcomeWithReceipt

      public size(): u32 {
        let size: u32 = 0;

        if (this.execution_outcome != null) {
          const f: ExecutionOutcomeWithId = this
            .execution_outcome as ExecutionOutcomeWithId;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.receipt != null) {
          const f: Receipt = this.receipt as Receipt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes IndexerExecutionOutcomeWithReceipt to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes IndexerExecutionOutcomeWithReceipt to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.execution_outcome != null) {
          const f = this.execution_outcome as ExecutionOutcomeWithId;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.receipt != null) {
          const f = this.receipt as Receipt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode IndexerExecutionOutcomeWithReceipt
    } // IndexerExecutionOutcomeWithReceipt

    export class IndexerChunk {
      public author: string = "";
      public header: ChunkHeader = new ChunkHeader();
      public transactions: Array<IndexerTransactionWithOutcome> =
        new Array<IndexerTransactionWithOutcome>();
      public receipts: Array<Receipt> = new Array<Receipt>();

      // Decodes IndexerChunk from an ArrayBuffer
      static decode(buf: ArrayBuffer): IndexerChunk {
        return IndexerChunk.decodeDataView(new DataView(buf));
      }

      // Decodes IndexerChunk from a DataView
      static decodeDataView(view: DataView): IndexerChunk {
        const decoder = new __proto.Decoder(view);
        const obj = new IndexerChunk();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.author = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.header = ChunkHeader.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.transactions.push(
                IndexerTransactionWithOutcome.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.receipts.push(
                Receipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode IndexerChunk

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.author.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.author.length) +
              this.author.length
            : 0;

        if (this.header != null) {
          const f: ChunkHeader = this.header as ChunkHeader;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.transactions.length; n++) {
          const messageSize = this.transactions[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.receipts.length; n++) {
          const messageSize = this.receipts[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes IndexerChunk to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes IndexerChunk to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.author.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.author.length);
          encoder.string(this.author);
        }

        if (this.header != null) {
          const f = this.header as ChunkHeader;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.transactions.length; n++) {
          const messageSize = this.transactions[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            this.transactions[n].encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.receipts.length; n++) {
          const messageSize = this.receipts[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            this.receipts[n].encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode IndexerChunk
    } // IndexerChunk

    export class IndexerTransactionWithOutcome {
      public transaction: SignedTransaction = new SignedTransaction();
      public outcome: IndexerExecutionOutcomeWithOptionalReceipt =
        new IndexerExecutionOutcomeWithOptionalReceipt();

      // Decodes IndexerTransactionWithOutcome from an ArrayBuffer
      static decode(buf: ArrayBuffer): IndexerTransactionWithOutcome {
        return IndexerTransactionWithOutcome.decodeDataView(new DataView(buf));
      }

      // Decodes IndexerTransactionWithOutcome from a DataView
      static decodeDataView(view: DataView): IndexerTransactionWithOutcome {
        const decoder = new __proto.Decoder(view);
        const obj = new IndexerTransactionWithOutcome();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.transaction = SignedTransaction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.outcome =
                IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode IndexerTransactionWithOutcome

      public size(): u32 {
        let size: u32 = 0;

        if (this.transaction != null) {
          const f: SignedTransaction = this.transaction as SignedTransaction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.outcome != null) {
          const f: IndexerExecutionOutcomeWithOptionalReceipt = this
            .outcome as IndexerExecutionOutcomeWithOptionalReceipt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes IndexerTransactionWithOutcome to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes IndexerTransactionWithOutcome to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.transaction != null) {
          const f = this.transaction as SignedTransaction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.outcome != null) {
          const f = this.outcome as IndexerExecutionOutcomeWithOptionalReceipt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode IndexerTransactionWithOutcome
    } // IndexerTransactionWithOutcome

    export class SignedTransaction {
      public signer_id: string = "";
      public public_key: PublicKey = new PublicKey();
      public nonce: u64;
      public receiver_id: string = "";
      public actions: Array<Action> = new Array<Action>();
      public signature: Signature = new Signature();
      public hash: CryptoHash = new CryptoHash();

      // Decodes SignedTransaction from an ArrayBuffer
      static decode(buf: ArrayBuffer): SignedTransaction {
        return SignedTransaction.decodeDataView(new DataView(buf));
      }

      // Decodes SignedTransaction from a DataView
      static decodeDataView(view: DataView): SignedTransaction {
        const decoder = new __proto.Decoder(view);
        const obj = new SignedTransaction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.signer_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              obj.nonce = decoder.uint64();
              break;
            }
            case 4: {
              obj.receiver_id = decoder.string();
              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.actions.push(
                Action.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.signature = Signature.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 7: {
              const length = decoder.uint32();
              obj.hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode SignedTransaction

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.signer_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.signer_id.length) +
              this.signer_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);
        size +=
          this.receiver_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.receiver_id.length) +
              this.receiver_id.length
            : 0;

        for (let n: i32 = 0; n < this.actions.length; n++) {
          const messageSize = this.actions[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.signature != null) {
          const f: Signature = this.signature as Signature;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.hash != null) {
          const f: CryptoHash = this.hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes SignedTransaction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes SignedTransaction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.signer_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.signer_id.length);
          encoder.string(this.signer_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.nonce != 0) {
          encoder.uint32(0x18);
          encoder.uint64(this.nonce);
        }
        if (this.receiver_id.length > 0) {
          encoder.uint32(0x22);
          encoder.uint32(this.receiver_id.length);
          encoder.string(this.receiver_id);
        }

        for (let n: i32 = 0; n < this.actions.length; n++) {
          const messageSize = this.actions[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            this.actions[n].encodeU8Array(encoder);
          }
        }

        if (this.signature != null) {
          const f = this.signature as Signature;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.hash != null) {
          const f = this.hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x3a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode SignedTransaction
    } // SignedTransaction

    export class IndexerExecutionOutcomeWithOptionalReceipt {
      public execution_outcome: ExecutionOutcomeWithId =
        new ExecutionOutcomeWithId();
      public receipt: Receipt = new Receipt();

      // Decodes IndexerExecutionOutcomeWithOptionalReceipt from an ArrayBuffer
      static decode(
        buf: ArrayBuffer
      ): IndexerExecutionOutcomeWithOptionalReceipt {
        return IndexerExecutionOutcomeWithOptionalReceipt.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes IndexerExecutionOutcomeWithOptionalReceipt from a DataView
      static decodeDataView(
        view: DataView
      ): IndexerExecutionOutcomeWithOptionalReceipt {
        const decoder = new __proto.Decoder(view);
        const obj = new IndexerExecutionOutcomeWithOptionalReceipt();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.execution_outcome = ExecutionOutcomeWithId.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.receipt = Receipt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode IndexerExecutionOutcomeWithOptionalReceipt

      public size(): u32 {
        let size: u32 = 0;

        if (this.execution_outcome != null) {
          const f: ExecutionOutcomeWithId = this
            .execution_outcome as ExecutionOutcomeWithId;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.receipt != null) {
          const f: Receipt = this.receipt as Receipt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes IndexerExecutionOutcomeWithOptionalReceipt to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.execution_outcome != null) {
          const f = this.execution_outcome as ExecutionOutcomeWithId;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.receipt != null) {
          const f = this.receipt as Receipt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode IndexerExecutionOutcomeWithOptionalReceipt
    } // IndexerExecutionOutcomeWithOptionalReceipt

    export class Receipt {
      public predecessor_id: string = "";
      public receiver_id: string = "";
      public receipt_id: CryptoHash = new CryptoHash();
      public action: ReceiptAction | null;
      public data: ReceiptData | null;

      public __receipt: string = "";
      public __receipt_index: u8 = 0;

      static readonly RECEIPT_ACTION_INDEX: u8 = 10;
      static readonly RECEIPT_DATA_INDEX: u8 = 11;

      // Decodes Receipt from an ArrayBuffer
      static decode(buf: ArrayBuffer): Receipt {
        return Receipt.decodeDataView(new DataView(buf));
      }

      // Decodes Receipt from a DataView
      static decodeDataView(view: DataView): Receipt {
        const decoder = new __proto.Decoder(view);
        const obj = new Receipt();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.predecessor_id = decoder.string();
              break;
            }
            case 2: {
              obj.receiver_id = decoder.string();
              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.receipt_id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 10: {
              const length = decoder.uint32();
              obj.action = ReceiptAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__receipt = "action";
              obj.__receipt_index = 10;
              break;
            }
            case 11: {
              const length = decoder.uint32();
              obj.data = ReceiptData.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__receipt = "data";
              obj.__receipt_index = 11;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode Receipt

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.predecessor_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.predecessor_id.length) +
              this.predecessor_id.length
            : 0;
        size +=
          this.receiver_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.receiver_id.length) +
              this.receiver_id.length
            : 0;

        if (this.receipt_id != null) {
          const f: CryptoHash = this.receipt_id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.action != null) {
          const f: ReceiptAction = this.action as ReceiptAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.data != null) {
          const f: ReceiptData = this.data as ReceiptData;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes Receipt to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes Receipt to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.predecessor_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.predecessor_id.length);
          encoder.string(this.predecessor_id);
        }
        if (this.receiver_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.receiver_id.length);
          encoder.string(this.receiver_id);
        }

        if (this.receipt_id != null) {
          const f = this.receipt_id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.action != null) {
          const f = this.action as ReceiptAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x52);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.data != null) {
          const f = this.data as ReceiptData;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x5a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode Receipt
    } // Receipt

    export class ReceiptData {
      public data_id: CryptoHash = new CryptoHash();
      public data: Array<u8> = new Array<u8>();

      // Decodes ReceiptData from an ArrayBuffer
      static decode(buf: ArrayBuffer): ReceiptData {
        return ReceiptData.decodeDataView(new DataView(buf));
      }

      // Decodes ReceiptData from a DataView
      static decodeDataView(view: DataView): ReceiptData {
        const decoder = new __proto.Decoder(view);
        const obj = new ReceiptData();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.data_id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              obj.data = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ReceiptData

      public size(): u32 {
        let size: u32 = 0;

        if (this.data_id != null) {
          const f: CryptoHash = this.data_id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.data.length > 0
            ? 1 + __proto.Sizer.varint64(this.data.length) + this.data.length
            : 0;

        return size;
      }

      // Encodes ReceiptData to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ReceiptData to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.data_id != null) {
          const f = this.data_id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.data.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.data.length);
          encoder.bytes(this.data);
        }

        return buf;
      } // encode ReceiptData
    } // ReceiptData

    export class ReceiptAction {
      public signer_id: string = "";
      public signer_public_key: PublicKey = new PublicKey();
      public gas_price: BigInt = new BigInt();
      public output_data_receivers: Array<DataReceiver> =
        new Array<DataReceiver>();
      public input_data_ids: Array<CryptoHash> = new Array<CryptoHash>();
      public actions: Array<Action> = new Array<Action>();

      // Decodes ReceiptAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): ReceiptAction {
        return ReceiptAction.decodeDataView(new DataView(buf));
      }

      // Decodes ReceiptAction from a DataView
      static decodeDataView(view: DataView): ReceiptAction {
        const decoder = new __proto.Decoder(view);
        const obj = new ReceiptAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.signer_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.signer_public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.gas_price = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.output_data_receivers.push(
                DataReceiver.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.input_data_ids.push(
                CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.actions.push(
                Action.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ReceiptAction

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.signer_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.signer_id.length) +
              this.signer_id.length
            : 0;

        if (this.signer_public_key != null) {
          const f: PublicKey = this.signer_public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.gas_price != null) {
          const f: BigInt = this.gas_price as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
          const messageSize = this.output_data_receivers[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
          const messageSize = this.input_data_ids[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        for (let n: i32 = 0; n < this.actions.length; n++) {
          const messageSize = this.actions[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes ReceiptAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ReceiptAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.signer_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.signer_id.length);
          encoder.string(this.signer_id);
        }

        if (this.signer_public_key != null) {
          const f = this.signer_public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.gas_price != null) {
          const f = this.gas_price as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.output_data_receivers.length; n++) {
          const messageSize = this.output_data_receivers[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            this.output_data_receivers[n].encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.input_data_ids.length; n++) {
          const messageSize = this.input_data_ids[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            this.input_data_ids[n].encodeU8Array(encoder);
          }
        }

        for (let n: i32 = 0; n < this.actions.length; n++) {
          const messageSize = this.actions[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            this.actions[n].encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode ReceiptAction
    } // ReceiptAction

    export class DataReceiver {
      public data_id: CryptoHash = new CryptoHash();
      public receiver_id: string = "";

      // Decodes DataReceiver from an ArrayBuffer
      static decode(buf: ArrayBuffer): DataReceiver {
        return DataReceiver.decodeDataView(new DataView(buf));
      }

      // Decodes DataReceiver from a DataView
      static decodeDataView(view: DataView): DataReceiver {
        const decoder = new __proto.Decoder(view);
        const obj = new DataReceiver();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.data_id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              obj.receiver_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DataReceiver

      public size(): u32 {
        let size: u32 = 0;

        if (this.data_id != null) {
          const f: CryptoHash = this.data_id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.receiver_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.receiver_id.length) +
              this.receiver_id.length
            : 0;

        return size;
      }

      // Encodes DataReceiver to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DataReceiver to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.data_id != null) {
          const f = this.data_id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.receiver_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.receiver_id.length);
          encoder.string(this.receiver_id);
        }

        return buf;
      } // encode DataReceiver
    } // DataReceiver

    export class ExecutionOutcomeWithId {
      public proof: MerklePath = new MerklePath();
      public block_hash: CryptoHash = new CryptoHash();
      public id: CryptoHash = new CryptoHash();
      public outcome: ExecutionOutcome = new ExecutionOutcome();

      // Decodes ExecutionOutcomeWithId from an ArrayBuffer
      static decode(buf: ArrayBuffer): ExecutionOutcomeWithId {
        return ExecutionOutcomeWithId.decodeDataView(new DataView(buf));
      }

      // Decodes ExecutionOutcomeWithId from a DataView
      static decodeDataView(view: DataView): ExecutionOutcomeWithId {
        const decoder = new __proto.Decoder(view);
        const obj = new ExecutionOutcomeWithId();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.proof = MerklePath.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.block_hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.outcome = ExecutionOutcome.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ExecutionOutcomeWithId

      public size(): u32 {
        let size: u32 = 0;

        if (this.proof != null) {
          const f: MerklePath = this.proof as MerklePath;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.block_hash != null) {
          const f: CryptoHash = this.block_hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.id != null) {
          const f: CryptoHash = this.id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.outcome != null) {
          const f: ExecutionOutcome = this.outcome as ExecutionOutcome;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes ExecutionOutcomeWithId to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ExecutionOutcomeWithId to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.proof != null) {
          const f = this.proof as MerklePath;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.block_hash != null) {
          const f = this.block_hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.id != null) {
          const f = this.id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.outcome != null) {
          const f = this.outcome as ExecutionOutcome;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode ExecutionOutcomeWithId
    } // ExecutionOutcomeWithId

    export class ExecutionOutcome {
      public logs: Array<string> = new Array<string>();
      public receipt_ids: Array<CryptoHash> = new Array<CryptoHash>();
      public gas_burnt: u64;
      public tokens_burnt: BigInt = new BigInt();
      public executor_id: string = "";
      public unknown: UnknownExecutionStatus | null;
      public failure: FailureExecutionStatus | null;
      public success_value: SuccessValueExecutionStatus | null;
      public success_receipt_id: SuccessReceiptIdExecutionStatus | null;
      public metadata: u32;

      public __status: string = "";
      public __status_index: u8 = 0;

      static readonly STATUS_UNKNOWN_INDEX: u8 = 20;
      static readonly STATUS_FAILURE_INDEX: u8 = 21;
      static readonly STATUS_SUCCESS_VALUE_INDEX: u8 = 22;
      static readonly STATUS_SUCCESS_RECEIPT_ID_INDEX: u8 = 23;

      // Decodes ExecutionOutcome from an ArrayBuffer
      static decode(buf: ArrayBuffer): ExecutionOutcome {
        return ExecutionOutcome.decodeDataView(new DataView(buf));
      }

      // Decodes ExecutionOutcome from a DataView
      static decodeDataView(view: DataView): ExecutionOutcome {
        const decoder = new __proto.Decoder(view);
        const obj = new ExecutionOutcome();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.logs.push(decoder.string());
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.receipt_ids.push(
                CryptoHash.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              obj.gas_burnt = decoder.uint64();
              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.tokens_burnt = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 5: {
              obj.executor_id = decoder.string();
              break;
            }
            case 20: {
              const length = decoder.uint32();
              obj.unknown = UnknownExecutionStatus.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__status = "unknown";
              obj.__status_index = 20;
              break;
            }
            case 21: {
              const length = decoder.uint32();
              obj.failure = FailureExecutionStatus.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__status = "failure";
              obj.__status_index = 21;
              break;
            }
            case 22: {
              const length = decoder.uint32();
              obj.success_value = SuccessValueExecutionStatus.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__status = "success_value";
              obj.__status_index = 22;
              break;
            }
            case 23: {
              const length = decoder.uint32();
              obj.success_receipt_id =
                SuccessReceiptIdExecutionStatus.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__status = "success_receipt_id";
              obj.__status_index = 23;
              break;
            }
            case 6: {
              obj.metadata = decoder.uint32();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ExecutionOutcome

      public size(): u32 {
        let size: u32 = 0;

        size += __size_string_repeated(this.logs);

        for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
          const messageSize = this.receipt_ids[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.gas_burnt == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas_burnt);

        if (this.tokens_burnt != null) {
          const f: BigInt = this.tokens_burnt as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.executor_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.executor_id.length) +
              this.executor_id.length
            : 0;

        if (this.unknown != null) {
          const f: UnknownExecutionStatus = this
            .unknown as UnknownExecutionStatus;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.failure != null) {
          const f: FailureExecutionStatus = this
            .failure as FailureExecutionStatus;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.success_value != null) {
          const f: SuccessValueExecutionStatus = this
            .success_value as SuccessValueExecutionStatus;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.success_receipt_id != null) {
          const f: SuccessReceiptIdExecutionStatus = this
            .success_receipt_id as SuccessReceiptIdExecutionStatus;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.metadata == 0 ? 0 : 1 + __proto.Sizer.uint32(this.metadata);

        return size;
      }

      // Encodes ExecutionOutcome to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ExecutionOutcome to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.logs.length > 0) {
          for (let n: i32 = 0; n < this.logs.length; n++) {
            encoder.uint32(0xa);
            encoder.uint32(this.logs[n].length);
            encoder.string(this.logs[n]);
          }
        }

        for (let n: i32 = 0; n < this.receipt_ids.length; n++) {
          const messageSize = this.receipt_ids[n].size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            this.receipt_ids[n].encodeU8Array(encoder);
          }
        }

        if (this.gas_burnt != 0) {
          encoder.uint32(0x18);
          encoder.uint64(this.gas_burnt);
        }

        if (this.tokens_burnt != null) {
          const f = this.tokens_burnt as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.executor_id.length > 0) {
          encoder.uint32(0x2a);
          encoder.uint32(this.executor_id.length);
          encoder.string(this.executor_id);
        }

        if (this.unknown != null) {
          const f = this.unknown as UnknownExecutionStatus;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.failure != null) {
          const f = this.failure as FailureExecutionStatus;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xaa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.success_value != null) {
          const f = this.success_value as SuccessValueExecutionStatus;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xb2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.success_receipt_id != null) {
          const f = this.success_receipt_id as SuccessReceiptIdExecutionStatus;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xba);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.metadata != 0) {
          encoder.uint32(0x30);
          encoder.uint32(this.metadata);
        }

        return buf;
      } // encode ExecutionOutcome
    } // ExecutionOutcome

    export class SuccessValueExecutionStatus {
      public value: Array<u8> = new Array<u8>();

      // Decodes SuccessValueExecutionStatus from an ArrayBuffer
      static decode(buf: ArrayBuffer): SuccessValueExecutionStatus {
        return SuccessValueExecutionStatus.decodeDataView(new DataView(buf));
      }

      // Decodes SuccessValueExecutionStatus from a DataView
      static decodeDataView(view: DataView): SuccessValueExecutionStatus {
        const decoder = new __proto.Decoder(view);
        const obj = new SuccessValueExecutionStatus();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.value = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode SuccessValueExecutionStatus

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.value.length > 0
            ? 1 + __proto.Sizer.varint64(this.value.length) + this.value.length
            : 0;

        return size;
      }

      // Encodes SuccessValueExecutionStatus to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes SuccessValueExecutionStatus to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.value.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.value.length);
          encoder.bytes(this.value);
        }

        return buf;
      } // encode SuccessValueExecutionStatus
    } // SuccessValueExecutionStatus

    export class SuccessReceiptIdExecutionStatus {
      public id: CryptoHash = new CryptoHash();

      // Decodes SuccessReceiptIdExecutionStatus from an ArrayBuffer
      static decode(buf: ArrayBuffer): SuccessReceiptIdExecutionStatus {
        return SuccessReceiptIdExecutionStatus.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes SuccessReceiptIdExecutionStatus from a DataView
      static decodeDataView(view: DataView): SuccessReceiptIdExecutionStatus {
        const decoder = new __proto.Decoder(view);
        const obj = new SuccessReceiptIdExecutionStatus();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.id = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode SuccessReceiptIdExecutionStatus

      public size(): u32 {
        let size: u32 = 0;

        if (this.id != null) {
          const f: CryptoHash = this.id as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes SuccessReceiptIdExecutionStatus to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes SuccessReceiptIdExecutionStatus to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.id != null) {
          const f = this.id as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode SuccessReceiptIdExecutionStatus
    } // SuccessReceiptIdExecutionStatus

    export class UnknownExecutionStatus {
      // Decodes UnknownExecutionStatus from an ArrayBuffer
      static decode(buf: ArrayBuffer): UnknownExecutionStatus {
        return UnknownExecutionStatus.decodeDataView(new DataView(buf));
      }

      // Decodes UnknownExecutionStatus from a DataView
      static decodeDataView(view: DataView): UnknownExecutionStatus {
        const decoder = new __proto.Decoder(view);
        const obj = new UnknownExecutionStatus();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode UnknownExecutionStatus

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes UnknownExecutionStatus to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes UnknownExecutionStatus to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode UnknownExecutionStatus
    } // UnknownExecutionStatus

    export class FailureExecutionStatus {
      public action_error: ActionError | null;
      public invalid_tx_error: u32;

      public __failure: string = "";
      public __failure_index: u8 = 0;

      static readonly FAILURE_ACTION_ERROR_INDEX: u8 = 1;
      static readonly FAILURE_INVALID_TX_ERROR_INDEX: u8 = 2;

      // Decodes FailureExecutionStatus from an ArrayBuffer
      static decode(buf: ArrayBuffer): FailureExecutionStatus {
        return FailureExecutionStatus.decodeDataView(new DataView(buf));
      }

      // Decodes FailureExecutionStatus from a DataView
      static decodeDataView(view: DataView): FailureExecutionStatus {
        const decoder = new __proto.Decoder(view);
        const obj = new FailureExecutionStatus();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.action_error = ActionError.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__failure = "action_error";
              obj.__failure_index = 1;
              break;
            }
            case 2: {
              obj.invalid_tx_error = decoder.uint32();
              obj.__failure = "invalid_tx_error";
              obj.__failure_index = 2;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode FailureExecutionStatus

      public size(): u32 {
        let size: u32 = 0;

        if (this.action_error != null) {
          const f: ActionError = this.action_error as ActionError;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.invalid_tx_error == 0
            ? 0
            : 1 + __proto.Sizer.uint32(this.invalid_tx_error);

        return size;
      }

      // Encodes FailureExecutionStatus to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes FailureExecutionStatus to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.action_error != null) {
          const f = this.action_error as ActionError;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.invalid_tx_error != 0) {
          encoder.uint32(0x10);
          encoder.uint32(this.invalid_tx_error);
        }

        return buf;
      } // encode FailureExecutionStatus
    } // FailureExecutionStatus

    export class ActionError {
      public index: u64;
      public account_already_exist: AccountAlreadyExistsErrorKind | null;
      public account_does_not_exist: AccountDoesNotExistErrorKind | null;
      public create_account_only_by_registrar: CreateAccountOnlyByRegistrarErrorKind | null;
      public create_account_not_allowed: CreateAccountNotAllowedErrorKind | null;
      public actor_no_permission: ActorNoPermissionErrorKind | null;
      public delete_key_does_not_exist: DeleteKeyDoesNotExistErrorKind | null;
      public add_key_already_exists: AddKeyAlreadyExistsErrorKind | null;
      public delete_account_staking: DeleteAccountStakingErrorKind | null;
      public lack_balance_for_state: LackBalanceForStateErrorKind | null;
      public tries_to_unstake: TriesToUnstakeErrorKind | null;
      public tries_to_stake: TriesToStakeErrorKind | null;
      public insufficient_stake: InsufficientStakeErrorKind | null;
      public function_call: FunctionCallErrorKind | null;
      public new_receipt_validation: NewReceiptValidationErrorKind | null;
      public only_implicit_account_creation_allowed: OnlyImplicitAccountCreationAllowedErrorKind | null;
      public delete_account_with_large_state: DeleteAccountWithLargeStateErrorKind | null;

      public __kind: string = "";
      public __kind_index: u8 = 0;

      static readonly KIND_ACCOUNT_ALREADY_EXIST_INDEX: u8 = 21;
      static readonly KIND_ACCOUNT_DOES_NOT_EXIST_INDEX: u8 = 22;
      static readonly KIND_CREATE_ACCOUNT_ONLY_BY_REGISTRAR_INDEX: u8 = 23;
      static readonly KIND_CREATE_ACCOUNT_NOT_ALLOWED_INDEX: u8 = 24;
      static readonly KIND_ACTOR_NO_PERMISSION_INDEX: u8 = 25;
      static readonly KIND_DELETE_KEY_DOES_NOT_EXIST_INDEX: u8 = 26;
      static readonly KIND_ADD_KEY_ALREADY_EXISTS_INDEX: u8 = 27;
      static readonly KIND_DELETE_ACCOUNT_STAKING_INDEX: u8 = 28;
      static readonly KIND_LACK_BALANCE_FOR_STATE_INDEX: u8 = 29;
      static readonly KIND_TRIES_TO_UNSTAKE_INDEX: u8 = 30;
      static readonly KIND_TRIES_TO_STAKE_INDEX: u8 = 31;
      static readonly KIND_INSUFFICIENT_STAKE_INDEX: u8 = 32;
      static readonly KIND_FUNCTION_CALL_INDEX: u8 = 33;
      static readonly KIND_NEW_RECEIPT_VALIDATION_INDEX: u8 = 34;
      static readonly KIND_ONLY_IMPLICIT_ACCOUNT_CREATION_ALLOWED_INDEX: u8 = 35;
      static readonly KIND_DELETE_ACCOUNT_WITH_LARGE_STATE_INDEX: u8 = 36;

      // Decodes ActionError from an ArrayBuffer
      static decode(buf: ArrayBuffer): ActionError {
        return ActionError.decodeDataView(new DataView(buf));
      }

      // Decodes ActionError from a DataView
      static decodeDataView(view: DataView): ActionError {
        const decoder = new __proto.Decoder(view);
        const obj = new ActionError();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.index = decoder.uint64();
              break;
            }
            case 21: {
              const length = decoder.uint32();
              obj.account_already_exist =
                AccountAlreadyExistsErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "account_already_exist";
              obj.__kind_index = 21;
              break;
            }
            case 22: {
              const length = decoder.uint32();
              obj.account_does_not_exist =
                AccountDoesNotExistErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "account_does_not_exist";
              obj.__kind_index = 22;
              break;
            }
            case 23: {
              const length = decoder.uint32();
              obj.create_account_only_by_registrar =
                CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "create_account_only_by_registrar";
              obj.__kind_index = 23;
              break;
            }
            case 24: {
              const length = decoder.uint32();
              obj.create_account_not_allowed =
                CreateAccountNotAllowedErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "create_account_not_allowed";
              obj.__kind_index = 24;
              break;
            }
            case 25: {
              const length = decoder.uint32();
              obj.actor_no_permission =
                ActorNoPermissionErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "actor_no_permission";
              obj.__kind_index = 25;
              break;
            }
            case 26: {
              const length = decoder.uint32();
              obj.delete_key_does_not_exist =
                DeleteKeyDoesNotExistErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "delete_key_does_not_exist";
              obj.__kind_index = 26;
              break;
            }
            case 27: {
              const length = decoder.uint32();
              obj.add_key_already_exists =
                AddKeyAlreadyExistsErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "add_key_already_exists";
              obj.__kind_index = 27;
              break;
            }
            case 28: {
              const length = decoder.uint32();
              obj.delete_account_staking =
                DeleteAccountStakingErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "delete_account_staking";
              obj.__kind_index = 28;
              break;
            }
            case 29: {
              const length = decoder.uint32();
              obj.lack_balance_for_state =
                LackBalanceForStateErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "lack_balance_for_state";
              obj.__kind_index = 29;
              break;
            }
            case 30: {
              const length = decoder.uint32();
              obj.tries_to_unstake = TriesToUnstakeErrorKind.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__kind = "tries_to_unstake";
              obj.__kind_index = 30;
              break;
            }
            case 31: {
              const length = decoder.uint32();
              obj.tries_to_stake = TriesToStakeErrorKind.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__kind = "tries_to_stake";
              obj.__kind_index = 31;
              break;
            }
            case 32: {
              const length = decoder.uint32();
              obj.insufficient_stake =
                InsufficientStakeErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "insufficient_stake";
              obj.__kind_index = 32;
              break;
            }
            case 33: {
              const length = decoder.uint32();
              obj.function_call = FunctionCallErrorKind.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__kind = "function_call";
              obj.__kind_index = 33;
              break;
            }
            case 34: {
              const length = decoder.uint32();
              obj.new_receipt_validation =
                NewReceiptValidationErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "new_receipt_validation";
              obj.__kind_index = 34;
              break;
            }
            case 35: {
              const length = decoder.uint32();
              obj.only_implicit_account_creation_allowed =
                OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "only_implicit_account_creation_allowed";
              obj.__kind_index = 35;
              break;
            }
            case 36: {
              const length = decoder.uint32();
              obj.delete_account_with_large_state =
                DeleteAccountWithLargeStateErrorKind.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                );
              decoder.skip(length);

              obj.__kind = "delete_account_with_large_state";
              obj.__kind_index = 36;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ActionError

      public size(): u32 {
        let size: u32 = 0;

        size += this.index == 0 ? 0 : 1 + __proto.Sizer.uint64(this.index);

        if (this.account_already_exist != null) {
          const f: AccountAlreadyExistsErrorKind = this
            .account_already_exist as AccountAlreadyExistsErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.account_does_not_exist != null) {
          const f: AccountDoesNotExistErrorKind = this
            .account_does_not_exist as AccountDoesNotExistErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.create_account_only_by_registrar != null) {
          const f: CreateAccountOnlyByRegistrarErrorKind = this
            .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.create_account_not_allowed != null) {
          const f: CreateAccountNotAllowedErrorKind = this
            .create_account_not_allowed as CreateAccountNotAllowedErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.actor_no_permission != null) {
          const f: ActorNoPermissionErrorKind = this
            .actor_no_permission as ActorNoPermissionErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.delete_key_does_not_exist != null) {
          const f: DeleteKeyDoesNotExistErrorKind = this
            .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.add_key_already_exists != null) {
          const f: AddKeyAlreadyExistsErrorKind = this
            .add_key_already_exists as AddKeyAlreadyExistsErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.delete_account_staking != null) {
          const f: DeleteAccountStakingErrorKind = this
            .delete_account_staking as DeleteAccountStakingErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.lack_balance_for_state != null) {
          const f: LackBalanceForStateErrorKind = this
            .lack_balance_for_state as LackBalanceForStateErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.tries_to_unstake != null) {
          const f: TriesToUnstakeErrorKind = this
            .tries_to_unstake as TriesToUnstakeErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.tries_to_stake != null) {
          const f: TriesToStakeErrorKind = this
            .tries_to_stake as TriesToStakeErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.insufficient_stake != null) {
          const f: InsufficientStakeErrorKind = this
            .insufficient_stake as InsufficientStakeErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.function_call != null) {
          const f: FunctionCallErrorKind = this
            .function_call as FunctionCallErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.new_receipt_validation != null) {
          const f: NewReceiptValidationErrorKind = this
            .new_receipt_validation as NewReceiptValidationErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.only_implicit_account_creation_allowed != null) {
          const f: OnlyImplicitAccountCreationAllowedErrorKind = this
            .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.delete_account_with_large_state != null) {
          const f: DeleteAccountWithLargeStateErrorKind = this
            .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 2 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes ActionError to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ActionError to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.index != 0) {
          encoder.uint32(0x8);
          encoder.uint64(this.index);
        }

        if (this.account_already_exist != null) {
          const f = this.account_already_exist as AccountAlreadyExistsErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xaa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.account_does_not_exist != null) {
          const f = this.account_does_not_exist as AccountDoesNotExistErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xb2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.create_account_only_by_registrar != null) {
          const f = this
            .create_account_only_by_registrar as CreateAccountOnlyByRegistrarErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xba);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.create_account_not_allowed != null) {
          const f = this
            .create_account_not_allowed as CreateAccountNotAllowedErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xc2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.actor_no_permission != null) {
          const f = this.actor_no_permission as ActorNoPermissionErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xca);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.delete_key_does_not_exist != null) {
          const f = this
            .delete_key_does_not_exist as DeleteKeyDoesNotExistErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xd2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.add_key_already_exists != null) {
          const f = this.add_key_already_exists as AddKeyAlreadyExistsErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xda);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.delete_account_staking != null) {
          const f = this
            .delete_account_staking as DeleteAccountStakingErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xe2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.lack_balance_for_state != null) {
          const f = this.lack_balance_for_state as LackBalanceForStateErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xea);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.tries_to_unstake != null) {
          const f = this.tries_to_unstake as TriesToUnstakeErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xf2);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.tries_to_stake != null) {
          const f = this.tries_to_stake as TriesToStakeErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xfa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.insufficient_stake != null) {
          const f = this.insufficient_stake as InsufficientStakeErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x102);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.function_call != null) {
          const f = this.function_call as FunctionCallErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x10a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.new_receipt_validation != null) {
          const f = this
            .new_receipt_validation as NewReceiptValidationErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x112);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.only_implicit_account_creation_allowed != null) {
          const f = this
            .only_implicit_account_creation_allowed as OnlyImplicitAccountCreationAllowedErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x11a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.delete_account_with_large_state != null) {
          const f = this
            .delete_account_with_large_state as DeleteAccountWithLargeStateErrorKind;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x122);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode ActionError
    } // ActionError

    export class AccountAlreadyExistsErrorKind {
      public account_id: string = "";

      // Decodes AccountAlreadyExistsErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): AccountAlreadyExistsErrorKind {
        return AccountAlreadyExistsErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes AccountAlreadyExistsErrorKind from a DataView
      static decodeDataView(view: DataView): AccountAlreadyExistsErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new AccountAlreadyExistsErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AccountAlreadyExistsErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes AccountAlreadyExistsErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AccountAlreadyExistsErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode AccountAlreadyExistsErrorKind
    } // AccountAlreadyExistsErrorKind

    export class AccountDoesNotExistErrorKind {
      public account_id: string = "";

      // Decodes AccountDoesNotExistErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): AccountDoesNotExistErrorKind {
        return AccountDoesNotExistErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes AccountDoesNotExistErrorKind from a DataView
      static decodeDataView(view: DataView): AccountDoesNotExistErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new AccountDoesNotExistErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AccountDoesNotExistErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes AccountDoesNotExistErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AccountDoesNotExistErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode AccountDoesNotExistErrorKind
    } // AccountDoesNotExistErrorKind

    // / A top-level account ID can only be created by registrar.
    export class CreateAccountOnlyByRegistrarErrorKind {
      public account_id: string = "";
      public registrar_account_id: string = "";
      public predecessor_id: string = "";

      // Decodes CreateAccountOnlyByRegistrarErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): CreateAccountOnlyByRegistrarErrorKind {
        return CreateAccountOnlyByRegistrarErrorKind.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes CreateAccountOnlyByRegistrarErrorKind from a DataView
      static decodeDataView(
        view: DataView
      ): CreateAccountOnlyByRegistrarErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new CreateAccountOnlyByRegistrarErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.registrar_account_id = decoder.string();
              break;
            }
            case 3: {
              obj.predecessor_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode CreateAccountOnlyByRegistrarErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.registrar_account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.registrar_account_id.length) +
              this.registrar_account_id.length
            : 0;
        size +=
          this.predecessor_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.predecessor_id.length) +
              this.predecessor_id.length
            : 0;

        return size;
      }

      // Encodes CreateAccountOnlyByRegistrarErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes CreateAccountOnlyByRegistrarErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.registrar_account_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.registrar_account_id.length);
          encoder.string(this.registrar_account_id);
        }
        if (this.predecessor_id.length > 0) {
          encoder.uint32(0x1a);
          encoder.uint32(this.predecessor_id.length);
          encoder.string(this.predecessor_id);
        }

        return buf;
      } // encode CreateAccountOnlyByRegistrarErrorKind
    } // CreateAccountOnlyByRegistrarErrorKind

    export class CreateAccountNotAllowedErrorKind {
      public account_id: string = "";
      public predecessor_id: string = "";

      // Decodes CreateAccountNotAllowedErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): CreateAccountNotAllowedErrorKind {
        return CreateAccountNotAllowedErrorKind.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes CreateAccountNotAllowedErrorKind from a DataView
      static decodeDataView(view: DataView): CreateAccountNotAllowedErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new CreateAccountNotAllowedErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.predecessor_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode CreateAccountNotAllowedErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.predecessor_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.predecessor_id.length) +
              this.predecessor_id.length
            : 0;

        return size;
      }

      // Encodes CreateAccountNotAllowedErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes CreateAccountNotAllowedErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.predecessor_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.predecessor_id.length);
          encoder.string(this.predecessor_id);
        }

        return buf;
      } // encode CreateAccountNotAllowedErrorKind
    } // CreateAccountNotAllowedErrorKind

    export class ActorNoPermissionErrorKind {
      public account_id: string = "";
      public actor_id: string = "";

      // Decodes ActorNoPermissionErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): ActorNoPermissionErrorKind {
        return ActorNoPermissionErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes ActorNoPermissionErrorKind from a DataView
      static decodeDataView(view: DataView): ActorNoPermissionErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new ActorNoPermissionErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              obj.actor_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode ActorNoPermissionErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;
        size +=
          this.actor_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.actor_id.length) +
              this.actor_id.length
            : 0;

        return size;
      }

      // Encodes ActorNoPermissionErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes ActorNoPermissionErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }
        if (this.actor_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.actor_id.length);
          encoder.string(this.actor_id);
        }

        return buf;
      } // encode ActorNoPermissionErrorKind
    } // ActorNoPermissionErrorKind

    export class DeleteKeyDoesNotExistErrorKind {
      public account_id: string = "";
      public public_key: PublicKey = new PublicKey();

      // Decodes DeleteKeyDoesNotExistErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeleteKeyDoesNotExistErrorKind {
        return DeleteKeyDoesNotExistErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes DeleteKeyDoesNotExistErrorKind from a DataView
      static decodeDataView(view: DataView): DeleteKeyDoesNotExistErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new DeleteKeyDoesNotExistErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeleteKeyDoesNotExistErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes DeleteKeyDoesNotExistErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeleteKeyDoesNotExistErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode DeleteKeyDoesNotExistErrorKind
    } // DeleteKeyDoesNotExistErrorKind

    export class AddKeyAlreadyExistsErrorKind {
      public account_id: string = "";
      public public_key: PublicKey = new PublicKey();

      // Decodes AddKeyAlreadyExistsErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): AddKeyAlreadyExistsErrorKind {
        return AddKeyAlreadyExistsErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes AddKeyAlreadyExistsErrorKind from a DataView
      static decodeDataView(view: DataView): AddKeyAlreadyExistsErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new AddKeyAlreadyExistsErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AddKeyAlreadyExistsErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes AddKeyAlreadyExistsErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AddKeyAlreadyExistsErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode AddKeyAlreadyExistsErrorKind
    } // AddKeyAlreadyExistsErrorKind

    export class DeleteAccountStakingErrorKind {
      public account_id: string = "";

      // Decodes DeleteAccountStakingErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeleteAccountStakingErrorKind {
        return DeleteAccountStakingErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes DeleteAccountStakingErrorKind from a DataView
      static decodeDataView(view: DataView): DeleteAccountStakingErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new DeleteAccountStakingErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeleteAccountStakingErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes DeleteAccountStakingErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeleteAccountStakingErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode DeleteAccountStakingErrorKind
    } // DeleteAccountStakingErrorKind

    export class LackBalanceForStateErrorKind {
      public account_id: string = "";
      public balance: BigInt = new BigInt();

      // Decodes LackBalanceForStateErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): LackBalanceForStateErrorKind {
        return LackBalanceForStateErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes LackBalanceForStateErrorKind from a DataView
      static decodeDataView(view: DataView): LackBalanceForStateErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new LackBalanceForStateErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.balance = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode LackBalanceForStateErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.balance != null) {
          const f: BigInt = this.balance as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes LackBalanceForStateErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes LackBalanceForStateErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.balance != null) {
          const f = this.balance as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode LackBalanceForStateErrorKind
    } // LackBalanceForStateErrorKind

    export class TriesToUnstakeErrorKind {
      public account_id: string = "";

      // Decodes TriesToUnstakeErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): TriesToUnstakeErrorKind {
        return TriesToUnstakeErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes TriesToUnstakeErrorKind from a DataView
      static decodeDataView(view: DataView): TriesToUnstakeErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new TriesToUnstakeErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode TriesToUnstakeErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes TriesToUnstakeErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes TriesToUnstakeErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode TriesToUnstakeErrorKind
    } // TriesToUnstakeErrorKind

    export class TriesToStakeErrorKind {
      public account_id: string = "";
      public stake: BigInt = new BigInt();
      public locked: BigInt = new BigInt();
      public balance: BigInt = new BigInt();

      // Decodes TriesToStakeErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): TriesToStakeErrorKind {
        return TriesToStakeErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes TriesToStakeErrorKind from a DataView
      static decodeDataView(view: DataView): TriesToStakeErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new TriesToStakeErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.stake = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.locked = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.balance = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode TriesToStakeErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.stake != null) {
          const f: BigInt = this.stake as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.locked != null) {
          const f: BigInt = this.locked as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.balance != null) {
          const f: BigInt = this.balance as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes TriesToStakeErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes TriesToStakeErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.stake != null) {
          const f = this.stake as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.locked != null) {
          const f = this.locked as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.balance != null) {
          const f = this.balance as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode TriesToStakeErrorKind
    } // TriesToStakeErrorKind

    export class InsufficientStakeErrorKind {
      public account_id: string = "";
      public stake: BigInt = new BigInt();
      public minimum_stake: BigInt = new BigInt();

      // Decodes InsufficientStakeErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): InsufficientStakeErrorKind {
        return InsufficientStakeErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes InsufficientStakeErrorKind from a DataView
      static decodeDataView(view: DataView): InsufficientStakeErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new InsufficientStakeErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.stake = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.minimum_stake = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode InsufficientStakeErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        if (this.stake != null) {
          const f: BigInt = this.stake as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.minimum_stake != null) {
          const f: BigInt = this.minimum_stake as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes InsufficientStakeErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes InsufficientStakeErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        if (this.stake != null) {
          const f = this.stake as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.minimum_stake != null) {
          const f = this.minimum_stake as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode InsufficientStakeErrorKind
    } // InsufficientStakeErrorKind

    export class FunctionCallErrorKind {
      public error: u32;

      // Decodes FunctionCallErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): FunctionCallErrorKind {
        return FunctionCallErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes FunctionCallErrorKind from a DataView
      static decodeDataView(view: DataView): FunctionCallErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new FunctionCallErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.error = decoder.uint32();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode FunctionCallErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

        return size;
      }

      // Encodes FunctionCallErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes FunctionCallErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.error != 0) {
          encoder.uint32(0x8);
          encoder.uint32(this.error);
        }

        return buf;
      } // encode FunctionCallErrorKind
    } // FunctionCallErrorKind

    export class NewReceiptValidationErrorKind {
      public error: u32;

      // Decodes NewReceiptValidationErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): NewReceiptValidationErrorKind {
        return NewReceiptValidationErrorKind.decodeDataView(new DataView(buf));
      }

      // Decodes NewReceiptValidationErrorKind from a DataView
      static decodeDataView(view: DataView): NewReceiptValidationErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new NewReceiptValidationErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.error = decoder.uint32();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode NewReceiptValidationErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size += this.error == 0 ? 0 : 1 + __proto.Sizer.uint32(this.error);

        return size;
      }

      // Encodes NewReceiptValidationErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes NewReceiptValidationErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.error != 0) {
          encoder.uint32(0x8);
          encoder.uint32(this.error);
        }

        return buf;
      } // encode NewReceiptValidationErrorKind
    } // NewReceiptValidationErrorKind

    export class OnlyImplicitAccountCreationAllowedErrorKind {
      public account_id: string = "";

      // Decodes OnlyImplicitAccountCreationAllowedErrorKind from an ArrayBuffer
      static decode(
        buf: ArrayBuffer
      ): OnlyImplicitAccountCreationAllowedErrorKind {
        return OnlyImplicitAccountCreationAllowedErrorKind.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes OnlyImplicitAccountCreationAllowedErrorKind from a DataView
      static decodeDataView(
        view: DataView
      ): OnlyImplicitAccountCreationAllowedErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new OnlyImplicitAccountCreationAllowedErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode OnlyImplicitAccountCreationAllowedErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes OnlyImplicitAccountCreationAllowedErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode OnlyImplicitAccountCreationAllowedErrorKind
    } // OnlyImplicitAccountCreationAllowedErrorKind

    export class DeleteAccountWithLargeStateErrorKind {
      public account_id: string = "";

      // Decodes DeleteAccountWithLargeStateErrorKind from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeleteAccountWithLargeStateErrorKind {
        return DeleteAccountWithLargeStateErrorKind.decodeDataView(
          new DataView(buf)
        );
      }

      // Decodes DeleteAccountWithLargeStateErrorKind from a DataView
      static decodeDataView(
        view: DataView
      ): DeleteAccountWithLargeStateErrorKind {
        const decoder = new __proto.Decoder(view);
        const obj = new DeleteAccountWithLargeStateErrorKind();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.account_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeleteAccountWithLargeStateErrorKind

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.account_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.account_id.length) +
              this.account_id.length
            : 0;

        return size;
      }

      // Encodes DeleteAccountWithLargeStateErrorKind to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeleteAccountWithLargeStateErrorKind to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.account_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.account_id.length);
          encoder.string(this.account_id);
        }

        return buf;
      } // encode DeleteAccountWithLargeStateErrorKind
    } // DeleteAccountWithLargeStateErrorKind

    export class MerklePath {
      public path: Array<MerklePathItem> = new Array<MerklePathItem>();

      // Decodes MerklePath from an ArrayBuffer
      static decode(buf: ArrayBuffer): MerklePath {
        return MerklePath.decodeDataView(new DataView(buf));
      }

      // Decodes MerklePath from a DataView
      static decodeDataView(view: DataView): MerklePath {
        const decoder = new __proto.Decoder(view);
        const obj = new MerklePath();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.path.push(
                MerklePathItem.decodeDataView(
                  new DataView(
                    decoder.view.buffer,
                    decoder.pos + decoder.view.byteOffset,
                    length
                  )
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode MerklePath

      public size(): u32 {
        let size: u32 = 0;

        for (let n: i32 = 0; n < this.path.length; n++) {
          const messageSize = this.path[n].size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes MerklePath to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes MerklePath to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        for (let n: i32 = 0; n < this.path.length; n++) {
          const messageSize = this.path[n].size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            this.path[n].encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode MerklePath
    } // MerklePath

    export class MerklePathItem {
      public hash: CryptoHash = new CryptoHash();
      public direction: u32;

      // Decodes MerklePathItem from an ArrayBuffer
      static decode(buf: ArrayBuffer): MerklePathItem {
        return MerklePathItem.decodeDataView(new DataView(buf));
      }

      // Decodes MerklePathItem from a DataView
      static decodeDataView(view: DataView): MerklePathItem {
        const decoder = new __proto.Decoder(view);
        const obj = new MerklePathItem();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.hash = CryptoHash.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              obj.direction = decoder.uint32();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode MerklePathItem

      public size(): u32 {
        let size: u32 = 0;

        if (this.hash != null) {
          const f: CryptoHash = this.hash as CryptoHash;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.direction == 0 ? 0 : 1 + __proto.Sizer.uint32(this.direction);

        return size;
      }

      // Encodes MerklePathItem to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes MerklePathItem to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.hash != null) {
          const f = this.hash as CryptoHash;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.direction != 0) {
          encoder.uint32(0x10);
          encoder.uint32(this.direction);
        }

        return buf;
      } // encode MerklePathItem
    } // MerklePathItem

    export class Action {
      public create_account: CreateAccountAction | null;
      public deploy_contract: DeployContractAction | null;
      public function_call: FunctionCallAction | null;
      public transfer: TransferAction | null;
      public stake: StakeAction | null;
      public add_key: AddKeyAction | null;
      public delete_key: DeleteKeyAction | null;
      public delete_account: DeleteAccountAction | null;

      public __action: string = "";
      public __action_index: u8 = 0;

      static readonly ACTION_CREATE_ACCOUNT_INDEX: u8 = 1;
      static readonly ACTION_DEPLOY_CONTRACT_INDEX: u8 = 2;
      static readonly ACTION_FUNCTION_CALL_INDEX: u8 = 3;
      static readonly ACTION_TRANSFER_INDEX: u8 = 4;
      static readonly ACTION_STAKE_INDEX: u8 = 5;
      static readonly ACTION_ADD_KEY_INDEX: u8 = 6;
      static readonly ACTION_DELETE_KEY_INDEX: u8 = 7;
      static readonly ACTION_DELETE_ACCOUNT_INDEX: u8 = 8;

      // Decodes Action from an ArrayBuffer
      static decode(buf: ArrayBuffer): Action {
        return Action.decodeDataView(new DataView(buf));
      }

      // Decodes Action from a DataView
      static decodeDataView(view: DataView): Action {
        const decoder = new __proto.Decoder(view);
        const obj = new Action();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.create_account = CreateAccountAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "create_account";
              obj.__action_index = 1;
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.deploy_contract = DeployContractAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "deploy_contract";
              obj.__action_index = 2;
              break;
            }
            case 3: {
              const length = decoder.uint32();
              obj.function_call = FunctionCallAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "function_call";
              obj.__action_index = 3;
              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.transfer = TransferAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "transfer";
              obj.__action_index = 4;
              break;
            }
            case 5: {
              const length = decoder.uint32();
              obj.stake = StakeAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "stake";
              obj.__action_index = 5;
              break;
            }
            case 6: {
              const length = decoder.uint32();
              obj.add_key = AddKeyAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "add_key";
              obj.__action_index = 6;
              break;
            }
            case 7: {
              const length = decoder.uint32();
              obj.delete_key = DeleteKeyAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "delete_key";
              obj.__action_index = 7;
              break;
            }
            case 8: {
              const length = decoder.uint32();
              obj.delete_account = DeleteAccountAction.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__action = "delete_account";
              obj.__action_index = 8;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode Action

      public size(): u32 {
        let size: u32 = 0;

        if (this.create_account != null) {
          const f: CreateAccountAction = this
            .create_account as CreateAccountAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.deploy_contract != null) {
          const f: DeployContractAction = this
            .deploy_contract as DeployContractAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.function_call != null) {
          const f: FunctionCallAction = this
            .function_call as FunctionCallAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.transfer != null) {
          const f: TransferAction = this.transfer as TransferAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.stake != null) {
          const f: StakeAction = this.stake as StakeAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.add_key != null) {
          const f: AddKeyAction = this.add_key as AddKeyAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.delete_key != null) {
          const f: DeleteKeyAction = this.delete_key as DeleteKeyAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.delete_account != null) {
          const f: DeleteAccountAction = this
            .delete_account as DeleteAccountAction;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes Action to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes Action to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.create_account != null) {
          const f = this.create_account as CreateAccountAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.deploy_contract != null) {
          const f = this.deploy_contract as DeployContractAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.function_call != null) {
          const f = this.function_call as FunctionCallAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x1a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.transfer != null) {
          const f = this.transfer as TransferAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.stake != null) {
          const f = this.stake as StakeAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x2a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.add_key != null) {
          const f = this.add_key as AddKeyAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x32);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.delete_key != null) {
          const f = this.delete_key as DeleteKeyAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x3a);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.delete_account != null) {
          const f = this.delete_account as DeleteAccountAction;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x42);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode Action
    } // Action

    export class CreateAccountAction {
      // Decodes CreateAccountAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): CreateAccountAction {
        return CreateAccountAction.decodeDataView(new DataView(buf));
      }

      // Decodes CreateAccountAction from a DataView
      static decodeDataView(view: DataView): CreateAccountAction {
        const decoder = new __proto.Decoder(view);
        const obj = new CreateAccountAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode CreateAccountAction

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes CreateAccountAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes CreateAccountAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode CreateAccountAction
    } // CreateAccountAction

    export class DeployContractAction {
      public code: Array<u8> = new Array<u8>();

      // Decodes DeployContractAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeployContractAction {
        return DeployContractAction.decodeDataView(new DataView(buf));
      }

      // Decodes DeployContractAction from a DataView
      static decodeDataView(view: DataView): DeployContractAction {
        const decoder = new __proto.Decoder(view);
        const obj = new DeployContractAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.code = decoder.bytes();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeployContractAction

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.code.length > 0
            ? 1 + __proto.Sizer.varint64(this.code.length) + this.code.length
            : 0;

        return size;
      }

      // Encodes DeployContractAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeployContractAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.code.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.code.length);
          encoder.bytes(this.code);
        }

        return buf;
      } // encode DeployContractAction
    } // DeployContractAction

    export class FunctionCallAction {
      public method_name: string = "";
      public args: Array<u8> = new Array<u8>();
      public gas: u64;
      public deposit: BigInt = new BigInt();

      // Decodes FunctionCallAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): FunctionCallAction {
        return FunctionCallAction.decodeDataView(new DataView(buf));
      }

      // Decodes FunctionCallAction from a DataView
      static decodeDataView(view: DataView): FunctionCallAction {
        const decoder = new __proto.Decoder(view);
        const obj = new FunctionCallAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.method_name = decoder.string();
              break;
            }
            case 2: {
              obj.args = decoder.bytes();
              break;
            }
            case 3: {
              obj.gas = decoder.uint64();
              break;
            }
            case 4: {
              const length = decoder.uint32();
              obj.deposit = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode FunctionCallAction

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.method_name.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.method_name.length) +
              this.method_name.length
            : 0;
        size +=
          this.args.length > 0
            ? 1 + __proto.Sizer.varint64(this.args.length) + this.args.length
            : 0;
        size += this.gas == 0 ? 0 : 1 + __proto.Sizer.uint64(this.gas);

        if (this.deposit != null) {
          const f: BigInt = this.deposit as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes FunctionCallAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes FunctionCallAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.method_name.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.method_name.length);
          encoder.string(this.method_name);
        }
        if (this.args.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.args.length);
          encoder.bytes(this.args);
        }
        if (this.gas != 0) {
          encoder.uint32(0x18);
          encoder.uint64(this.gas);
        }

        if (this.deposit != null) {
          const f = this.deposit as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x22);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode FunctionCallAction
    } // FunctionCallAction

    export class TransferAction {
      public deposit: BigInt = new BigInt();

      // Decodes TransferAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): TransferAction {
        return TransferAction.decodeDataView(new DataView(buf));
      }

      // Decodes TransferAction from a DataView
      static decodeDataView(view: DataView): TransferAction {
        const decoder = new __proto.Decoder(view);
        const obj = new TransferAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.deposit = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode TransferAction

      public size(): u32 {
        let size: u32 = 0;

        if (this.deposit != null) {
          const f: BigInt = this.deposit as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes TransferAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes TransferAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.deposit != null) {
          const f = this.deposit as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode TransferAction
    } // TransferAction

    export class StakeAction {
      public stake: BigInt = new BigInt();
      public public_key: PublicKey = new PublicKey();

      // Decodes StakeAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): StakeAction {
        return StakeAction.decodeDataView(new DataView(buf));
      }

      // Decodes StakeAction from a DataView
      static decodeDataView(view: DataView): StakeAction {
        const decoder = new __proto.Decoder(view);
        const obj = new StakeAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.stake = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode StakeAction

      public size(): u32 {
        let size: u32 = 0;

        if (this.stake != null) {
          const f: BigInt = this.stake as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes StakeAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes StakeAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.stake != null) {
          const f = this.stake as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode StakeAction
    } // StakeAction

    export class AddKeyAction {
      public public_key: PublicKey = new PublicKey();
      public access_key: AccessKey = new AccessKey();

      // Decodes AddKeyAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): AddKeyAction {
        return AddKeyAction.decodeDataView(new DataView(buf));
      }

      // Decodes AddKeyAction from a DataView
      static decodeDataView(view: DataView): AddKeyAction {
        const decoder = new __proto.Decoder(view);
        const obj = new AddKeyAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.access_key = AccessKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AddKeyAction

      public size(): u32 {
        let size: u32 = 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.access_key != null) {
          const f: AccessKey = this.access_key as AccessKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes AddKeyAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AddKeyAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.access_key != null) {
          const f = this.access_key as AccessKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode AddKeyAction
    } // AddKeyAction

    export class DeleteKeyAction {
      public public_key: PublicKey = new PublicKey();

      // Decodes DeleteKeyAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeleteKeyAction {
        return DeleteKeyAction.decodeDataView(new DataView(buf));
      }

      // Decodes DeleteKeyAction from a DataView
      static decodeDataView(view: DataView): DeleteKeyAction {
        const decoder = new __proto.Decoder(view);
        const obj = new DeleteKeyAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.public_key = PublicKey.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeleteKeyAction

      public size(): u32 {
        let size: u32 = 0;

        if (this.public_key != null) {
          const f: PublicKey = this.public_key as PublicKey;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes DeleteKeyAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeleteKeyAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.public_key != null) {
          const f = this.public_key as PublicKey;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode DeleteKeyAction
    } // DeleteKeyAction

    export class DeleteAccountAction {
      public beneficiary_id: string = "";

      // Decodes DeleteAccountAction from an ArrayBuffer
      static decode(buf: ArrayBuffer): DeleteAccountAction {
        return DeleteAccountAction.decodeDataView(new DataView(buf));
      }

      // Decodes DeleteAccountAction from a DataView
      static decodeDataView(view: DataView): DeleteAccountAction {
        const decoder = new __proto.Decoder(view);
        const obj = new DeleteAccountAction();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.beneficiary_id = decoder.string();
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode DeleteAccountAction

      public size(): u32 {
        let size: u32 = 0;

        size +=
          this.beneficiary_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.beneficiary_id.length) +
              this.beneficiary_id.length
            : 0;

        return size;
      }

      // Encodes DeleteAccountAction to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes DeleteAccountAction to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.beneficiary_id.length > 0) {
          encoder.uint32(0xa);
          encoder.uint32(this.beneficiary_id.length);
          encoder.string(this.beneficiary_id);
        }

        return buf;
      } // encode DeleteAccountAction
    } // DeleteAccountAction

    export class AccessKey {
      public nonce: u64;
      public permission: AccessKeyPermission = new AccessKeyPermission();

      // Decodes AccessKey from an ArrayBuffer
      static decode(buf: ArrayBuffer): AccessKey {
        return AccessKey.decodeDataView(new DataView(buf));
      }

      // Decodes AccessKey from a DataView
      static decodeDataView(view: DataView): AccessKey {
        const decoder = new __proto.Decoder(view);
        const obj = new AccessKey();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              obj.nonce = decoder.uint64();
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.permission = AccessKeyPermission.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AccessKey

      public size(): u32 {
        let size: u32 = 0;

        size += this.nonce == 0 ? 0 : 1 + __proto.Sizer.uint64(this.nonce);

        if (this.permission != null) {
          const f: AccessKeyPermission = this.permission as AccessKeyPermission;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes AccessKey to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AccessKey to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.nonce != 0) {
          encoder.uint32(0x8);
          encoder.uint64(this.nonce);
        }

        if (this.permission != null) {
          const f = this.permission as AccessKeyPermission;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode AccessKey
    } // AccessKey

    export class AccessKeyPermission {
      public function_call: FunctionCallPermission | null;
      public full_access: FullAccessPermission | null;

      public __permission: string = "";
      public __permission_index: u8 = 0;

      static readonly PERMISSION_FUNCTION_CALL_INDEX: u8 = 1;
      static readonly PERMISSION_FULL_ACCESS_INDEX: u8 = 2;

      // Decodes AccessKeyPermission from an ArrayBuffer
      static decode(buf: ArrayBuffer): AccessKeyPermission {
        return AccessKeyPermission.decodeDataView(new DataView(buf));
      }

      // Decodes AccessKeyPermission from a DataView
      static decodeDataView(view: DataView): AccessKeyPermission {
        const decoder = new __proto.Decoder(view);
        const obj = new AccessKeyPermission();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.function_call = FunctionCallPermission.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__permission = "function_call";
              obj.__permission_index = 1;
              break;
            }
            case 2: {
              const length = decoder.uint32();
              obj.full_access = FullAccessPermission.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              obj.__permission = "full_access";
              obj.__permission_index = 2;
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode AccessKeyPermission

      public size(): u32 {
        let size: u32 = 0;

        if (this.function_call != null) {
          const f: FunctionCallPermission = this
            .function_call as FunctionCallPermission;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        if (this.full_access != null) {
          const f: FullAccessPermission = this
            .full_access as FullAccessPermission;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes AccessKeyPermission to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes AccessKeyPermission to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.function_call != null) {
          const f = this.function_call as FunctionCallPermission;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.full_access != null) {
          const f = this.full_access as FullAccessPermission;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0x12);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode AccessKeyPermission
    } // AccessKeyPermission

    export class FunctionCallPermission {
      public allowance: BigInt = new BigInt();
      public receiver_id: string = "";
      public method_names: Array<string> = new Array<string>();

      // Decodes FunctionCallPermission from an ArrayBuffer
      static decode(buf: ArrayBuffer): FunctionCallPermission {
        return FunctionCallPermission.decodeDataView(new DataView(buf));
      }

      // Decodes FunctionCallPermission from a DataView
      static decodeDataView(view: DataView): FunctionCallPermission {
        const decoder = new __proto.Decoder(view);
        const obj = new FunctionCallPermission();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.allowance = BigInt.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }
            case 2: {
              obj.receiver_id = decoder.string();
              break;
            }
            case 3: {
              obj.method_names.push(decoder.string());
              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode FunctionCallPermission

      public size(): u32 {
        let size: u32 = 0;

        if (this.allowance != null) {
          const f: BigInt = this.allowance as BigInt;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        size +=
          this.receiver_id.length > 0
            ? 1 +
              __proto.Sizer.varint64(this.receiver_id.length) +
              this.receiver_id.length
            : 0;

        size += __size_string_repeated(this.method_names);

        return size;
      }

      // Encodes FunctionCallPermission to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes FunctionCallPermission to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.allowance != null) {
          const f = this.allowance as BigInt;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        if (this.receiver_id.length > 0) {
          encoder.uint32(0x12);
          encoder.uint32(this.receiver_id.length);
          encoder.string(this.receiver_id);
        }

        if (this.method_names.length > 0) {
          for (let n: i32 = 0; n < this.method_names.length; n++) {
            encoder.uint32(0x1a);
            encoder.uint32(this.method_names[n].length);
            encoder.string(this.method_names[n]);
          }
        }

        return buf;
      } // encode FunctionCallPermission
    } // FunctionCallPermission

    export class FullAccessPermission {
      // Decodes FullAccessPermission from an ArrayBuffer
      static decode(buf: ArrayBuffer): FullAccessPermission {
        return FullAccessPermission.decodeDataView(new DataView(buf));
      }

      // Decodes FullAccessPermission from a DataView
      static decodeDataView(view: DataView): FullAccessPermission {
        const decoder = new __proto.Decoder(view);
        const obj = new FullAccessPermission();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode FullAccessPermission

      public size(): u32 {
        let size: u32 = 0;

        return size;
      }

      // Encodes FullAccessPermission to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes FullAccessPermission to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        return buf;
      } // encode FullAccessPermission
    } // FullAccessPermission
  } // v1
} // sf
export namespace receipts {
  export namespace v1 {
    export class BlockAndReceipts {
      /**
       * repeated sf.near.codec.v1.ExecutionOutcomeWithId outcome = 2;
       *  repeated sf.near.codec.v1.Receipt receipt = 3;
       */
      public block: sf.near.codec.v1.Block = new sf.near.codec.v1.Block();

      // Decodes BlockAndReceipts from an ArrayBuffer
      static decode(buf: ArrayBuffer): BlockAndReceipts {
        return BlockAndReceipts.decodeDataView(new DataView(buf));
      }

      // Decodes BlockAndReceipts from a DataView
      static decodeDataView(view: DataView): BlockAndReceipts {
        const decoder = new __proto.Decoder(view);
        const obj = new BlockAndReceipts();

        while (!decoder.eof()) {
          const tag = decoder.tag();
          const number = tag >>> 3;

          switch (number) {
            case 1: {
              const length = decoder.uint32();
              obj.block = sf.near.codec.v1.Block.decodeDataView(
                new DataView(
                  decoder.view.buffer,
                  decoder.pos + decoder.view.byteOffset,
                  length
                )
              );
              decoder.skip(length);

              break;
            }

            default:
              decoder.skipType(tag & 7);
              break;
          }
        }
        return obj;
      } // decode BlockAndReceipts

      public size(): u32 {
        let size: u32 = 0;

        if (this.block != null) {
          const f: sf.near.codec.v1.Block = this
            .block as sf.near.codec.v1.Block;
          const messageSize = f.size();

          if (messageSize > 0) {
            size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;
          }
        }

        return size;
      }

      // Encodes BlockAndReceipts to the ArrayBuffer
      encode(): ArrayBuffer {
        return changetype<ArrayBuffer>(
          StaticArray.fromArray<u8>(this.encodeU8Array())
        );
      }

      // Encodes BlockAndReceipts to the Array<u8>
      encodeU8Array(
        encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())
      ): Array<u8> {
        const buf = encoder.buf;

        if (this.block != null) {
          const f = this.block as sf.near.codec.v1.Block;

          const messageSize = f.size();

          if (messageSize > 0) {
            encoder.uint32(0xa);
            encoder.uint32(messageSize);
            f.encodeU8Array(encoder);
          }
        }

        return buf;
      } // encode BlockAndReceipts
    } // BlockAndReceipts
  } // v1
} // receipts

// __size_bool_repeated_packed

function __size_bool_repeated_packed(value: Array<bool>): u32 {
  let size: u32 = 0;

  for (let n: i32 = 0; n < value.length; n++) {
    size += 1;
  }

  return size;
}

// __size_string_repeated

function __size_string_repeated(value: Array<string>): u32 {
  let size: u32 = 0;

  for (let n: i32 = 0; n < value.length; n++) {
    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;
  }

  return size;
}
